{"meta":{"title":"Seha's Devlog","subtitle":"Seha 개발 블로그","description":"Junior Developer","author":"Sehajyang","url":"https://sehajyang.github.io","root":"/"},"pages":[{"title":"about","date":"2019-06-19T08:29:11.000Z","updated":"2019-08-02T14:41:53.817Z","comments":false,"path":"about/index.html","permalink":"https://sehajyang.github.io/about/index.html","excerpt":"","text":"Seha안녕하세요 주니어 개발자 세하 입니다.현재 Springboot 로 웹 개발을 하고 있으며 Python 으로 그 외 개발을 하고있습니다.코드 품질을 위한 CleanCode 를 지향하고 있으며 테스트코드 짜는것을 중요하게 생각합니다.욕심내되 꾸준히 하자는 모토로 공부중이며 이 블로그는 그러한 취지로 운영됩니다 😊 토이프로젝트를 종종 진행하고 있으며, 해당 프로젝트들은 제 GitHub 에서 좀 더 자세하게 볼 수 있습니다. Skill SetStack ShareJava / Python / ShellJavaScript / Node.jsSpring / Springboot / FlaskAWSLinuxMySQL / Oracle / MongoDB / RedisIntelliJ / PyCharm / VS Code / WebStorm / Vim LearningScala Interesting서비스 확장 및 유지보수를 위한 품질 좋은 코드 및 TDD(BDD)를 중요하게 생각합니다.함수형 프로그래밍에 관심을 가지고 공부하고 있습니다. Work Experience2018.11 ~ Now / Herren Backend Developer고객관리 관련 서비스 유지보수 및 서버/벡엔드 개발, 인프라 구축을 담당했습니다. Development Python, Java, Springboot, JPA, MyBatis, Gradle, Mysql, H2, Lombok JavaScript, HTML, CSS GitLab Jenkins, Docker IntelliJ, WebStorm, VSCode AWS (EC2, RDS, S3, DynamoDB) 기능 개발, 레거시 코드 리팩토링 및 클린코드를 위한 통합 테스트코드 작성(커버리지 80%) GitLab, Jenkins, Slack 을 이용해 CI/CD 환경 구축 및 알림 시간 및 자원이 많이 소요되던 기존 Python 코드를 Asyncio 등 으로 리팩토링해 비동기로 처리 Side Projectsimple-anonymous-board 사내 익명게시판 구현을 위해 Springboot 를 이용해 공지/익명 게시판을 개발했습니다. 이중 암호화로 강력한 익명을 지원하며, 일정 수 이상의 [좋아요] 를 받은 게시물은 슬랙의 특정 채널에 전송됩니다. sanic-chatting-project 채팅 웹은 실시간성이 중요하기 때문에 Python의 비동기 프레임워크인 Sanic을 활용해 개발했습니다. 메세지는 Redis 의 PUB/SUB 을 활용해 빠른 입출력을 구현했으며, 유저 데이터는 PostgreSql 에 저장됩니다. Prizes [2019.06.02] AngelHack Global Hackaton Series 2019 Seoul 전체 우승 Translate Scala Exercises Tutorial 번역 SlideShare 클린코드와 TDD (1부) 클린코드와 테스트코드 (2부) Javascript 생태계 Activities2019 190223 KCD(Korea Community Day) 2019 190316 프론트엔드와 무관합니다만, 190427 Spring camp 2019 190602 AngelHackaton Seoul 2019 190630 I/O Extended 2019 Seoul 2018 180628 OpenInfra Days Korea 2018 180628 SmartTech in Korea 2018 180708 개발자의 생존전략 41기 180715 웹 취약점 진단 교육 180728 Seoul.js Lightning Talk 180809 [OKKY 세미나] 오픈소스, 줘도 못 먹나 - 오픈소스로 팀의 개발 생산성 높이기 후기 180901 남궁성님 C 언어 포인터 세미나 180919 [AUSG Seminar Series] 2018 F/W 초보자를 위한 AWS 뿌시기 180920 [T academy]스프링부트를 이용한 웹 서비스 개발하기 181006 Dev Django Korea 2018 Contact궁금한 사항 혹은 문의사항은 아래로 보내주세요 😄sehajyang@gmail.comTwitterGitHubLinkedIn"},{"title":"","date":"2019-07-15T14:11:55.604Z","updated":"2019-07-15T14:11:55.604Z","comments":false,"path":"categories/index.html","permalink":"https://sehajyang.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2019-07-15T14:11:55.651Z","updated":"2019-07-15T14:11:55.651Z","comments":false,"path":"tags/index.html","permalink":"https://sehajyang.github.io/tags/index.html","excerpt":"","text":""},{"title":"springboot migration","date":"2019-05-06T15:00:00.000Z","updated":"2019-08-02T14:41:53.824Z","comments":true,"path":"java/2019/05/07/springboot-migration-1.5to2.0.html/index.html","permalink":"https://sehajyang.github.io/java/2019/05/07/springboot-migration-1.5to2.0.html/index.html","excerpt":"","text":"공식 가이드대로 했을때 몇가지 오류때문에 버전 업그레이드가 잘 되지 않았었기 때문에 삽질을 줄이고자 이 포스팅을 작성하게 되었습니다 😊필수 사항 : JDK 8 이상 우선, 버전을 마이그레이션 할 때몇가지 라이브러리들은 버전을 업그레이드 해주지 않으면 에러가 납니다.그리고 한방에 버전을 쭉 올려버리면 오류를 잡았음에도 불구하고 자꾸 알수 없는 오류가 발생하며 빌드가 되지 않습니다(혹 이유를 아신다면 코멘트 부탁드리겠습니다 🙇)따라서 1.5 -&gt; 2.0 -&gt; 2.1 순서로 버전을 업그레이드 했습니다. 순서1. gradle 버전이 4.4 가 아닐경우 4.4-all 로 변경gradle &gt; wrapper &gt; gradle-wrapper.properties 에서 아래와 같이 gradle 버전을 수정합니다. 1distributionUrl=https\\://services.gradle.org/distributions/gradle-4.4-all.zip 2. build.gradle에 dependency-management를 추가12apply plugin: 'io.spring.dependency-management'runtime(\"org.springframework.boot:spring-boot-properties-migrator\") 3. springboot 버전 바꾸기1springBootVersion = '2.0.5.RELEASE' 아래부턴 쓰는 라이브러리가 다양하기 때문에버전 업그레이드로 인한 특정 라이브러리 설정의 변화로 발생하는 오류를 고치는 방법을 작성할 수 없었습니다. 대신 어떻게 고쳐야 하는지에 대한 문서는 common-application-properties 공식문서 링크 위 링크를 참고하시면 될 것 같습니다. 4. 빌드만약 컴파일 오류가 난다면 해당되는 오류를 고칩니다.(ex: log4j 오류가 나서 log4j2로 고쳤습니다) 5. application.properties 수정빌드 깨진 것을 확인 후 해당 설정을 application.properties에서 적절하게 고칩니다.(여담으로 datasource 쪽에서 자꾸 오류가 났습니다) 6. bean overridingorg.springframework.beans.factory.support.Bean Definition Override Exception위의 오류가 발생하면 application.properties 에 아래 코드를 추가합니다.spring.main.allow-bean-definition-overriding=true이것은 bean overriding을 허용한다는 것 입니다. 12The server time zone value ‘KST’ is unrecognized or represents more than one time zone : mysql-connector-java 위의 오류가 발생하면 아래와 같이 DB url의 DB명 뒤에 ?characterEncoding=UTF-8&amp;serverTimezone=Asia/Seoul 를 추가합니다 1jdbc:mysql://아이피:포트/DB명?characterEncoding=UTF-8&amp;serverTimezone=Asia/Seoul 7. 버전 업그레이드 2.0 -&gt; 2.1빌드 및 run이 성공적으로 되면 build.gradle에서 2.1.3.RELEASE 로 springboot 버전을 변경합니다. 1springBootVersion = '2.1.3.RELEASE' 그 후 위의 작업을 반복하며 오류를 잡으면 됩니다.2.1 버전 부턴 mysql 드라이버 명이 변경되었습니다. 12기존 : com.mysql.jdbc.Driver바뀐것 : com.mysql.cj.jdbc.Driver 8. properties-migrator 제거빌드 및 run이 성공적으로 되면 build.gradle 에서 추가해뒀던 아래 코드를 제거 합니다. 1runtime(\"org.springframework.boot:spring-boot-properties-migrator\") 혹 내용이 잘못되었거나 보충해야 될 부분이 있다면 코멘트 남겨주세요 🙏읽어주셔서 감사합니다 :) 추가(19.5월 기준) 만약 swagger를 쓰는데 마이그레이션 시 오류 날 경우 2.9.1로 올려주셔야 됩니다 :) 참고자료 spring-boot-migration-java 공식문서"},{"title":"gitlab에 이미 push된 commit 삭제","date":"2019-03-10T15:00:00.000Z","updated":"2019-08-02T14:41:53.829Z","comments":true,"path":"tip/2019/03/11/git-reset-push.html/index.html","permalink":"https://sehajyang.github.io/tip/2019/03/11/git-reset-push.html/index.html","excerpt":"","text":"gitlab, github등에 취소해야 되는 commit이 있는데 이미 push 해버렸을 때git bash에서 1git reset --hard 되돌아가고자 하는 커밋주소 커밋 주소는 git log 로 알 수 있다 reset 옵션으론 hard, soft, mixed 가 있다 링크 그 후 1git push origin +브랜치명 브랜치 명 앞에 +를 붙여야 한다(덮어씌운다는 의미)+ 없이 push 해버리면 최근 커밋을 pull 하라며 에러가 난다. 만약 1! [remote rejected] master -&gt; master (pre-receive hook declined) 이런 에러가 났다면 해당 project settings &gt; Repository &gt; Protected Branches에서 unprotected로 해당 브랜치를 설정해주면 된다 (보통 master에 걸려있음)"},{"title":"Kotlin 에서 Lombok을 사용할 수 없는 문제","date":"2019-03-06T15:00:00.000Z","updated":"2019-07-15T14:11:55.607Z","comments":true,"path":"etc/2019/03/07/kotlin-and-lombok.html/index.html","permalink":"https://sehajyang.github.io/etc/2019/03/07/kotlin-and-lombok.html/index.html","excerpt":"","text":"최근 자바 스프링부트로 되어있는 사내 프로젝트에 코틀린을 일부분 도입하려다 대차게 실패했다..사내 프로젝트에 Lombok을 사용하고 있었는데, 코틀린이 롬복을 사용한 Bean Class 에 접근하지 못하고 있었다. 당시 1Kotlin: Cannot access &apos;가가&apos; it is private member of &apos;나나&apos; 이런 에러 메세지를 띄우며 컴파일이 되지 않았다. 처음엔 자바로 짜여진 클래스의 private object에 접근을 못해서 나는 에러인 줄 알았으나 롬복 문제였다.kotlin-doesnt-see-java-lombok-accessors그리고 위 링크에서 이유를 알 수 있었다. 위 링크를 요약하자면 일반적으로 JVM 에선 코틀린이 먼저 컴파일 된 후 자바가 컴파일 된다.코틀린이 자바의 롬복으로 된 클래스에 접근하려 했으나 getter setter가 만들어지지 않아서 접근을 하지 못한다.롬복은 컴파일시 동작 하는 어노테이션이기 때문이다.강제로 컴파일러가 자바 먼저 컴파일하게 바꿀 순 있지만 그렇게 되면 자바에서 코틀린 코드를 사용할 수 없다. 코틀린과 자바가 100% 호환은 맞지만 자바로 만들어진 third-party 라이브러리 들과 호환 되는건 아닌 것 이다.롬복을 사용한 자바 파일들을 전부 코틀린으로 바꾸지 않는 한 코틀린을 현재 진행 중인 프로젝트에 적용 하긴 힘들 것 같다. 두줄요약 코틀린과 롬복을 같이 쓸 수 없다. 코틀린을 정말 쓰고싶다면 롬복을 사용한 자바 파일을 코틀린 파일로 바꿔야 된다. 19.06.26 기준 자세한 포스팅이 나왔습니다! Naver D2 Kotlin 도입 과정에서 만난 문제와 해결 방법 혹 궁금하거나 오류가 있다면 댓글 남겨주세요😄"},{"title":"mybatis association","date":"2019-02-17T15:00:00.000Z","updated":"2019-08-02T14:41:53.819Z","comments":true,"path":"java/2019/02/18/mybatis-association.html/index.html","permalink":"https://sehajyang.github.io/java/2019/02/18/mybatis-association.html/index.html","excerpt":"","text":"Lombok 사용Service 생략 File Shop.java ShopDetail.java ShopMapper.xml Shop.java 12345678@Datapublic class Shop &#123; private String shopno; private String id; private String pwd; private ShopDetail shopDetail; //변수명 앞문자 capital 주면 안됨(getter, setter 때문)&#125; ShopDetail.java 123456public class ShopDetail &#123; private String shopno; private String name; private String price; private String count;&#125; ShopMapper.xml 123456789101112131415161718&lt;!-- 중략 --&gt;&lt;mapper namespace=\"com.test.mapper.ShopMapper\"&gt; &lt;resultMap id=\"ShopMap\" type=\"com.test.domain.Shop\"&gt; &lt;result property=\"shopno\" column=\"shopno\" /&gt; &lt;result property=\"id\" column=\"id\" /&gt; &lt;result property=\"pwd\" column=\"pwd\" /&gt; &lt;association property=\"shopDetail\" javaType=\"com.test.domain.ShopDetail\"&gt; &lt;result property=\"shopno\" column=\"shopno\" /&gt; &lt;result property=\"name\" column=\"name\" /&gt; &lt;result property=\"price\" column=\"price\" /&gt; &lt;result property=\"count\" column=\"count\" /&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id = \"selectTestQuery\" resultMap = \"ShopMap\"&gt; select s.*, sd.* from shop s join shopdetail sd on s.shopno = sd.shopno &lt;/select&gt; Result1Shop[(shopno=1, id=aa, pwd=1234, shopDetail=shopDetail(shopno=1, name=김뭐뭐, price=1000, count=100))] association, result map collection 등으로 검색하면 더 자세히 알 수 있습니다."},{"title":"Springboot 에서 test code 작성하기 1편 - 통합테스트","date":"2019-04-04T15:00:00.000Z","updated":"2019-08-02T14:41:53.820Z","comments":true,"path":"java/2019/04/05/springboot-test-code-1.html/index.html","permalink":"https://sehajyang.github.io/java/2019/04/05/springboot-test-code-1.html/index.html","excerpt":"","text":"Springboot 에서 test code 작성하기 시리즈 Springboot 에서 test code 작성하기 1편 - 통합테스트(MVC) Springboot 에서 test code 작성하기 2편 - 단위테스트(Service) Springboot 에서 test code 작성하기 3편 - assetThat이 중복되는 테스트와 Spock 최근 사내 프로젝트에 테스트 코드를 작성할 기회가 있었다.컨트롤러는 운영 환경과 비슷하게 테스트 하기 위해 통합 테스트, 서비스는 의존성을 줄이고 해당 서비스의 목표에만 집중하기 위해 단위테스트를 하기로 결정했다.목표는 해당 컨트롤러의 메소드가 잘 동작하는지(요청을 잘 보내고 예상한 응답을 잘 받는지), 서비스가 개별적으로 잘 동작하는지 확인하는 것 이다. 테스트에 관한 글을 찾아보던 중 우아한형제들 기술블로그에서 테스트 메소드의 이름을 한글로 짓는다는 것을 알게 되었다.테스트가 실패했을 때 어느 기능에서 오류가 났는지 직관적으로 알 수 있어 좋은 것 같아서 테스트 메소드 명을 한글로 작성했다. 1. MVC 컨트롤러 통합 테스트목표는 고객 정보를 조회 및 등록하는 메소드를 통합테스트 하는 것 이다.컨트롤러 통합 테스트는 클래스 상단에 @SpringbootTest 을 선언한다.모든 Bean을 올리는 것으로 다른 테스트에 비해 테스트 시간이 오래 소요되지만 운영환경과 비슷하게 테스트 할 수 있다.따라서 클래스에 선언한 어노테이션은 다음과 같다. 어노테이션 설명 @RunWith(SpringRunner.class) 테스트를 실행하기 위해 참조하는 클래스(SpringRunner) @AutoConfigureWebMvc MVC와 관련된 Bean을 올린다 @Transactional 테스트 후 DB 롤백 @Ignore 실제로 실행할 필요가 없기 때문에 Ignore를 선언 @SpringBootTest 모든 Bean을 올리는 통합 테스트 123456789101112131415161718192021222324252627/** * @author sehajyang * @date 2019-04-05 */@RunWith(SpringRunner.class) @AutoConfigureWebMvc @Transactional @Ignore @SpringBootTest public class CustomerControllerTest &#123; @Autowired private MockMvc mvc; @Autowired private WebApplicationContext webApplicationContext; @SpyBean private CustomerService customerService; @Autowired private ObjectMapper objectMapper; private MockHttpSession session = new MockHttpSession(); private MockHttpServletRequest request = new MockHttpServletRequest(); @SpyBean은 해당 객체를 주입받아 사용하다 given을 주면 선언한 해당 기능으로 동작하는 Bean 이다. 고객정보를 조회 및 등록하는 메소드가 있는 도메인 인 CustomerController 가 있다.아래 코드는 예시입니다. 12345678910111213141516171819202122232425262728293031@Controller@RequestMapping(\"customer\")public class CustomerController &#123; @Autowired CustomerService customerService; @GetMapping(\"\") public ModelAndView getCustomerList(HttpSession session, HttpServletRequest request)&#123; ModelAndView mav = new ModelAndView(\"customerListPage\"); List&lt;Customer&gt; customerList = customerService.getCustomerList(); mav.addObject(\"customerList\", customerList); return mav; &#125; @PostMapping(\"\") public Object regCustomerData(@RequestBody Customer customer, HttpSession session, HttpServletRequest request)&#123; // 기존에 해당 유저가 있는지 확인후 등록하는 메소드 (이렇게 하면 안됩니다(예시일뿐!)) int result; int userExist = shopService.getCustomerByCustno(customer.getCustno(1)); if(userExist &lt; 1)&#123; return Constant.RESULT_FAIL; &#125;else&#123; result = shopService.regCustomerData(customer); &#125; return (result &gt; 0) ? Constant.RESULT_SUCCESS : Constant.RESULT_FAIL; &#125;&#125; 코드상엔 없지만 CustomerController의 모든 메소드의 session과 header에는 특정 값이 셋팅되어 있어야 한다고 가정한다.따라서 위 getCustomerList 를 테스트 하는 코드는 다음과 같다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Before //테스트 수행시 실행 public void setUp() &#123; //Integration Test this.mvc = MockMvcBuilders.webAppContextSetup(webApplicationContext) .dispatchOptions(true) //HTTP TRACE 요청을 디스패치할지 여부를 설정 (default는 false) .alwaysDo(print()) .build(); session.setAttribute(\"Id\", \"셋팅 값\"); request.addHeader(\"X-FORWARDED-FOR\", \"셋팅 값\"); &#125; @Test public void 고객리스트_조회가_정상적으로_되어야한다() throws Exception &#123; List&lt;Customer&gt; customerList = customerService.getCustomerList(); this.mvc.perform(get(\"/customer\") .session(session) .header(\"X-FORWARDED-FOR\", request.getHeader(\"X-FORWARDED-FOR\")) ) .andExpect(status().isOk()) // 200 return .andExpect(view().name(\"customerListPage\")) // 리턴할 view page name .andExpect(model().attribute(\"customerList\", customerList)); // 리턴할 model attribute name // redirect 리턴일 경우 //.andExpect(redirectedUrl(\"/\")) //.andExpect(status().is3xxRedirection()) &#125; @Test public void 고객정보_등록이_예외없이_되어야한다() throws Exception &#123; Customer customer = new Customer(\"1\",\"sehajyang\"); // Customer(custno, custname) given(customerService.getCustomerByCustno(customer.getCustno())).willReturn(1); // getCustomerByCustno 의 result는 1을 리턴 this.mvc.perform(post(\"/customer\") .contentType(MediaType.APPLICATION_JSON) .content(objectMapper.writeValueAsString(customer)) // JSON으로 만들어준다 .session(session) .header(\"X-FORWARDED-FOR\", request.getHeader(\"X-FORWARDED-FOR\")) ) .andExpect(status().isOk()) .andExpect(content().string(\"SUCCESS\")) .andReturn() .getResponse(); &#125; 그 밖에도 param() 등 으로 파라미터를 넘길수도 있다.이렇게 Controller를 통합테스트 를 실행해 전체 플로우를 테스트 할 수 있다. @SessionAttributes를 사용하는 방법도 있는데 이 경우엔 테스트 코드에서 requestAttr() 대신 sessionAttr()을 사용할 수 있다.이 방법은 이곳의 예제로 확인할 수 있다. 만약 123@PostMapping(\"\")public Object regCustomerData(Customer customer, HttpSession session, HttpServletRequest request)&#123; 이렇게 DTO에 @RequestBody가 없는 도메인을 테스트하려면 조금 복잡해진다.나는 회사 코드의 POST 도메인 파라미터 DTO에 일부 @RequestBody가 없었고, @RequestBody를 추가 할 경우 문제가 생길 수 있었기 때문에기존 코드를 변경하지 않고 테스트 하는 방법을 찾아보았다. 우선 Spring에서는 권장하지 않는다 그 이유는 아래와 같다.대략 이렇게 이해할 수 있다. 통합 테스트의 주 목적 중 하나는 MockMvc 모델 객체가 Object 데이터로 바뀌었는지 확인하는 것 이다.NewObject(DTO)를 자동으로 변환하면 NewObject(DTO)가 실제 form과 호환되지 않는 문제가 있는데, 이러한 문제가 있는 파라미터는 테스트에서 제외되기 때문이다. 그래서 @RequestBody가 없는 도메인의 DTO 파라미터는 십중팔구 넘어가지 않으며 null이된다.이것을 해결하기 위한 방법은 두가지 정도가 있다. HttpClient 사용1234567891011121314151617@Test public void 고객정보_등록이_예외없이_되어야한다() throws Exception &#123; Customer customer = new Customer(\"1\",\"sehajyang\"); // Customer(custno, custname) given(customerService.getCustomerByCustno(customer.getCustno())).willReturn(1); // getCustomerByCustno 의 result는 1을 리턴 this.mvc.perform(post(\"/customer\") .contentType(MediaType.APPLICATION_FORM_URLENCODED) .content(EntityUtils.toString(new UrlEncodedFormEntity(Arrays.asList( new BasicNameValuePair(\"custno\", \"1\"), new BasicNameValuePair(\"custname\", \"sehajyang\") ))))) .andExpect(status().isOk()) .andExpect(content().string(\"SUCCESS\")) .andReturn() .getResponse(); &#125; buildUrlEncodedFormEntity() 이용1234567891011121314151617181920212223242526272829303132333435363738394041@Test public void 고객정보_등록이_예외없이_되어야한다() throws Exception &#123; Customer customer = new Customer(\"1\",\"sehajyang\"); // Customer(custno, custname) given(customerService.getCustomerByCustno(customer.getCustno())).willReturn(1); // getCustomerByCustno 의 result는 1을 리턴 this.mvc.perform(post(\"/customer\") .contentType(MediaType.APPLICATION_FORM_URLENCODED) .contentType(MediaType.APPLICATION_FORM_URLENCODED) .content(buildUrlEncodedFormEntity( \"custno\",\"1\", \"custname\",\"sehajyang\" )))) .andExpect(status().isOk()) .andExpect(content().string(\"SUCCESS\")) .andReturn() .getResponse(); &#125;private String buildUrlEncodedFormEntity(String... params) &#123; if( (params.length % 2) &gt; 0 ) &#123; throw new IllegalArgumentException(\"Need to give an even number of parameters\"); &#125; StringBuilder result = new StringBuilder(); for (int i=0; i&lt;params.length; i+=2) &#123; if( i &gt; 0 ) &#123; result.append('&amp;'); &#125; try &#123; result. append(URLEncoder.encode(params[i], StandardCharsets.UTF_8.name())). append('='). append(URLEncoder.encode(params[i+1], StandardCharsets.UTF_8.name())); &#125; catch (UnsupportedEncodingException e) &#123; throw new RuntimeException(e); &#125; &#125; return result.toString(); &#125; Testing Form posts through MockMVC에서 더 알아볼 수 있다. 위 시리즈는 3부로 나뉘어 통합테스트, 단위테스트, spock를 사용한 테스트로 작성 될 예정입니다.많이 미숙하지만 지속적으로 알아가고 있습니다.혹 틀린 부분 혹은 궁금한 점이 있다면 댓글 부탁드리겠습니다 읽어주셔서 감사합니다!🙏 참고자료 Mokito 공식 문서 Mokito github wiki Yun 님의 Test Guide"},{"title":"spring camp 2019 참석 후기 (1부)","date":"2019-04-28T15:00:00.000Z","updated":"2019-08-02T14:41:53.826Z","comments":true,"path":"seminar/2019/04/29/springcamp-2019-review.html/index.html","permalink":"https://sehajyang.github.io/seminar/2019/04/29/springcamp-2019-review.html/index.html","excerpt":"","text":"spring camp 2019를 다녀왔다! 티켓팅이 정말 어려웠기 때문에, 지인이나 회사의 다른 개발자분이 티켓팅에 실패해서 혼자 다녀왔다.공개된 세션들은 지금 내가 개발하고 있는 프로젝트에 많은 도움이 될 것 같아서 정말 기대를 많이 했다.특히 실전에 써먹는 스프링부트 나 Monitoring With Actuator, 무엇을 테스트할 것인가? 어떻게 테스트할 것인가?, Kotlin 프로젝트를 피할 수 없을 때 라는 세션이 그러했다.최근 테스트를 내가 제대로 하고 있는지에 대한 의문이 있었고, 모니터링에 대한 필요성을 느끼고 있어서였다.Kotlin은 저번에 Springboot에 붙이려다 실패했었기 때문에 위의 세션이 기대가 됐다.세션은 오전 10:40 분 부터 시작했는데 가는길에 시간이 조금 걸려 조금 지각을 해버렸다.로비에 들어가니 팔찌와 스티커 그리고 휴대용 선풍기를 줬다(왜인지는 모르겠는데 많은 개발세미나에선 휴대용 선풍기를 준다)굿즈를 받아들고 Track 1의 실전에 써먹는 스프링부트를 들었다.중후반에 들어왔기 때문에 아쉽게 기록을 하지 못했다. 정말 아쉬웠다. Monitoring With Actuator두번째로 들은 세션은 Monitoring With Actuator 였다.보안에 대한 의문이 있었기 때문에 예전에 한번 도입하려다 그냥 포기했었는데, 이 세션에서 어떻게 사용해야 하며 모니터링을 도와주는 도구 및 팁과룰에 대한 다양한 설명을 들을 수 있었다.Actuator는 springboot 2.0 부터 사용할 수 있는데, 다행히 저번에 버전업을 해서 도입한다면 바로 도입할 수 있을 것 같았다. 1.5에서도 사용할 수 있지만 제약사항이 많았다. Spring Actuator 란? 장애 예방, 원인파악 및 조치, 상태확인, 성능개선, 서비스상태분석을 위함 제어 도구 = endpoint 지표 제공 = metrics 사용중인 라이브러리 탐지도 한다 default endpoint default 는 health, info 만 제공 properties에서 설정할 수 있다. Enabling Endpoints web &gt; rest(health,info)로 보여줌 jmx &gt; 셧다운 제외한 모든 정보를 보여줌 spring boot 2.0 부터 spring security에 통합 혹은 따로 서버에 띄우는 방법(총 두개)으로 사용 가능 접근 가능 ip 설정 가능 Metrics 2.0 부터 특정 지표상의 key value 쌍의 지표 tag로 검색 가능 반드시 측정해야 할 지표 (RED Method) (Request)Rate (Request)Error (Request)Duration outcome code =&gt; status 간단히 잘 볼수있음 Micrometer Registry, Meter, Tag spring boot 2.0부터 지원 meterregistry cloudwatch도 있음! 자바에서 null을 안전하게 다루는 방법세번째로 들은 세션은 자바에서 null을 안전하게 다루는 방법 이었다. 내 생각에, 자바에서 가장 많이 일어나는 Exception은 nullPointer exception이 아닐까 싶다.인기가 정말 많았던 세션이라 아쉽게도 좌석 부족으로 서서 들어 기록을 하진 못했지만 ppt가 공개되었다! ppt 링크너무 너무 유익한 세션이었다. 만약 해당 강연을 듣지 못한 분은 ppt를 보고 이 강연이 얼마나 유익했을지 알 수 있을거라 생각한다.해당 세션이 끝난 후 한시즈음 점심을 먹었다. 배달의 민족 측에서 준비한 도시락이었다. 보통 세미나에선 샌드위치를 주는데 한식을 줘서 좋았다 :D 무엇을 테스트할 것인가? 어떻게 테스트할 것인가?네번째 세션은 정말 기대하던 TDD 세션이었다. TDD라기보단 테스트 세션이었지만 그래서 더 좋았다.그간 인터넷을 찾아보며 나름대로 테스트코드를 작성해오고 있었는데, 맞게 작성하고 있는지, 이건 테스트해야되는지 이건 아닌지, 이걸 테스트하기엔 너무 어려운데 과연 의미가 있는지이건 불가능한 테스트인데 어떻게 해야 하는지에 대한 고민이 많았다.그래서 Udemy에서 Master Java Unit Testing with Spring Boot &amp; Mockito 강의라도 들을까 하고 있던 차에, 한국에서! 그것도 실무자가 하고있는 스프링부트 테스트코드 강의라서 많은 기대가 됐다.그리고 이 세션은 그러한 내 많은 고민을 한번에 해결해 주었다! 그리고 나는 테스트코드를 맞게 짜고 있었다. 안도감이 들었다.강연 중간에 spock에 대한 언급이 있었는데, 생각보다 많은 분들이 사용하고 있어서 왠지 든든했다(?)spock는 정말 좋다. 처음엔 groovy가 낯설었지만 조금 적응이 되니 너무 편리했다. 테스트로부터 얻을 수 있는 것 안정감과 자신감 (정말 그렇다!) 대상은 나와 동료 무엇을 테스트 할 것인가 기존 플로우 안까지 할 필요없음 만약 걔를 테스트해야되면 걔를 빼는게 맞는거임 설계사항 그대로 테스트 코드로 옮기는게 좋음 테스트 가능한 것 불가능한 것 외부 API 테스트안됨(그렇다) 항상 성공할 수 있는것 동일한 결과가 나올 수 있는것을 테스트 어떻게 테스트 할 것 인가 바운더리 레이어까지 테스트안되는걸 끌어올려서 테스트 바운더리 레이어 = &gt; 한 모듈로서의 의미를 지니는 가장 바깥쪽 springcontext의 오용은 언어의 본질을 망각하게 될 수 있다. Context, framework 종속적이지 않은 테스트를 우선 Test double 테스트 할 수 없는 영역을 주입해서 테스트할 수 있게 해줌 무엇을 test double로 처리해야할까 H2 뭐 그런거 써서 enbedded 활용 =&gt; 제어할 수 없던 그 영역을 제어할 수 있다! Endpoint Test Spring contract test tip 테스트는 상호 독립적으로 작성 공유되는 데이터는 꼭 초기화를 한다(테스트간 서로 영향을 끼치지않도록) =&gt; Dynamic Test (Junit5) 테스트 에서 의도와 목적이 드러나도록 테스트 코드도 리펙토링 대상 앞으로 테스트코드를 더 즐겁고 확신있게(?) 짤 수 있을 것 같다. 이후에 들은 세션은 당신도 할 수 있는 레거시 프로젝트 개선 이야기, Kotlin 프로젝트 적응하기 이다.Kotlin + Spring Data JPA 세션을 듣고싶었는데, 중간에 일이 생겨 아쉽게 마지막 세션을 들을 수 없었다.이전에 kotlin 프로젝트에 자바 라이브러리를 사용하려다 대차게 실패한 적이 있기 때문에 꼭 듣고 싶었다.해당글 : Kotlin 에서 Lombok을 사용할 수 없는 문제강연 영상이나 ppt가 공개되면 봐야겠다."},{"title":"Kakao Geocode API, 주소로 위도 경도 java로 파싱하기","date":"2019-04-16T15:00:00.000Z","updated":"2019-08-02T14:41:53.822Z","comments":true,"path":"java/2019/04/17/kakao-api-geocode-parsing.html/index.html","permalink":"https://sehajyang.github.io/java/2019/04/17/kakao-api-geocode-parsing.html/index.html","excerpt":"","text":"Kakao Geocode API로 부터 받은 데이터를 직렬화 하고 JSON객체로 바꾸고 특정 데이터를 얻어오는 작업을 할 것입니다.Kakao API를 이용하기 위해선 API Key가 필요한데, 이곳 에서 얻을 수 있습니다. 카카오 지도 API로부터 주소로 위도 경도를 받아오기 위해선 이곳에 공식 예제가 있습니다. 받아온 주소 데이터를 JSON으로헤더에 발급받은 API키를 등록 후 POSTMAN으로 요청을 날려보겠습니다. https://dapi.kakao.com/v2/local/search/address.json?query=판교역로 235 응답받은 데이터는 이러합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#123; \"meta\": &#123; \"is_end\": true, \"total_count\": 1, \"pageable_count\": 1 &#125;, \"documents\": [ &#123; \"road_address\": &#123; \"undergroun_yn\": \"N\", \"road_name\": \"판교역로\", \"underground_yn\": \"N\", \"region_2depth_name\": \"성남시 분당구\", \"zone_no\": \"13494\", \"sub_building_no\": \"\", \"region_3depth_name\": \"삼평동\", \"main_building_no\": \"235\", \"address_name\": \"경기 성남시 분당구 판교역로 235\", \"y\": \"37.40209529907863\", \"x\": \"127.10863694633468\", \"region_1depth_name\": \"경기\", \"building_name\": \"에이치스퀘어 엔동\" &#125;, \"address_name\": \"경기 성남시 분당구 판교역로 235\", \"address\": &#123; \"b_code\": \"4113510900\", \"region_3depth_h_name\": \"삼평동\", \"main_address_no\": \"681\", \"h_code\": \"4113565500\", \"region_2depth_name\": \"성남시 분당구\", \"main_adderss_no\": \"681\", \"sub_address_no\": \"\", \"region_3depth_name\": \"삼평동\", \"address_name\": \"경기 성남시 분당구 삼평동 681\", \"y\": \"37.40206645815382\", \"x\": \"127.10864594007738\", \"mountain_yn\": \"N\", \"zip_code\": \"463400\", \"region_1depth_name\": \"경기\", \"sub_adderss_no\": \"\" &#125;, \"y\": \"37.40209529907863\", \"x\": \"127.10863694633468\", \"address_type\": \"ROAD_ADDR\" &#125; ]&#125; 위의 데이터에서 Y 좌표 값과 X 좌표값이 필요하기 때문에 해당 데이터만 가져오도록 하겠습니다. 우선 KAKAO 지도 API로 요청을 보내고 응답을 받습니다. 1234567891011String APIKey = \"발급받은 API 키\"; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); //결과를 담을 maptry &#123; String apiURL = \"https://dapi.kakao.com/v2/local/search/address.json?query=\" + URLEncoder.encode(address, \"UTF-8\"); HttpResponse&lt;JsonNode&gt; response = Unirest.get(apiURL) .header(\"Authorization\", APIKey) .asJson(); 받아온 데이터를 JSON 객체로 변환하기 위해 ObjectMapper를 사용합니다. 12ObjectMapper objectMapper = new ObjectMapper();objectMapper.configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true); 위의 objectMapper.configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true); 는단일 리스트 객체를 싱글 값과 같게 인식합니다.ex) &quot;fruits&quot; : [&quot;apple&quot;] 를 &quot;fruits&quot; : &quot;apple&quot; 로 인식 지정된 VO에 응답받은 데이터를 셋팅지정된 형식에 잘 셋팅하기 위해 1KakaoGeoRes bodyJson = objectMapper.readValue(response.getBody().toString(), KakaoGeoRes.class); KakaoGeoRes에 응답받은 데이터를 잘 셋팅하도록 합니다. 123456789101112131415@Datapublic class KakaoGeoRes &#123; private HashMap&lt;String, Object&gt; meta; private List&lt;Documents&gt; documents;&#125;@Dataclass Documents &#123; private HashMap&lt;String, Object&gt; address; private String address_type; private Double x; private Double y; private String address_name; private HashMap&lt;String, Object&gt; road_address;&#125; X, Y값만 필요했기 때문에 위와 같이 작성했습니다.key가 응답받은 데이터와 다르면 에러가 나기 때문에 사용하지 않는 key 도 선언합니다. X,Y 값에 접근그 후 12bodyJson.getDocuments().get(0).getX()bodyJson.getDocuments().get(0).getY() 위와같이 접근할 수 있습니다. 읽어주셔서 감사합니다.혹 오류나 질문이 있다면 편하게 코멘트 부탁드리겠습니다!🙆‍♂️"}],"posts":[{"title":"스칼라 번역 - 객체지향 (Object Oriented Programming)","slug":"oop","date":"2019-08-06T14:46:00.000Z","updated":"2019-08-06T14:46:38.793Z","comments":true,"path":"2019/08/06/oop/","link":"","permalink":"https://sehajyang.github.io/2019/08/06/oop/","excerpt":"","text":"이 포스팅은 [scala-exercises 번역 시리즈]로 scala-exercises 사이트의 스칼라 튜토리얼을 공부하며 번역한 문서 입니다.scala-exercises 는 스칼라 창시자인 마틴 오더스키가 만든 강의의 강의자료입니다.따라서 강의를 들으며 본 문서를 같이 보는것을 추천합니다.직역보단 의역을 했기 때문에 의역이 많습니다. 오역 및 오타 등은 코멘트로 알려주세요 😄원문 : [scala-exercises object_oriented_programming] 객체지향 프로그래밍함수와 데이터어떻게 함수가 생성되고 데이터 구조를 캡슐화 하는지 살펴보겠습니다.우린 산술연산을 위한 패키지를 만들려 합니다.분수 x/y는 두가지 정수로 표현됩니다: 분자 x 그리고 분모 y 유리수 덧셈두 분수의 덧셈을 하고 싶다고 가정해봅시다. 12def addRationalNumerator(n1: Int, d1: Int, n2: Int, d2: Int): Intdef addRationalDenominator(n1: Int, d1: Int, n2: Int, d2: Int): Int 이 많은 분자와 분모를 관리하기는 어렵습니다!.이렇게 하기보단, 데이터구조 안에서 분자와 분모를 결합하는 것이 더 낫습니다. 클래스스칼라에서, 클래스를 이렇게 정의할 수 있습니다: 1234class Rational(x: Int, y: Int) &#123; def numer = x def denom = y&#125; 이 정의는 두가지 엔티티를 나타냅니다: Rational 이라는 새로운 타입 이러한 타입으로 요소를 생성하기 위한 Rational 생성자스칼라는 서로 다른 네임스페이스에 타입과 생성된 값을 보관합니다. 따라서 Rational에 대한 두 정의끼리 충돌하지 않습니다. 객체클래스 타입의 요소(element)는 객체라고 불리며 클래스 생성자의 어플리케이션 앞에 new 연산자를 붙여 객체를 생성합니다. 1new Rational(1, 2) 객체의 멤버Rational 클래스 의 객체는 numer 과 denom 라는 두 멤버를 갖고 있습니다.자바처럼 . 연산자를 객체에 붙여 멤버를 호출할 수 있습니다. 123val x = new Rational(1, 2) // x: Rational = Rational@2abe0e27x.numer // 1x.denom // 2 분수 연산이제 스탠다드 룰에 따른 분수를 연산하는 함수를 정의할 수 있습니다. 12345n1 / d1 + n2 / d2 = (n1 * d2 + n2 * d1) / (d1 * d2)n1 / d1 - n2 / d2 = (n1 * d2 - n2 * d1) / (d1 * d2)n1 / d1 * n2 / d2 = (n1 * n2) / (d1 * d2)n1 / d1 / n2 / d2 = (n1 * d2) / (d1 * n2)n1 / d1 = n2 / d2 iff n1 * d2 = d1 * n2 분수 연산 구현12345678def addRational(r: Rational, s: Rational): Rational = new Rational( r.numer * s.denom + s.numer * r.denom, r.denom * s.denom )def makeString(r: Rational) = r.numer + \"/\" + r.denom 그런다음 : 1makeString(addRational(new Rational(1, 2), new Rational(2, 3))) 메소드더 나아가 데이터 추상화 자체에서 데이터 추상화에 따라 작동하는 기능도 패키징할 수 있습니다.이러한 함수를 메소드 라고 합니다.Rational 클래스는 numer 과 denom 함수 뿐 만 아니라 add, sub, mul, div, equal, toString 함수도 있습니다.구현은 다음과 같습니다: 123456789class Rational(x: Int, y: Int) &#123; def numer = x def denom = y def add(r: Rational) = new Rational(numer * r.denom + r.numer * denom, denom * r.denom) def mul(r: Rational) = ... ... override def toString = numer + \"/\" + denom&#125; 수정자 override 선언은 java.lang.Object 클래스에 있던 toString 메소드를 재정의 합니다.다음은 new Rational 을 사용하는 방법 입니다: 1234val x = new Rational(1, 3)val y = new Rational(5, 7)val z = new Rational(3, 2)x.add(y).mul(z) 데이터 추상화위의 분수 예제는 항상 가장 단순한 형태로 표현된 것이 아닙니다.역자 추가) 42/77 은 6/11로 약분될 수 있지만, 위의 분수 예제는 42/77 을 나타내므로 가장 단순한 형태(약분이 다 된 상태) 가 아니란 뜻따라서 분수가 약분될 수 있음을 예상할 수 있습니다: 최대공약수로 나눠서 가장 작은 분자와 분모로 줄입니다 우린 분수 연산을 할 때 마다 약분을 할 수 있지만 약분해야 한다는 걸 금방 까먹을 것 입니다.그러니 다음과 같이 객체가 생성될 때 클래스의 약분함수를 거쳐 객체가 생성되는게 더 낫습니다. 1234567class Rational(x: Int, y: Int) &#123; private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b) private val g = gcd(x, y) def numer = x / g def denom = y / g ...&#125; gcd와 d는 private 멤버이므로, Rational 클래스 안에서만 접근할 수 있습니다.이 예제에서, gcd 함수를 즉시 계산하며, 그 값을 numer과 denom의 계산에서 재사용할 수 있습니다.또한 numer과 denom 코드안에서 gcd 호출이 가능합니다(Rational 클래스 안이기 때문에): 12345class Rational(x: Int, y: Int) &#123; private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b) def numer = x / gcd(x, y) def denom = y / gcd(x, y)&#125; 위 코드는 numer과 denom 함수가 가끔 호출되는 경우에 유리합니다.numer과 denom의 def를 val로 변환하는 것 과도 같습니다. 그리고 val 는 단 한번만 계산됩니다: 12345class Rational(x: Int, y: Int) &#123; private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b) val numer = x / gcd(x, y) val denom = y / gcd(x, y)&#125; 이는 numer과 denom이 종종 호출될 때 유리합니다. 클라이언트 뷰클라이언트는 각각의 케이스에서 정확히 같은 경향을 보입니다.클라이언트에 영향을 주지 않고 데이터의 다른 구현을 선택할 수 있는 이러한 기능을 데이터 추상화라고 합니다.이것은 소프트 엔지니어링의 초석입니다. 자기 참조클래스 내부의 this는 현재 메소드가 실행되는 객체를 나타냅니다.Rational 클래스에 less 와 max 함수를 추가해봅시다: 12345678class Rational(x: Int, y: Int) &#123; ... def less(that: Rational) = numer * that.denom &lt; that.numer * denom def max(that: Rational) = if (this.less(that)) that else this&#125; 클래스의 다른 멤버를 참조하는 x는, this.x이 생략된 표현됩니다. this를 생략하지 않은 less 구현은 다음과 같습니다: 12def less(that: Rational) = this.numer * that.denom &lt; that.numer * this.denom 전제 조건(Preconditions)Rational 클래스의 분모는 양의 정수여야 한다고 가정해봅시다.require 라는 함수로 이를 구현할 수 있습니다. 1234class Rational(x: Int, y: Int) &#123; require(y &gt; 0, \"denominator must be positive\") ...&#125; require는 미리 정의된 함수입니다. 이 함수는 조건과 메세지 문자열(옵션)이 필요합니다.만약 require의 조건 결과가 false 라면 메세지 문자열과 함께 IllegalArgumentException 오류를 던집니다. ASSERTIONSrequire 말고, assert도 있습니다.assert또한 조건과 메세지 문자열(옵션)이 필요합니다. 12val x = sqrt(y)assert(x &gt;= 0) require 처럼 assert의 조건이 실패시 예외를 던집니다, 그러나 assert의 AssertionError과 require의 IllegalArgumentException는 한가지 차이가 있습니다.이것은 의도의 차이를 나타냅니다. require는 함수 호출시 사전 조건을 적용하는데에 사용됩니다. assert는 함수의 자체의 코드를 검사하기 위해 사용됩니다. 생성자스칼라에서, 클래스는 암시적으로 생성자를 선언합니다. 이것을 주 생성자(primary constructor)라고 합니다.주 생성자는 : 클래스의 파라미터를 가져옵니다. 그리고, 클래스 바디안의 모든 명령문을 실행합니다(require 같은 것들) 보조 생성자또한 스칼라는 보조생성자의 선언을 허용하며 이름은 this라고 합니다.Rational 클래스에 보조 생성자를 추가해봅시다: 1234class Rational(x: Int, y: Int) &#123; def this(x: Int) = this(x, 1) ...&#125; 클래스와 치환(Subtitution)이전엔 치환에 기반한 계산 모델을 사용해 함수 어플리케이션의 의미를 정의했습니다. 이제 이 모델을 클래스와 객체로 확장합니다.new C(e1, …, en)(C: 클래스, e: 인스턴스)는 어떻게 값이 구해질까요?표현식 인수(argument) e1, …, en는 일반 함수의 인수와 같이 간주됩니다.결과 표현식 new C(v1, …, vn)은 이미 값입니다.이제 클래스 정의가 있다고 가정해봅시다: 12345class C(x1, …, xn) &#123; … def f(y1, …, ym) = b …&#125; x1, …, xn는 클래스의 형식적인 파라미터입니다. 이 클래스는 y1, …, ym파라미터가 있는 f 메소드를 정의합니다 (함수 파라미터 리스트가 없을 수 있습니다. 심플함을 위해, 파라미터 타입을 생략했습니다)다음의 표현식은 어떻게 될까요? 1new C(v1, …, vn).f(w1, …, wm) 다음과 같은 세가지의 치환이 발생합니다. 인수 w1, ..., wm에 대한 함수 f의 매개변수 y1, ..., ym 치환. 클래스 인수 v1, ..., vn에 의한 클래스 C의 매개변수 x1, ..., xn 치환 자체 참조 this를 new C(v1, ..., vn) 객체의 값으로 치환. 연산자원칙적으로, Rational이 정의한 분수는 정수와 같습니다(분수는 정수라는 뜻).하지만 눈에 띄는 차이점이 있습니다: x 과 y가 정수인 x+y를 작성했지만, r.add(s)의 경우 r과 s 는 분수입니다. 역자추가) x와 y는 정수라서 +가 되는데 r과 s는 분수라 +가 없어서 add 메소드를 씀. 근데 원칙적으로 분수는 정수인데 뭐지? 라는 차이점이 있다는 뜻 스칼라에선, 연산자를 식별자로 사용할 수 있으므로 이 차이를 없앨 수 있습니다.식별자는 다음과 같습니다: Alphanumeric : 문자로 시작하고 문자 또는 숫자 시퀀스 심볼릭 : 연산자 기호로 시작하고, 그 뒤에 다른 연산자 기호가 옵니다. 밑줄 문자 _는 문자로 계산됩니다. Alphanumeric 식별자는 밑줄로 끝나며 일부 연산자 기호가 이어질 수 있습니다.식별자 예제:1x1 * +?%&amp; vector_++ counter_= 분수를 위한 연산자여기 Rational 클래스에 대한 보다 자연스러운 정의가 있습니다: 1234567891011121314class Rational(x: Int, y: Int) &#123; private def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b) private val g = gcd(x, y) def numer = x / g def denom = y / g def + (r: Rational) = new Rational( numer * r.denom + r.numer * denom, denom * r.denom ) def - (r: Rational) = ... def * (r: Rational) = ... ...&#125; 이제 분수는 Int 나 Double 처럼 사용될 수 있습니다. 123val x = new Rational(1, 2)val y = new Rational(1, 3)x * x + y * y 우선순위 규칙연산자 우선순위는 첫 문자에 의해 결정됩니다.다음은 우선순위가 높은 순서대로 문자를 나열한 것 입니다: 12345678910(all letters)|^&amp;&lt; &gt;= !:+ -* / %(all other special characters) 추상 클래스IntSet 클래스의 작성에 대해 생각해봅시다. 1234abstract class IntSet &#123; def incl(x: Int): IntSet def contains(x: Int): Boolean&#125; IntSet은 추상 클래스입니다.추상 클래스는 구현이 되지 않은 멤버를 포함할 수 있습니다(이 경우엔, incl과 contains 이며 추상메소드 라고 합니다).그렇기 때문에, 추상클래스는 new 연산자로 새로운 객체를 생성할 수 없습니다. 클래스 확장set 을 이진트리로 구현하는 것에 대해서 생각해봅시다.가능한 트리에는 두가지 타입이 있습니다. 빈 세트에 대한 트리 정수와 두개의 하위트리로 구성된 트리 구현은 다음과 같습니다: 1234567891011121314151617class Empty extends IntSet &#123; def contains(x: Int): Boolean = false def incl(x: Int): IntSet = new NonEmpty(x, new Empty, new Empty)&#125;class NonEmpty(elem: Int, left: IntSet, right: IntSet) extends IntSet &#123; def contains(x: Int): Boolean = if (x &lt; elem) left contains x else if (x &gt; elem) right contains x else true def incl(x: Int): IntSet = if (x &lt; elem) new NonEmpty(elem, left incl x, right) else if (x &gt; elem) new NonEmpty(elem, left, right incl x) else this&#125; Empty와 NonEmpty는 IntSet 클래스를 상속 받았습니다.이 상속은 Empty와 NonEmpty의 타입이 IntSet의 타입을 따르게 합니다.Empty 혹은 NonEmpty는 IntSet 타입의 객체가 필요한 곳이라면 어디서나 사용할 수 있습니다. IntSet은 Empty와 NonEmpty의 ‘슈퍼클래스’ 라고 불립니다.Empty 및 NonEmpty는 IntSet의 하위 클래스입니다.스칼라에서는 사용자 정의 클래스가 다른 클래스를 상속받습니다.슈퍼 클래스가 주어지지 않는 경우, Java 패키지 java.lang의 표준 클래스 객체로 가정합니다.C 클래스의 직접 또는 간접 슈퍼클래스를 C 의 기본 클래스라고 합니다.그래서, NonEmpty의 기본 클래스는 IntSet과 Object 입니다. 상속(implementation)과 오버라이딩Empty 와 NonEmpty 클래스의 contains 과 incl의 정의는 IntSet 의 추상 함수를 구현합니다.또한 오버라이드를 사용하여 하위 클래스에서 기존 비추상 정의를 재정의할 수 있습니다. 123456789abstract class Base &#123; def foo = 1 def bar: Int&#125;class Sub extends Base &#123; override def foo = 2 def bar = 3&#125; 객체 정의IntSet 예제에서, 실제론 하나의 빈 IntSet만 존재한다고 할 수도 있습니다.그렇기 때문에 사용자가 많은 인스턴스를 만들도록 하는 것은 지나친 것 같습니다.우린 객체 정의로 이 경우를 개선할 수 있습니다: 1234object Empty extends IntSet &#123; def contains(x: Int): Boolean = false def incl(x: Int): IntSet = new NonEmpty(x, Empty, Empty)&#125; 위 코드는 Empty라는 싱클톤 객체를 정의합니다.다른 어떤 Empty 객체도 생성될 수 없습니다.싱글톤 객체는 값이기 때문에 Empty는 스스로 계산됩니다. 동적 바인딩스칼라를 포함한 OOP 언어에선 동적 메소드 디스패치를 구현합니다.이것은 메소드 호출에 의해 호출된 코드는 메소드를 포함하는 객체의 런타임 유형에 따라 다르다는 것을 의미합니다.추가 12Empty contains 1 shouldBe falsenew NonEmpty(7, Empty, Empty) contains 7 shouldBe true 메소드의 동적 디스패치는 고차함수의 호출과 비슷합니다.이 개념을 다른 개념으로 구현할 수 있습니까? 고차함수의 측면에서 객체? 객체 측면에서 고차함수? 트레잇스칼라에서, 클래스는 단 하나의 슈퍼클래스를 가질 수 있습니다.그러나 한 클래스가 몇 가지 슈퍼타입을 가지고 있거나 그로부터 코드를 상속받고자 하면 어떨까요?이때, 당신은 트레잇(trait)를 사용할 수 있습니다.트레잇은 추상클래스처럼 선언되며, trait 으로 선언합니다. 12345trait Planar &#123; def height: Int def width: Int def surface = height * width&#125; 클래스, 객체, 트레잇은 최대 하나의 클래스에서 상속 할 수 있지만 임의의 많은 트레잇이 있습니다: 1class Square extends Shape with Planar with Movable … 반면에, 트레잇은 값 파라미터를 가지지 않으며 클래스만 가질 수 있습니다. 스칼라의 클래스 계층 Top Type타입 계층 구조의 맨 위에는 다음이 있습니다. Any 모든 타입의 기본 타입 메소드: ==, !=, equals, hashCode, toString AnyRef 모든 참조 타입의 기본 타입 별칭 java.lang.Object AnyVal 모든 원시 타입의 기본 타입 Bottom TypeNothing은 스칼라의 타입 계층의 최하위에 있습니다. 그것은 다른 모든 타입의 하위 유형입니다.Nothing타입의 값은 없습니다.이걸 어디에 사용하나요? 비정상 종료 신호 빈 콜렉션 의 요소(element) 타입 Null Type모든 참조 클래스 타입은 또한 null을 값으로 갖고 있습니다.null 타입은 Null 입니다.Null은 Object에서 상속하는 모든 클래스의 하위 타입이며, AnyVal의 하위 타입과 호환되지 않습니다. 123val x = null // x: Nullval y: String = null // y: Stringval z: Int = null // error: type mismatch 읽어주셔서 감사합니다. 혹 글에 오역/추가할 내용이 있다면 코멘트 남겨주세요!🙆","categories":[{"name":"Scala","slug":"Scala","permalink":"https://sehajyang.github.io/categories/Scala/"}],"tags":[{"name":"scala-exercises","slug":"scala-exercises","permalink":"https://sehajyang.github.io/tags/scala-exercises/"},{"name":"Scala","slug":"Scala","permalink":"https://sehajyang.github.io/tags/Scala/"}]},{"title":"190722-190804 2주간 회고","slug":"190722-190804","date":"2019-08-05T07:09:32.000Z","updated":"2019-08-06T14:31:35.583Z","comments":true,"path":"2019/08/05/190722-190804/","link":"","permalink":"https://sehajyang.github.io/2019/08/05/190722-190804/","excerpt":"","text":"2주간 스칼라 공부를 하고, 개인 프로젝트를 했다.처음엔 날씨 정보를 알려주는 슬랙봇을 만들었으나, 개발팀의 반응이 좋아서 기능을 확장시켜 결국 너굴맨 프로젝트를 만들게 되었다! 너굴쟝.JPG 너굴맨은 가끔 까칠하다. 너굴맨 프로젝트의 아이디어는 9XD에 있는 item4 님의 yui에서 얻었다.Slacker를 이용해서 만들었는데, 부족한 기능이 많아서 라이브러리를 고치다 문득 이럴바엔 차라리 async로 만드는게 낫겠다는 생각이 들었다.yui가 비동기로 짜여져 있던데, 나도 시간이 나면 처음부터 저렇게 싹 만들고 싶다. 2주간 했던 학습 및 개발 Functional Programming in Scala 코세라 강의 Code Wars 스칼라 풀이 Scala Exercises 번역 Scala 학습마틴 오더스키 스칼라 코세라 강의를 듣던 중 깨달은건데, 강의 예제가 내가 번역하던 Scala Exercises 번역이라는 걸 깨달았다!.게다가, 스칼라 강의엔 한글 자막이 붙어있다. 이럴수가.. 내가 바퀴를 재발명 하고있었던걸까?다행히도 스칼라 강의에 붙어있는 한글 자막은 구글 번역기로 돌린듯한 퀄리티를 보여줬기 때문에 내 번역자료는 향상된 바퀴가 되었다.Programming in Scala 도 계속해서 보고있다. 개인적으론, 강의보단 책의 내용이 좀 더 자세하며 좋은 것 같다.(그리고 많다) 스칼라는 어렵기 때문에 생산성에 대한 의문이 있다. 주위에선 왜 스칼라를 하냐 코틀린을 하지 라는 반응을 보이기도 했다.그렇지만 멀티 프로세싱이 중요해진 요즘 시대에 (꽤)순수한 함수형 언어는 꼭 배워야 하며, 그렇게 새로운 패러다임을 배움으로써 시야를 확장해 나가는 것이 중요하다고 생각하기 때문에 어렵지만 여차저차 공부하고있다.누군가, 그럴거면 하스켈을 하지 라는 말을 할지도 모르겠다. 하지만 하스켈을 실무에서 쓰기엔 그닥 이라고 생각한다. 다음 주부터는 지인과 매주 주말마다 스칼라 스터디를 하기로 했다. 책은 당연히 Programming in Scala 이다.라스칼라 코딩단에서 팀원을 모아볼까 했지만 왠지 참가하는 사람이 적을 것 같은 느낌적인 느낌(왠지 고수분들만 있는것같은)이 들어서 지인과 하기로 결정됐다.지금껏 많은 스터디를 참여하기도, 열기도 했지만 꾸준히 파토나지 않고 유지해나가는게 정말 어려운 것 같다.발표하는 방식의 스터디가 가장 좋았던 것 같아, 한 주 동안 1~2강을 학습하고 주말에 해당 내용을 발표 및 토의, 질문, 문제풀이의 시간을 가질 예정이다! Code Wars는 부끄럽게도 너굴맨 프로젝트를 하느라 몇 문제 못 풀었다.Scala Exercises 번역은 회사일이 바빠 속도가 느려졌지만 계속해서 하고있긴하다. 다음주 목표 Functional Programming in Scala 코세라 강의 3Week 까지 Code Wars 스칼라 풀이 Scala Exercises 번역 너굴맨 슬랙봇 개발 총평2주간 스칼라 강의를 듣고 책을 봤다. 너굴맨 프로젝트를 하느라(이게 생각보다 재밌었다) 스칼라 코드를 짜는 횟수는 좀 적었다..책은 반정도 봤다. 다음주에는 좀 더 코드를 짜는것에 집중해야겠다. 다음 주부터 시작하는 지인과 함께하는 스칼라 스터디는 정말 기대된다!","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"190708-190721 2주간 회고","slug":"190708-190721","date":"2019-07-23T00:55:56.000Z","updated":"2019-08-02T14:41:53.794Z","comments":true,"path":"2019/07/23/190708-190721/","link":"","permalink":"https://sehajyang.github.io/2019/07/23/190708-190721/","excerpt":"","text":"2주간 스칼라공부를 많이 했다. 스칼라는 무슨말을 하는지 뭔가 머리론 알겠는데 막상 사용하려면 손이 안떨어지는 느낌이다.아직도 객체가 불변하다는것과 파라미터로 함수를 넘긴다는게 내겐 너무 낯설다.사람의 머리는 재귀에 가깝다고 한다 하지만 나는 너무 for loop에 익숙해져 있어서 그런지 재귀적인 사고가 잘 되지 않는 것 같다.그래도 최대한 var 나 for loop를 사용하지 않으려 노력하고 있다💦스칼라 문법에 빨리 익숙해지기 위해 스칼라로 프로젝트 오일러를 몇 문제 풀어보기도 하고, Scala Exercises 를 풀거나 번역을 했는데,가장 좋은 방법은 단언 Code Wars 문제를 푸는 것 이었다. 2주간 했던 학습 및 개발 Functional Programming in Scala 코세라 강의 Code Wars 스칼라 풀이 프로젝트 오일러 스칼라 풀이 Scala Exercises 번역 Functional Programming in Scala 코세라 강의스칼라 언어를 만든 마틴 오더스키 교수님이 만든 강좌로 수강을 시작했다.지인과 같이 이 강의로 스칼라 스터디를 하고있는데 내용이 차근차근 하며 어렵지 않아서 잘 듣고 있다.OOP언어만 알던 나에게 스칼라는 너무 신선해서 강의는 그야말로 놀라움의 연속이다. 덕분에 강의를 듣는 내내 지루할 틈이 없다ㅎㅎ Code Wars 스칼라 풀이처음엔 백준문제를 풀려고 했지만 어떠한 이유에서인지 백준은 스칼라를 지원하지 않았다. 그래서 대안으로 Code Wars를 선택했다.Code Wars는 지원하는 언어도 다양하고 난이도가 나뉘어있어 수준에 맞는(?) 문제를 풀 수 있다.또한 테스트 케이스를 작성해주며 문제 제출 시 오류가 난 테스트를 상세히 알려준다.제출한 코드가 통과되면 타인이 작성한 코드 및 가장 많은 추천을 받은 릿코드를 볼 수 있다.언어별로 있는 난이도는 기초, 랭크 업, 반복 연습, 랜덤 등인데 기초 난이도는 스칼라 문법 연습으로 괜찮았다!.스칼라 문법 연습은 앞으로 계속 Code Wars로 해야겠다. 프로젝트 오일러 스칼라 풀이자바로 공개되어있는 프로젝트 오일러 문제를 스칼라로 포팅하는 식으로 몇 문제 진행했었는데, 스칼라 연습이 안되는 것 같아 금방 접었다.그리고 공개된 소스를 스칼라로 포팅하는건 왠지 지루했다. Scala Exercises 번역Scala Exercises 번역을 벌써 다섯개나 했다! 앞으로 4개정도 남은 것 같다.번역을 하면서 Scala Exercises 설명은 굉장히 대충이라는 느낌을 받았다. 대략 내가 대충 말하면 너가 잘 알아들어~ 라는 느낌이었다.FP를 좀 아는 사람이 보기 좋은 사이트이며 스칼라 입문용으로 보기엔 별로인 것 같다. 그야말로 Exercises란 이름에 낚였다.덕분에 추가설명을 다느라 애먹고 있다. 물론 번역엔 추가설명을 붙였기 때문에 이젠 초보자도 나름 볼 수 있는 자료가 되었다 😁 😁번역하며 가장 어려웠던 점은 전문 용어를 한글로 번역하는게 너무 어렵다는 것 이다.예를들어 Option value 를 보자면, 이걸 옵션 값 으로 해야할지 선택적 값 으로 해야할지 옵션벨류로 해야 할지를 선택해야 한다.조금 과장하자면 이런 문제가 거의 매 줄 매 단략마다 일어났다.앞으로 4개정도 남았다. 슬프게도 봐주는 사람이 지금은 없지만.. 언젠가 스칼라 뉴비에게 도움이 되는 자료가 된다면 좋겠다.. 다음주 목표 Functional Programming in Scala 코세라 강의 Code Wars 스칼라 풀이 Scala Exercises 번역 총평내가 목표한 학습량엔 못미쳐 좀 아쉬웠다.특히, 인터넷에서 얻는 정보로는 어느정도 한계가 있어 책을 봤어야 했는데 책을 조금밖에 못봐서 아쉬웠다.다음 2주간도 지난주와 마찬가지로 스칼라 공부를 할 예정이다. 책, 강의, CodeWars 풀이에 중점을 두고 시간날때 간간히 번역을 해야겠다.언젠가 스칼라에 좀 익숙해지고 좀 알 것 같아지면 매주마다 하는 라스칼라 스터디에도 참여해보고싶다.","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"스칼라 번역- 편리한 문법들 (Syntactic Conveniences)","slug":"syntactic-conveniences","date":"2019-07-18T12:47:06.000Z","updated":"2019-08-06T14:31:35.588Z","comments":true,"path":"2019/07/18/syntactic-conveniences/","link":"","permalink":"https://sehajyang.github.io/2019/07/18/syntactic-conveniences/","excerpt":"","text":"이 포스팅은 [scala-exercises 번역 시리즈]로 scala-exercises 사이트의 스칼라 튜토리얼을 공부하며 번역한 문서 입니다.scala-exercises 는 스칼라 창시자인 마틴 오더스키가 만든 강의의 강의자료입니다.따라서 강의를 들으며 본 문서를 같이 보는것을 추천합니다.직역보단 의역을 했기 때문에 의역이 많습니다. 오역 및 오타 등은 코멘트로 알려주세요 😄원문 : [scala-exercises syntactic_conveniences] 편리한 문법들(SYNTACTIC CONVENIENCES)이 섹션에선 언어가 지원하는 몇가지 문법적 설탕에 대해 소개합니다. 문자열 인터폴레이션(INTERPOLATION)런타임에서 String 에 값을 붙일 시 문자열 인터폴레이션을 사용할 수 있습니다: 12345def greet(name: String): String = s\"Hello, $name!\"greet(\"Scala\") shouldBe \"Hello, Scala!\"greet(\"Functional Programming\") shouldBe \"Hello, Functional Programming!\" 문자열 리터럴 접미사로 s를 붙이면 $으로 동적값을 그 안에서 사용할 수 있습니다.만약 복잡한 식을 연결할시엔 중괄호로 둘러쌉니다. 1234def greet(name: String): String = s\"Hello, $&#123;name.toUpperCase&#125;!\"greet(\"Scala\") shouldBe \"Hello, SCALA!\" 튜플우리는 이전 섹션들을 통해 케이스 클래스는 정보를 모으는데에 유용하다는 것을 알게되었습니다.그러나 때로는 완전한 케이스 클래스를 정의할 필요 없이 정보를 모을 수 있습니다. 튜플로 말이죠 1234def pair(i: Int, s: String): (Int, String) = (i, s)pair(42, \"foo\") shouldBe (42, \"foo\")pair(0, \"bar\") shouldBe (0, \"bar\") 위 예제에서의 타입은 (Int, String)로 첫번째 요소(element)의 타입은 Int 두번째 요소는 String 입니다.비슷하게, (i, s) 쌍의 첫번째 요소는 i, 두번째 요소는 s 입니다.일반적으로, (T1, …, Tn)의 타입은 i번째 요소는 Ti 타입을 가진, n개의 요소가 있는 튜플입니다.그리고 값은 n개 요소 (t1, …, tn)의 튜플 값 입니다. (역자추가) 튜플의 각 요소들은 타입이 각자 다를 수 있습니다. (&quot;a&quot;,1,&#39;b&#39;) 튜플의 타입은 Tuple[String,Int,Char] 입니다.즉, 튜플의 타입은 요소의 개수와 각각의 타입에 따라 달라집니다. [출처] 튜플 조작하기튜플 패턴을 사용해 튜플의 요소를 검색할 수 있습니다. 1234567val is: (Int, String) = (42, \"foo\")is match &#123; case (i, s) =&gt; i shouldBe 42 s shouldBe \"foo\"&#125; 또는 심플하게 다음과 같이 작성할 수 있습니다: 12345val is: (Int, String) = (42, \"foo\")val (i, s) = isi shouldBe 42s shouldBe \"foo\" 또는 _1멤버로 첫번째 요소를, _2멤버로 두번째 요소를 검색할 수 있습니다: 123val is: (Int, String) = (42, \"foo\")is._1 shouldBe 42is._2 shouldBe \"foo\" 객체로서의 함수우리는 스칼라의 넘버릭 타입들과 Boolean 타입이 일반 클래스처럼 상속될 수 있음을 보았습니다.그러나 함수는 어떨까요?실제로 스칼라에서 함수의 값은 객체로 다뤄집니다.타입이 A = B 인 함수는 사실 scala.Function1[A, B] 가 생략된 것 이며 다음과 같이 정의됩니다: 1234package scalatrait Function1[A, B] &#123; def apply(x: A): B&#125; 그래서, 함수는 apply 메소드를 가지고있는 객체입니다.또한 Function2, Function3… , 등 더 많은 매개변수를 취하는 함수(튜플..최대 22개)가 있습니다. 함수값의 확장아래의 익명함수는: 1(x: Int) =&gt; x * x 다음과 같이 확장됩니다. 123456&#123; class AnonFun extends Function1[Int, Int] &#123; def apply(x: Int) = x * x &#125; new AnonFun&#125; 또는 익명 클래스 문법을 사용해 짧아집니다. 123new Function1[Int, Int] &#123; def apply(x: Int) = x * x&#125; 함수호출의 확장f(a, b) (f는 일부 클래스 타입의 값) 함수의 호출은 다음과 같이 확장됩니다. 1f.apply(a, b) 그래서 객체지향(OO)으로 변환하면 12val f = (x: Int) =&gt; x * xf(7) 아래와 같을 것 입니다: 1234val f = new Function1[Int, Int] &#123; def apply(x: Int) = x * x&#125;f.apply(7) 함수와 메소드다음과 같은 메소드 자체는 함수 값이 아닙니다. 1def f(x: Int): Boolean = … 그러나 만약 함수 유형이 예상되는 곳에 f 가 사용되면, 자동으로 함수값으로 변환됩니다. 1(x: Int) =&gt; f(x) FOR 표현표준 라이브러리의 여러 데이터 타입은 map, flatMap, filter라는 메소드를 갖고있음을 알 수 있습니다.이 메소드들이 실제로 사용되는 경우가 많기 때문에 스칼라는 표현식에 대한 전용 문법을 지원합니다: map 대신: 1xs.map(x =&gt; x + 1) 다음과 같이 작성할 수 있습니다: 1for (x &lt;- xs) yield x + 1 그리고 “xs의 모든 요소 x에 x+1 하고 리턴합니다”라고 읽습니다. (역자추가) xs의 요소들에 대해 x 라고 명명하며 xs를 순회하며 x+1 을 하고, 그 결과를 새로운 리스트로 리턴합니다. filter 대신: 1xs.filter(x =&gt; x % 2 == 0) 다음과 같이 작성할 수 있습니다: 1for (x &lt;- xs if x % 2 == 0) yield x 이 문법의 이점은 이전 문법과 같이 보면 더욱 분명해집니다(가독성이 향상되었습니다): 1234for (x &lt;- xs if x % 2 == 0) yield x + 1// Equivalent to the following:xs.filter(x =&gt; x % 2 == 0).map(x =&gt; x + 1) 마지막으로 flatMap 대신: 1xs.flatMap(x =&gt; ys.map(y =&gt; (x, y))) 다음과 같이 작성할 수 있습니다: 1for (x &lt;- xs; y &lt;- ys) yield (x, y) 그리고 “xs의 모든 요소 x 와 ys의 모든 요소y를 (x,y)하고 (그 결과를 새로운 리스트로) 리턴합니다” 라고 읽습니다. 한꺼번에 값 넣기다음은 한꺼번에 값을 넣는 예제입니다: 1234for &#123; x &lt;- xs if x % 2 == 0 y &lt;- ys&#125; yield (x, y) 문법적 설탕을 해제한 코드는 이렇습니다: 1234567xs.filter &#123; x =&gt; x % 2 == 0&#125;.flatMap &#123; x =&gt; ys.map &#123; y =&gt; (x, y) &#125;&#125; 메소드의 파라미터명명된 파라미터때때로 함수에 전달된 몇몇 파라미터의 의미가 무엇인지 파악하기 어려울 수 있습니다.다음 예제를보며 생각해봅시다: 1Range(1, 10, 2) 이것은 무슨 뜻 일까요? 명명된 파라미터(named parameter)를 사용해 읽기 쉽게 만들 수 있습니다.사실 위의 코드에서 Range 는 다음과 같이 정의되어 있습니다: 1case class Range(start: Int, end: Int, step: Int) 그리고 다음과 재작성 할 수 있습니다: 1Range(start = 1, end = 10, step = 2) 이제 위 코드는 1 부터 10까지 2씩 증가시킨다 는 정의를 했음이 명확해졌습니다. 기본 값메소드의 파라미터는 기본값을 가질 수 있습니다.Range를 재정의 해 봅시다: 1case class Range(start: Int, end: Int, step: Int = 1) 위 코드에서, step 파라미터는 기본값으로 1을 가집니다.그 뒤, step 파라미터를 생략할 수 있으며, 생략할 시 컴파일러는 해당 파라미터의 기본값으로 지정한 값을 사용하게 됩니다. 12345case class Range(start: Int, end: Int, step: Int = 1)val xs = Range(start = 1, end = 10)xs.step shouldBe 1 반복된 파라미터다음과 같이 임의의 수의 파라미터(동일한 타입의)를 받을 수 있는 함수를 정의할 수 있습니다: 123456def average(x: Int, xs: Int*): Double = (x :: xs.to[List]).sum.toDouble / (xs.size + 1)average(1) shouldBe 1.0average(1, 2) shouldBe 1.5average(1, 2, 3) shouldBe 2 average 함수는 최소한 하나의 Int 파라미터와 임의의 수의 파라미터의 값들을 가져와 평균을 계산합니다.또한, 사용자가 적어도 하나의 파라미터를 제공하도록 함으로써 빈 숫자 리스트의 평균을 계산할 수 없도록 만듭니다.때로는 리스트의 각 요소를 많은 파라미터로 제공하려면, : _*를 추가합니다: 12val xs: List[Int] = …average(1, xs: _*) 타입 엘리어스(TYPE ALIASES) 비슷하게, 타입 표현식(type expressions) 으로 표현식에 의미있는 이름을 줄 수 있습니다. 1234567type Result = Either[String, (Int, Int)]def divide(dividend: Int, divisor: Int): Result = if (divisor == 0) Left(\"Division by zero\") else Right((dividend / divisor, dividend % divisor))divide(6, 4) shouldBe Right((1, 2))divide(2, 0) shouldBe Left(\"Division by zero\")divide(8, 4) shouldBe Right((2,0)) 읽어주셔서 감사합니다. 혹 글에 오역/추가할 내용이 있다면 코멘트 남겨주세요!🙆","categories":[{"name":"Scala","slug":"Scala","permalink":"https://sehajyang.github.io/categories/Scala/"}],"tags":[{"name":"scala-exercises","slug":"scala-exercises","permalink":"https://sehajyang.github.io/tags/scala-exercises/"},{"name":"Scala","slug":"Scala","permalink":"https://sehajyang.github.io/tags/Scala/"}]},{"title":"스칼라 번역- 표준 라이브러리 (Standard Library)","slug":"standard-library","date":"2019-07-16T00:00:00.000Z","updated":"2019-08-02T14:41:53.812Z","comments":true,"path":"2019/07/16/standard-library/","link":"","permalink":"https://sehajyang.github.io/2019/07/16/standard-library/","excerpt":"","text":"이 포스팅은 [scala-exercises 번역 시리즈]로 scala-exercises 사이트의 스칼라 튜토리얼을 공부하며 번역한 문서 입니다.scala-exercises 는 스칼라 창시자인 마틴 오더스키가 만든 강의의 강의자료입니다.따라서 강의를 들으며 본 문서를 같이 보는것을 추천합니다.직역보단 의역을 했기 때문에 의역이 많습니다. 오역 및 오타 등은 코멘트로 알려주세요 😄원문 : [scala tutorial higher order functions] 표준 라이브러리 (STANDARD LIBRARY)LIST함수형 프로그림에서 리스트는 기본적인 데이터 구조입니다.x1, ..., xn 요소(element)를 가지고 있는 리스트는 List(x1, ..., xn) 로 작성되어집니다. 1234val fruit = List(apples, oranges, pears)val nums = List(1, 2, 3, 4)val diag3 = List(List(1, 0, 0), List(0, 1, 0), List(0, 0, 1))val empty = List() 리스트는 불변입니다 — 리스트의 요소들은 변경될 수 없습니다. 리스트는 재귀적입니다(다음 섹션에서 볼 수 있습니다) 리스트는 동질적(homogeneous) 입니다: 리스트의 요소들은 반드시 같은 타입이어야 합니다. 요소(element)들의 타입이 T인 리스트는 List[T]로 작성되어집니다: 1234val fruit: List[String] = List(apples, oranges, pears)val nums: List[Int] = List(1, 2, 3, 4)val diag3: List[List[Int]] = List(List(1, 0, 0), List(0, 1, 0), List(0, 0, 1))val empty: List[Nothing] = List() 리스트의 생성자사실 스칼라의 모든 리스트는 이렇게 구성되어집니다: Nil (빈 리스트) :: 메소드: x::xs는 첫번째 요소(x)에 새 리스트를 지정하고, 그 뒤에 xs 목록(리스트 목록 자체)이 뒤따릅니다. 123val fruit = apples :: (oranges :: (pears :: Nil))val nums = 1 :: (2 :: (3 :: (4 :: Nil)))val empty = Nil 오른쪽과의 연관성규칙 : : 로 끝나는 작업은 오른쪽과 연결됩니다. 따라서 A :: B :: C 는 A :: (B :: C)라고 해석됩니다.그러나 다음처럼 괄호를 생략할 수 있습니다. 1val nums = 1 :: 2 :: 3 :: 4 :: Nil 하지만 :로 끝나는 작업은 오른쪽 피연산자의 메소드 호출과는 다릅니다. (역: 1이 2 요소를 호출하진 않습니다 라는 뜻 입니다)사실 위 표현식은 다음과 같습니다. 1val nums = Nil.::(4).::(3).::(2).::(1) (역자추가) 왜 이런일이 일어났냐면, 스칼라에서 이름이 콜론(:)으로 끝나는 메소드는 오른쪽 피연산자의 것으로 호출하기 때문입니다. Nil가 왜 있냐면 :: 메소드가 리스트 클래스의 멤버이기 때문입니다.만약 1::2::3 이라고 하면 마지막 3이 Int 형이라서 ::메소드가 없기 때문에 리스트로 인식이 안됩니다.1::2::3 는 Nil.(3).::(2).::(1)라는 뜻이기 때문이죠.마지막 요소에 Nil을 넣어주면 Nil은 리스트의 멤버이기 때문에 타입을 추론해 리스트로 만들어 줍니다. [출처] 리스트 조작패턴 매칭으로 리스트를 분해(decompose) 할 수 있습니다. Nil: Nil은 고정값 입니다. p :: ps : 리스트의 패턴인 head 는 p와 tail은 ps 과 매칭됩니다. 123456789101112nums match &#123; // 1 그리고 2로 시작하는 Int 리스트 case 1 :: 2 :: xs =&gt; … // 리스트의 길이 1 case x :: Nil =&gt; … // `x :: Nil`과 같습니다 case List(x) =&gt; … // 빈 리스트는 `Nil` 과 같습니다 case List() =&gt; // 2로 시작하는 또 다른 리스트를 요소로 포함하는 리스트 case List(2 :: xs) =&gt; …&#125; 연습 : 리스트 정렬리스트의 숫자들을 오름차순으로 정렬해야 된다고 가정해봅시다:리스트를 정렬하기 위한 방법 중 중 한가지 방법으로 해보겠습니다. List(7, 3, 9, 2) 리스트를 정렬하려면 우선 List(2, 3, 9)를 얻기위해 tail 인 List(3, 9, 2) 를 정렬합니다. 그 다음 head 인 7을 올바른 자리에 삽입해 List(2, 3, 7, 9)를 얻습니다. 이 아이디어를 삽입 정렬(Insertion Sort) 이라고 합니다. 1234def insertionSort(xs: List[Int]): List[Int] = xs match &#123; case List() =&gt; List() case y :: ys =&gt; insert(y, insertionSort(ys))&#125; 12345678910111213val cond: (Int, Int) =&gt; Boolean = (x, y) =&gt; x &lt; ydef insert(x: Int, xs: List[Int]): List[Int] = xs match &#123; case List() =&gt; x :: Nil case y :: ys =&gt; if (cond(x, y)) x :: y :: ys else y :: insert(x, ys) &#125;insert(2, 1 :: 3 :: Nil) shouldBe (1 :: 2 :: 3 :: Nil)insert(1, 2 :: 3 :: Nil) shouldBe (1 :: 2 :: 3 :: Nil)insert(3, 1 :: 2 :: Nil) shouldBe (1 :: 2 :: 3 :: Nil) 리스트에 대한 일반적인 작업(Common Operations)map을 사용해 요소를 바꿉니다. 1List(1, 2, 3).map(x =&gt; x + 1) == List(2, 3, 4) filter를 사용해 요소를 조건에 맞게 걸러냅니다. 1List(1, 2, 3).filter(x =&gt; x % 2 == 0) == List(2) 리스트 안의 각 요소들을 변환 후 리스트에 담고, flatMap을 사용해 결과를 단일 리스트로 만듭니다. 12345val xs = List(1, 2, 3).flatMap &#123; x =&gt; List(x, 2 * x, 3 * x) &#125;xs == List(1, 2, 3, 2, 4, 6, 3, 6, 9) 옵션 값(Option Values) Option[A]로 A 타입의 옵션 값(Option Values)을 표현할 수 있습니다.이것은 부분적으로 정의된 함수 구현시 유용합니다. 12// The `sqrt` function is not defined for negative valuesdef sqrt(x: Double): Option[Double] = … Option[A]는 None(값이 없음) 혹은 Some[A](값이 있음)이 될 수 있습니다. 12def sqrt(x: Double): Option[Double] = if (x &lt; 0) None else Some(…) 옵션 조작(Manipulating Options)패턴 매칭으로 리스트를 분해(decompose) 할 수 있습니다: 12345def foo(x: Double): String = sqrt(x) match &#123; case None =&gt; no result case Some(y) =&gt; y.toString &#125; 옵션에 대한 일반적인 작업map을 사용해 요소를 바꿉니다. 12Some(1).map(x =&gt; x + 1) shouldBe Some(2)None.map((x: Int) =&gt; x + 1) shouldBe None filter를 사용해 요소를 조건에 맞게 걸러냅니다. 12Some(1).filter(x =&gt; x % 2 == 0) shouldBe NoneSome(2).filter(x =&gt; x % 2 == 0) shouldBe Some(2) flatMap으로 값을 옵션 값(Option value)으로 변환합니다. 12Some(1).flatMap(x =&gt; Some(x + 1)) shouldBe Some(2)None.flatMap((x: Int) =&gt; Some(x + 1)) shouldBe None 에러 핸들링이 서브섹션은 오류를 핸들링하는데에 유용한 타입들을 소개합니다. TryTry[A]는 A 를 리턴하려고 시도한 계산을 표현합니다. 이것은 Success[A] 과 Failure 중 하나 입니다.None과 Failure사이엔 중요한 차이점이 있는데, Failure는 실패에 대한 이유를 알려줍니다. 123def sqrt(x: Double): Try[Double] = if (x &lt; 0) Failure(new IllegalArgumentException(x must be positive)) else Success(…) Try[A] 값 조작하기Options 와 리스트처럼, Try[A]는 대수적인 데이터 타입입니다.따라서 패턴 매칭으로 리스트를 분해(decompose) 할 수 있습니다.또한 Try[A]는 map, filter, flatMap 을 가지고 있습니다.따라서 실행중 발생한 오류는 Failure 로 변환된다는 점을 제외하면, 마치 Option[A] 처럼 동작합니다. EitherEither또한 예외 처리하는데에 유용하며, 기본적으로 타입 Either[A, B]는 A 혹은 B 타입 일 수 있는 값을 나타냅니다.이것은 Left 혹은 Right라는 두가지 경우로 나뉘어집니다.한가지 경우는 Failure를 나타내고 다른 하나는 SUCCESS를 나타낼 수 있습니다.한가지 차이점은, Try는 Throwable 이 아닌 다른 타입을 선택해 예외를 나타낼 수 있습니다.또 다른 차이점은 Either값을 변환할 때 발생하는 예외는 Failure 로 변환되지 않는다는 점 입니다. 123def sqrt(x: Double): Either[String, Double] = if (x &lt; 0) Left(x must be positive) else Right(…) Either[A, B] 값 조작스칼라 2.12 이후로 Either 는 map과 flatMap을 갖게 되었습니다. 이 메소드들은 Right 케이스로만 변환됩니다.따라서 Either는 우편향(right biased) 라고 할 수 있습니다. (Right 로만 가기 때문이죠) 12Right(1).map((x: Int) =&gt; x + 1) shouldBe Right(2)Left(foo).map((x: Int) =&gt; x + 1) shouldBe Left(foo) 또한 Either 는 filterOrElse 메소드도 갖고 있습니다.이 메소드는 만약 Right값이 predicate(술어) 를 만족하지 못하는 경우 Left로 만들어줍니다.(역 : 여기서 predicate 는 (A) ⇒ B 같은 것을 의미합니다. [참고]) 1Right(1).filterOrElse(x =&gt; x % 2 == 0, Odd value) shouldBe Left(Odd value) 그러나 스칼라 2.12 이전에는, Either는 편향되지 않았습니다(unbiased).무슨 뜻이냐면, 스칼라 2.12 이전엔 map 사용시 Side(Right or Left)를 명시적으로 지정해야 했습니다. 1234567def triple(x: Int): Int = 3 * xdef tripleEither(x: Either[String, Int]): Either[String, Int] = x.right.map(triple) tripleEither(Right(1)) shouldBe Right(3)tripleEither(Left(not a number)) shouldBe Left(not a number) 읽어주셔서 감사합니다. 혹 글에 오역/추가할 내용이 있다면 코멘트 남겨주세요!🙆 같이 보면 좋은 포스팅 HAMA 블로그 | 스칼라 강좌 (3) - List HAMA 블로그 | 스칼라 강좌 (21) - Option 과 Either","categories":[{"name":"Scala","slug":"Scala","permalink":"https://sehajyang.github.io/categories/Scala/"}],"tags":[{"name":"scala-exercises","slug":"scala-exercises","permalink":"https://sehajyang.github.io/tags/scala-exercises/"},{"name":"Scala","slug":"Scala","permalink":"https://sehajyang.github.io/tags/Scala/"}]},{"title":"스칼라 번역- 꼬리재귀 (Tail Recursion)","slug":"tail-recursion","date":"2019-07-11T05:07:42.000Z","updated":"2019-08-02T14:41:53.815Z","comments":true,"path":"2019/07/11/tail-recursion/","link":"","permalink":"https://sehajyang.github.io/2019/07/11/tail-recursion/","excerpt":"","text":"이 포스팅은 [scala-exercises 번역 시리즈]로 scala-exercises 사이트의 스칼라 튜토리얼을 공부하며 번역한 문서 입니다.scala-exercises 는 스칼라 창시자인 마틴 오더스키가 만든 강의의 강의자료입니다.따라서 강의를 들으며 본 문서를 같이 보는것을 추천합니다.직역보단 의역을 했기 때문에 의역이 많습니다. 오역 및 오타 등은 코멘트로 알려주세요 😄원문 : [scala-exercises tail_recursion] 꼬리 재귀(Tail Recurstion)재귀 함수 응용프로그램두개의 재귀 메소드의 실행과정(evaluation step) 을 비교해 보겠습니다.먼저 두 수의 최대공약수를 계산하는 gcd 메소드를 생각해봅시다.다음의 gcd 는 유클리드 알고리즘을 사용해 구현되었습니다. 12def gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b) gcd(14, 21) 는 다음의 실행과정을 거칩니다. 12345678910111213gcd(14, 21)if (21 == 0) 14 else gcd(21, 14 % 21)if (false) 14 else gcd(21, 14 % 21)gcd(21, 14 % 21)gcd(21, 14)if (14 == 0) 21 else gcd(14, 21 % 14)if (false) 21 else gcd(14, 21 % 14)gcd(14, 7)gcd(7, 14 % 7)gcd(7, 0)if (0 == 0) 7 else gcd(0, 7 % 0)if (true) 7 else gcd(0, 7 % 0)7 factorial 을 생각해봅시다: 12def factorial(n: Int): Int = if (n == 0) 1 else n * factorial(n - 1) factorial(4)는 다음의 실행과정을 거칩니다. 12345678factorial(4)if (4 == 0) 1 else 4 * factorial(4 - 1)4 * factorial(3)4 * (3 * factorial(2))4 * (3 * (2 * factorial(1)))4 * (3 * (2 * (1 * factorial(0)))4 * (3 * (2 * (1 * 1)))24 이 두 시퀀스는 뭐가 다른걸까요?가장 중요한 차이점은 gcd 경우 시퀀스가 본질적으로 감소하며 변합니다.(gcd(21, 14 % 21) 가 gcd(14, 7) 처럼 점점 줄어듭니다)그렇게 gcd의 하나의 호출에서 다음 호출로 넘어가며 마침내 종료됩니다.그리고 그 중간단계들 에는 if then elses 같은 표현식이 있습니다.어쨌든 항상 우리가 최초 호출한 모양인 gcd(a,b) 로 돌아옵니다. 반면에 factorial 에선, 하나의 요소를 매 단계마다 추가한다는 것을 알 수 있습니다.(4 * factorial(3) 에서 4 * (3 * factorial(2))으로 3 * 요소가 추가 된 것 처럼요)즉, 최종 값으로 줄어들 때 까지 표현식은 점점 커집니다. 꼬리 재귀(Tail Recursion)재활용(rewriting) 규칙의 차이점은 실제로 컴퓨터의 실제 실행의 차이로 직접 바뀝니다.(데이터를 다시 만들거나 하지 않고 재 활용 합니다)사실, 마지막 동작으로 자신을 호출하는 재귀함수가 있는 경우 해당 스택 프레임을 재사용할 수 있습니다.이것을 꼬리 재귀 라고 부릅니다. 그리고 이 트릭을 적용함으로써, 꼬리 재귀함수는 불변의 스택 영역에서 실행될 수 있습니다. 따라서 이건 단지 반복적인 프로세스(iterative process) 와는 다른 방법입니다.꼬리 재귀함수는 루프의 함수형 이며 루프처럼 효율적으로 실행됩니다. 다시 살펴보면, gdc의 else 부분에서 gcd의 마지막 동작으로 자신을 호출한다는 것을 알 수 있습니다.그리고 이것은 본질적으로 크기가 불변인 재활용 시퀀스(rewriting sequence)로 변환되며,이는 컴퓨터에서 실제 실행 시 불변의 공간에서 실행할 수 있는 꼬리재귀 호출로 변환됩니다. 반면에, factorial 을 보면 factorial(n - 1)이 호출 된 후에도 여전히 작업이 있습니다.다시말해서, 호출의 결과에 대해 n을 곱해야 한다는 걸 알 수 있습니다.따라서 재귀호출은 꼬래 재귀호출이 아니라는게 단계가 진행 되어지며 호출이 감소하지 않는 것(오히려 늘어나는 것) 에서 분명해집니다.최종 값을 계산하기 전 까지 실제로 유지해야 하는 중간 결과들의 축적이 있음을 알 수 있습니다.그러므로 factorial은 재귀 함수가 아닙니다. factorial과 gdc는 단지 자기 자신을 호출하지만, 일반적으로 함수는 다른 함수를 호출할 수 있습니다.꼬리재귀는 만약 함수의 마지막 동작으로 다른 함수를 호출하는 경우 스택프레임을 두 함수 모두에 재사용 할 수 있습니다.이러한 호출을 꼬리 호출(tail calls) 이라고 합니다. 스칼라에서의 꼬리재귀스칼라에서 현재 함수에 대한 직접 재귀 호출(directly recursive calls) 만 최적화됩니다.@tailrec 어노테이션을 사용해 꼬리재귀함수로 만들 수 있습니다. 12@tailrecdef gcd(a: Int, b: Int): Int = … 만약 @tailrec 어노테이션을 사용했지만 gcd가 꼬리재귀가 아닌경우 오류가 발생합니다. (역자추가) JVM은 보안상의 이유로 꼬리재귀를 지원하지 않기 때문에스칼라에서의 꼬리재귀는 컴파일러가 스택 하나만 사용해 재귀호출을 할 수 있도록 지원하고 있습니다.때문에 직접 호출하는 재귀호출 만 최적화가 가능하며 간접적으로 재귀호출이 일어나는 경우는 최적화 하지 못합니다.[참고] 읽어주셔서 감사합니다. 혹 글에 오역/추가할 내용이 있다면 코멘트 남겨주세요!🙆 같이보면 좋은 포스팅 Outsider’s Dev Story | Scala의 Tail Recursion 간단 예제","categories":[{"name":"Scala","slug":"Scala","permalink":"https://sehajyang.github.io/categories/Scala/"}],"tags":[{"name":"scala-exercises","slug":"scala-exercises","permalink":"https://sehajyang.github.io/tags/scala-exercises/"},{"name":"Scala","slug":"Scala","permalink":"https://sehajyang.github.io/tags/Scala/"}]},{"title":"스칼라 번역- 유효범위 (Lexical Scopes)","slug":"lexical-scope","date":"2019-07-11T04:04:44.000Z","updated":"2019-08-02T14:41:53.809Z","comments":true,"path":"2019/07/11/lexical-scope/","link":"","permalink":"https://sehajyang.github.io/2019/07/11/lexical-scope/","excerpt":"","text":"이 포스팅은 [scala-exercises 번역 시리즈]로 scala-exercises 사이트의 스칼라 튜토리얼을 공부하며 번역한 문서 입니다.scala-exercises 는 스칼라 창시자인 마틴 오더스키가 만든 강의의 강의자료입니다.따라서 강의를 들으며 본 문서를 같이 보는것을 추천합니다.직역보단 의역을 했기 때문에 의역이 많습니다. 오역 및 오타 등은 코멘트로 알려주세요 😄원문 : [scala tutorial lexical scopes] 유효범위(Lexical Scopes)중첩 함수작업을 여러 작은 함수로 분리하는 것은 좋은 함수형 프로그래밍 스타일입니다.그러나 sqrtIter, improve, isGoodEnough 같은 함수는 sqrt 의 구현만을 위한 것이지 사용되기 위한 것은 아닙니다.일반적으로 우리는 사용자가 저런 함수에 직접적으로 접근하는 것을 원하지 않습니다.이것을 해결하려면 sqrt안에 보조함수를 두어 이름 공간 오염(name-space pollution) 을 피할 수 있습니다.즉, 이렇게 따로 있던 함수들을 : 1234567891011def sqrtIter(guess: Double, x: Double): Double = if (isGoodEnough(guess, x)) guess else sqrtIter(improve(guess, x), x) def improve(guess: Double, x: Double) = (guess + x / guess) / 2def isGoodEnough(guess: Double, x: Double) = abs(guess * guess - x) &lt; 0.001 def sqrt(x: Double) = sqrtIter(1.0, x) 이렇게 말이죠: 12345678910111213def sqrt(x: Double) = &#123; def sqrtIter(guess: Double, x: Double): Double = if (isGoodEnough(guess, x)) guess else sqrtIter(improve(guess, x), x) def improve(guess: Double, x: Double) = (guess + x / guess) / 2 def isGoodEnough(guess: Double, x: Double) = abs(square(guess) - x) &lt; 0.001 sqrtIter(1.0, x)&#125; 스칼라의 블록스칼라의 블록은 중괄호로 구분됩니다. 1234&#123; val x = f(3) x * x&#125; 여기에는 일련의 정의 또는 표현식이 포함됩니다. 블록의 마지막 요소는 값을 정의하는 표현식입니다. 리턴 표현식 앞엔 보조정의가 올 수 있습니다. 블록 자체는 표현식이며, 표현이 가능할 때 마다 블록이 나타날 수 있습니다. 블록 및 가시성 블록 내부의 정의는 블록내에서만 볼 수 있습니다. 블록 내부의 정의는 블록 외부 정의와 같은 이름인 그림자 정의(shadow definitions)입니다. 123456val x = 0def f(y: Int) = y + 1val result = &#123; val x = f(3) x * x&#125; + x 이 경우 result = 16 입니다. 유효범위(LEXICAL SCOPING)블록 외부의 정의가 그림자 정의가 되지 않는 한 블록 내부에서도 볼 수 있습니다.따라서 모든 곳에서 동일한 것을 의미하는 x파라미터의 중복 발생을 제거함으로써 sqrt를 단순화 할 수 있습니다: 12345678910111213def sqrt(x: Double) = &#123; def sqrtIter(guess: Double): Double = if (isGoodEnough(guess)) guess else sqrtIter(improve(guess)) def improve(guess: Double) = (guess + x / guess) / 2 def isGoodEnough(guess: Double) = abs(square(guess) - x) &lt; 0.001 sqrtIter(1.0)&#125; 세미콜론스칼라에서 대부분의 경우 세미콜론은 옵션입니다.이렇게 쓸 수 있습니다: 1val x = 1; 그러나 대부분의 사람은 세미콜론을 생략할 겁니다.반면에 만약 한 줄에 둘 이상의 명령문이 있다면 세미콜론으로 구분해야 합니다. 1val y = x + 1; y * y 세미콜론과 삽입 연산자(SEMICOLONS AND INFIX OPERATORS)스칼라 세미콜론 규칙엔 여러행에 걸쳐있는 표현식 작성하는 방법에 대한 문제가 있습니다.예를들면 : 12someLongExpression +someOtherExpression 이럴경우 12someLongExpression; +someOtherExpression 이렇게 해석됩니다.이 문제를 해결하는데엔 두 가지 방법이 있습니다.세미콜론은 내부에 삽입되지 않으므로 괄호안에 여러 줄 표현식을 쓸 수 있습니다 (…): 12(someLongExpression + someOtherExpression) 또는 첫번째 행에 연산자를 쓰면 됩니다.이렇게 하면 스칼라 컴파일러에게 표현식이 아직 완료되지 않았음을 알릴 수 있기 때문입니다. 12someLongExpression + someOtherExpression 최상위 정의스칼라 프로그램에서 def와 val은 최상위 객체 정의(top-level object define )를 해야합니다. 1234object MyExecutableProgram &#123; val myVal = … def myMethod = …&#125; 위 코드는 MyExecutableProgram 라는 객체(object)를 정의합니다.또한 점 표기법으로 멤버를 참조할 수 있습니다 . 1MyExecutableProgram.myMethod MyExecutableProgram 정의는 다른 정의에 내포되어 있는 정의가 아니기 때문에 최상위(top-level) 정의 입니다. PACKAGES AND IMPORTS최상위 정의는 패키지로 구성될 수 있으며 클래스 혹은 객체를 패키지 안에 넣으려면 package 절을 소스 파일 상단에 사용합니다. 1234567// file foo/Bar.scalapackage fooobject Bar &#123; … &#125;// file foo/Baz.scalapackage fooobject Baz &#123; … &#125; 패키지에 있는 정의는 동일한 패키지에 있는 다른 정의 에서도 볼 수 있습니다. 123456// file foo/Baz.scalapackage fooobject Baz &#123; // Bar is visible because it is in the `foo` package too Bar.someMethod&#125; 하지만 다른 패키지에 있는 다른 정의는 못보므로 이를 참조하려면 풀 네임(fully qualified names)을 사용해야 합니다. 12345// file quux/Quux.scalapackage quuxobject Quux &#123; foo.Bar.someMethod&#125; 혹은 이렇게도 가능합니다. 1234567// file quux/Quux.scalapackage quuximport foo.Barobject Quux &#123; // Bar refers to the imported `foo.Bar` Bar.someMethod&#125; Auto Import스칼라 프로그램에서 몇몇 엔티티는 자동으로 import 됩니다. 모든 맴버가 스칼라 패키지인 경우 모든 맴버가 java.lang 패키지인 경우 모든 맴버가 싱글톤 객체인 scala.Predef 인 경우 아래는 지금까지 본 몇가지 유형 및 기능의 풀 네임 입니다. 1234Int scala.IntBoolean scala.BooleanObject java.lang.ObjectString java.lang.String 실행 프로그램 작성하기지금까지의 코드 예제는 웹 브라우저(scala-exercises 사이트)에서 실행됐지만 스칼라에서 독립 실행형 응용프로그램을 만들 수 있습니다.이러한 각 응용프로그램에는 main메소드가 있는 객체가 있습니다.예를들어 여기 “Hello World!” 가 있습니다.스칼라 프로그램: 1234567object Hello &#123; def main(args: Array[String]) = println(\"hello world!\")&#125;``` 이 프로그램을 컴파일 후 다음 명령으로 실행할 수 있습니다.```scala$ scala Hello 읽어주셔서 감사합니다. 혹 글에 오역/추가할 내용이 있다면 코멘트 남겨주세요!🙆","categories":[{"name":"Scala","slug":"Scala","permalink":"https://sehajyang.github.io/categories/Scala/"}],"tags":[{"name":"scala-exercises","slug":"scala-exercises","permalink":"https://sehajyang.github.io/tags/scala-exercises/"},{"name":"Scala","slug":"Scala","permalink":"https://sehajyang.github.io/tags/Scala/"}]},{"title":"스칼라 번역- 고차함수 (Higher Order Functions)","slug":"higher-order-function","date":"2019-07-11T02:39:20.000Z","updated":"2019-08-02T14:41:53.807Z","comments":true,"path":"2019/07/11/higher-order-function/","link":"","permalink":"https://sehajyang.github.io/2019/07/11/higher-order-function/","excerpt":"","text":"이 포스팅은 [scala-exercises 번역 시리즈]로 scala-exercises 사이트의 스칼라 튜토리얼을 공부하며 번역한 문서 입니다.scala-exercises 는 스칼라 창시자인 마틴 오더스키가 만든 강의의 강의자료입니다.따라서 강의를 들으며 본 문서를 같이 보는것을 추천합니다.직역보단 의역을 했기 때문에 의역이 많습니다. 오역 및 오타 등은 코멘트로 알려주세요 😄원문 : [scala tutorial higher order functions] 고차함수(Higher Order Functions)함수형 언어는 함수를 일급 객체(first-class) 값 으로 다룹니다.즉 값처럼 함수를 매개변수로 전달하고 결과를 반환할 수 있습니다.고차함수는 프로그램을 유연하게 조립하는 방법을 제공합니다.이렇게 마치 값 처럼 다른 함수를 매개변수로 사용하거나 함수를 결과로 리턴하는 함수를 고차함수라고 합니다. MOTIVATION a와 b사이의 정수(integer)들의 합을 합니다. 12def sumInts(a: Int, b: Int): Int = if (a &gt; b) 0 else a + sumInts(a + 1, b) a 와 b 사이의 정수(integer)들인 cube 들의 합을 합니다. 1234def cube(x: Int): Int = x * x * xdef sumCubes(a: Int, b: Int): Int = if (a &gt; b) 0 else cube(a) + sumCubes(a + 1, b) a 와 b 사이의 정수(integer)들인 factorial 들의 합을 합니다. 12def sumFactorials(a: Int, b: Int): Int = if (a &gt; b) 0 else factorial(a) + sumFactorials(a + 1, b) 이 메소드들은 비슷합니다. 공통패턴들을 제외할 수 있을까요? 고차함수를 이용해 더하기정의해봅시다: 123def sum(f: Int =&gt; Int, a: Int, b: Int): Int = if (a &gt; b) 0 else f(a) + sum(f, a + 1, b) 그리고 이렇게 작성할 수 있습니다: 1234def id(x: Int): Int = xdef sumInts(a: Int, b: Int) = sum(id, a, b)def sumCubes(a: Int, b: Int) = sum(cube, a, b)def sumFactorials(a: Int, b: Int) = sum(factorial, a, b) 함수 타입A =&gt; B의 타입은 함수 입니다. 함수 형태인 A argument 를 입력한 결과를 B 라는 결과로 리턴합니다.그러므로, Int =&gt; Int는 int를 int로 맵핑하는 함수 입니다. 익명함수(ANONYMOUS FUNCTIONS)함수를 매개변수로 전달하면 많은 작은 함수가 생깁니다.때로는 def 를 사용해 이런 함수(및 함수의 이름)를 정의해야 되는 일들은 지루합니다.string 과 비교하자면 : val을 사용해 string을 정의할 필요가 없습니다.(지루한 작업이기 때문이죠) 1val str = \"abc\"; println(str) 대신에 바로 아래와 같이 이렇게 작성할 수 있습니다. 1println(\"abc\") 왜냐하면, string 은 리터럴(literals)로 존재하기 때문입니다.이와 비슷하게 함수 리터럴을 원하므로, 함수 리터럴에 이름을 주지않고 함수를 작성하게 됩니다.이를 익명 함수(anonymous functions) 라고 합니다. 익명함수의 문법argument 를 cube 로 전달하는 함수는 다음과 같습니다. 1(x: Int) =&gt; x * x * x (x: Int)는 함수의 매개변수(parameter) 이며 x * x * x는 함수의 body 입니다.만약 컴파일러가 컨텍스트에서 유추할 수 있는 경우 파라미터의 타입은 생략할 수 있습니다.파라미터가 여러개인 경우 쉼표로 구분됩니다. 1(x: Int, y: Int) =&gt; x + y 익명함수는 문법적 설탕입니다(Anonymous Functions are Syntactic Sugar)익명함수 (x1: T1, …, xn: Tn) =&gt; e는 항상 def 를 사용해 다음과 같이 표현할 수 있습니다. 1&#123; def f(x1: T1, …, xn: Tn) = e ; f &#125; 여기서 f 는 프로그램에서 아직 사용되지않은 임의의 새로운 이름입니다 따라서 익명함수로 표현될 수 있습니다.따라서 익명함수는 문법적 설탕 이라고 할 수 있습니다. 익명함수를 이용해 더하기익명함수를 이용하면, sum 함수를 좀더 짧게 작성할 수 있습니다. 12def sumInts(a: Int, b: Int) = sum(x =&gt; x, a, b)def sumCubes(a: Int, b: Int) = sum(x =&gt; x * x * x, a, b) 읽어주셔서 감사합니다. 혹 글에 오역/추가할 내용이 있다면 코멘트 남겨주세요!🙆 같이 보면 좋은 포스팅 : 일급 함수","categories":[{"name":"Scala","slug":"Scala","permalink":"https://sehajyang.github.io/categories/Scala/"}],"tags":[{"name":"scala-exercises","slug":"scala-exercises","permalink":"https://sehajyang.github.io/tags/scala-exercises/"},{"name":"Scala","slug":"Scala","permalink":"https://sehajyang.github.io/tags/Scala/"}]},{"title":"190627-190707 주간 회고","slug":"190627-190707","date":"2019-07-08T02:37:51.000Z","updated":"2019-07-15T14:11:55.556Z","comments":true,"path":"2019/07/08/190627-190707/","link":"","permalink":"https://sehajyang.github.io/2019/07/08/190627-190707/","excerpt":"","text":"학습할 언어로 스칼라를 선택한 뒤로 한주간 다른 공부보단 스칼라 공부에 전념했다.처음엔 스칼라의 교과서라고 불리는 Programming in Scala로 학습했으나 내겐 아직 어려운 책이라 러닝 스칼라란 책을 추천받아 이 책으로 학습하고 있다.스칼라 과거에 프로그래밍 첫 언어로 C++을 독학하던 때가 생각 날 정도로 어려웠다.파이썬도 코틀린도 이렇게 어렵진 않았는데 스칼라는 이해가 가지 않는다.이 이해라는건 머리론 했는데 납득이 가지 않은 상태와 비슷해서, 이해가 안되니 배우고 금방 잊어버리기까지 한다.그러던 중 스칼라의 문법을 배우며 예제를 풀어 볼 수 있는 scala exercises 사이트에 대해 알게되었다.이 사이트에 대한 한국어 번역이 없었기 때문에, 나의 스칼라 학습 및 입문하는 분들에게 도움이 되기 위해 번역을 하기로 결정했다.이 번역을 완성하면 블로그에도 게시를 할 생각이다! 최근에 그간 얕고 넓은 지식을 쌓아온 것 같다는 생각이 들었는데, 그러한 지식 및 학습방식에 대해 염증을 느끼게 되었다.그래서 이번 학습은 바텀-업(bottom-up)방식으로 하는 만큼 탑-다운 방식 으로 공부하던 예전과 달리 좀 더 꼼꼼하게 이론/문법 등을 익히고 싶다는 욕심이 있다. 한주간 했던 학습 scala와 kotlin 비교 포스팅 Scala Exercises 학습 및 번역 Programming in Scala 학습 러닝 스칼라 학습 다음주 목표 Functional Programming Principles in Scala 수강 러닝 스칼라 학습 Scala Exercises 학습 및 번역 총평이번주는 오랜만에 새로운 언어를 학습하느라 즐겁게 공부했었다.다음주엔 Functional Programming Principles in Scala 강의를 수강할 예정이다.마틴 오더스키가 직접 강의했는데, 한글 자막이 없어서 조금 아쉽다.책은 러닝 스칼라를 먼저 본 뒤에 Programming in Scala를 봐야될 것 같다. Scala Exercises 번역은 다음주 혹은 2주뒤에 마무리 될 것 같다.한달간 주말엔 통 시간이 나지 않았는데, 다음주에는 주말에 조금이라도 짬을 내서 학습에 쏟는 시간을 늘려야겠다..","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"Scala와 Kotlin 비교","slug":"scala-vs-kotlin","date":"2019-07-02T02:49:54.000Z","updated":"2019-08-06T14:31:35.586Z","comments":true,"path":"2019/07/02/scala-vs-kotlin/","link":"","permalink":"https://sehajyang.github.io/2019/07/02/scala-vs-kotlin/","excerpt":"","text":"최근 함수형 언어(FP) 를 학습하기 위해 스칼라와 코틀린을 비교하다 정리하게 되었습니다.이 포스팅은 함수형 프로그래밍에 대한 글이 아니기 때문에 바로 스칼라와 코틀린을 비교해보도록 하겠습니다.혹시 함수형 프로그래밍이 궁금하시다면 함수형 프로그래밍 요약을 참고해주세요! Scala스칼라는 확장된 자바 를 지향하며 다중 OOP특성과 FP특성을 함께 가진 다중패러다임 언어입니다.그러한 철학은 스칼라 라는 이름에서도 볼 수 있는데, 스칼라는 Scalable(확장가능한) + Language(언어) 라는 단어의 결합으로 탄생한 이름입니다.EPFL대학의 마틴 오더스키가 만들었으며 그가 제작한 강의와 책이 있습니다.매우 강력하며 세심하게 디자인 되었지만 그 만큼 제대로 공부하고 사용하는것이 어렵다는 평을 받고 있습니다.함수형으로나 객체지향적으로 원하는 모든 기능(큰 자유와 수많은 기회)을 제공합니다.심지어 JVM에서 벗어나 컴파일 언어가 되는 작업을 진행하기도 합니다.Java에는 없는 많은 기능이 포함되어 있으며 동시 처리등의 큰 데이터 처리작업에 적합합니다. 장점 강력한 OOP 스타일의 FP 기능1급 객체(1급 시민), 고차 함수, 순수 함수, 불변성, 합성 함수 등을 잘 지원합니다 쉬운 언어 확장 및 DSL 자바와 코틀린에는 없는 기능 지원패턴 매칭, 매크로 및 상위 유형의 완벽한 지원, 동시 처리 지원 등(코틀린에도 코루틴이 있지만 스칼라의 future은 더욱 다양하게 사용 가능합니다) 연산자 오버로딩이 기능은 코틀린에도 있지만 스칼라의 연산자 오버로딩은 새로운 연산자를 정의할 수 있습니다. 코틀린에 비해 자료 및 라이브러리가 많습니다.스칼라는 2004년에 나온 언어로 코틀린에 비해 자료와 라이브러리가 풍부합니다.스택오버플로우(2019.7 기준)에서 약 7만건정도 차이나는 것을 알 수 있습니다. Java와의 호환성Java와의 호환성이 좋습니다. 스칼라에선 자바코드를 100% 가져다 쓸 수 있습니다. 단점 러닝커브가 높습니다.많은 자바 개발자들은 스칼라의 복잡성 때문에 당황했으며 높은 학습비용은 포기하는 이유가 되었습니다. 컴파일 속도가 느리며 jar 파일 용량이 큽니다.이것은 사람들이 말하는 스칼라의 가장 큰 단점 중 하나입니다. 이전 버전 컴파일이 어렵습니다(몇몇 버전은 이전 버전과 호환되지 않습니다) null safety한 측면에서 코틀린보다 별로입니다. scala 2.1.1의 경우 자바 1.8 부터 호환이 가능합니다.따라서 자바 1.8이하의 기존 레거시 코드와 같이 사용할 수 없습니다.또한 자바에서 스칼라코드를 가져와서 그대로 쓸 순 없습니다. 일각에선 스칼라는 어렵기 때문에 자바 &gt; 코틀린 &gt; 스칼라순으로 공부하는 것을 추천하기도 합니다. Kotlin 코틀린은 더 나은 자바 를 목표로 한 언어입니다.코틀린은 보일러플레이트 코드를 줄이며, null safety 한 기능을 제공하는 등 자바의 부족한 기능을 보완한 언어입니다. 장점 젯브레인사 에서 만든 언어이며 **구글 안드로이드 공식 언어로 채택되었습니다.** 강력한 null safety 기능을 제공합니다. 러닝커브가 낮습니다. 자바 개발자는 금방 코틀린에 적응할 수 있으며 쉽게 사용할 수 있습니다. Java 1.6 부터 호환이 가능하므로 기존 자바 레거시 프로젝트와의 결합이 용이합니다. 단점 Java 100% 호환 이지만 자바 서드파티들과 호환이 다 되는 것은 아닙니다.(하지만 스칼라보단 호환이 좋습니다) OOP와 FP둘다 가능한 멀티 패러다임 언어지만 Scala에 비해 다소 미약한 FP를 지원합니다.(이것은 객관적인 단점이라기보단 언어의 특성, 철학 때문입니다) 다소 아쉬운 동시성을 지원합니다. 마무리일반적으로 스칼라와 코틀린은 자바에 대한 대안입니다. 그러나 두 언어는 확연히 다른 언어입니다. 스칼라는 잘 쓰면 고급 함수 프로그래밍에 대한 강력한 자원을 제공 하지만 잘못 쓰게되면 금새 엉망이 되어버립니다.코틀린은 스칼라에 비해 다소 약한 FP를 지원하지만 배우기 쉽고 사용하기 쉬우며 자바만큼 빠른 컴파일 속도 및 가벼운 jar를 만들 수 있습니다.완벽한 100% FP는 없습니다. 얼마나 더 FP 하냐의 차이입니다. 그런 부분에 있어서 스칼라가 코틀린에 비해 더 FP할 수 있는 기능을 제공합니다.저는 좀더 FP한 언어를 원했기 때문에 스칼라를 선택했습니다.여담으로 스칼라는 안드로이드 포팅이 어렵기 때문에 코틀린이 좋습니다.두 언어는 철학부터 다르기 때문에 본인에게 필요한 언어를 파악해 잘 선택하는것이 중요하겠습니다. 큰 데이터로 작업을 하거나 속도를 높이고 싶으면 스칼라가,배우기 쉬우며 향상된 자바를 원하면 코틀린을 선택하는 것이 좋을 것 같습니다. 읽어주셔서 감사합니다. 혹 글에 오류/추가할 내용이 있다면 코멘트 남겨주세요!🙆 참고 Scala vs Kotlin Kotlin vs. Scala: What Should I Choose Instead of Java? Kotlin vs Scala: Which Problems Do They Solve? Scala vs Kotlin: Operator overloading","categories":[{"name":"Scala","slug":"Scala","permalink":"https://sehajyang.github.io/categories/Scala/"}],"tags":[{"name":"Scala","slug":"Scala","permalink":"https://sehajyang.github.io/tags/Scala/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://sehajyang.github.io/tags/Kotlin/"}]},{"title":"190529~190625 월간회고","slug":"190529-190625","date":"2019-06-25T05:27:42.000Z","updated":"2019-08-02T14:41:53.792Z","comments":true,"path":"2019/06/25/190529-190625/","link":"","permalink":"https://sehajyang.github.io/2019/06/25/190529-190625/","excerpt":"","text":"해커톤 이후 바쁘기도 하고 블로그도 리뉴얼 하느라 한달만에 주간회고 월간회고를 작성하게 되었다. 주간회고를 적는 이유는 그 주에 어떤걸 배웠고 어떤걸 배울건지 계획을 세우는, 한주를 마무리짓는 중요한 작업 중 하나였는데 바뻣다는 핑계로 미루게되어 부끄럽다. 한달동안 한 학습 및 개발한 것 Hexo + next theme (블로그 리뉴얼) 알고리즘 문제 풀이 Kafka Call for code 버츄얼 해커톤 Hexo + next theme블로그 프레임워크를 Jekyll에서 Hexo로 바꿨다! 처음엔 오른쪽 사이드바에 카테고리가 없는게 불만이라 수정을 시도해 봤지만 이미 만들어져 있는 테마를 갈아엎기엔 시간이 많이 들어갈 것 같아 몇번 시도하다 다른 테마로 바꾸려는데 엔진을 바꿔야 했다.루비 문법을 몰랐기 때문에 Jekyll을 사용하기가 부담스러웠고, 속도부분에서도 별로라고 생각했기 때문에 Hexo로 바꿨다.물론 Hexo 는 Github로 버전관리가 되지 않는다는 단점이 있지만 나는 그간 yml파일이 올라가는것에 대한 불만(secret key 노출 등)이 있었기 때문에 Hexo로 바꾼 후 매우 만족중이다! 버전관리에 대한 이슈는 따로 레포를 파서 관리 중이다. 몇번의 삽질 끝에 [이 포스팅]을 보게되어 참고했는데 굉장히 설명이 잘 되어있어서 삽질을 끝내고 비로소 서브모듈을 잘 달아 배포할 수 있었다😄그 밖에 카테고리, 태그등을 달았는데 생각보다 Hexo에 뉴비를 위한 카테고리, 태그등을 추가하는 방법에 대한 한글 포스팅이 적고 불충분했다.. 그래서 시간이 되면 해당 내용에 대해 포스팅 할 계획이다. 댓글은 gittalk를 사용했다. 거의 중국어로 된 포스팅이 많으며 한글로 된 포스팅이 거의 없기 때문에 문제가 생기면 해결하기가 쉽진 않았다.그 후 블로그 내의 포스팅 검색을 위한 algolia 와 구글 서치를 위한 sitemap 생성등을 마치고 기존 포스팅 규격을 새로운 블로그 규격에 맞추는 등의 작업을 했다.날 잡고 했으면 하루 이틀이면 끝냈을텐데 차일피일 미루다 보니 1~2주가 걸렸다. 하지만 처음 지킬 블로그 썼을땐 설정잡고 하는데에 몇달간 질질 끄는 등 굉장히 오래걸렸었는데, 이젠 금방 설정을 잡게되어 감게무량했다.(심지어 지인의 지킬블로그에서 카테고리가 동작하지 않는 이슈도 해결하고 풀리퀘를 날렸다😮)깃허브 블로그는 한번 설정 잘하고 잘 만들어두면 후에 포스팅만 작성하면 되기 때문에 애용하고 있다. 알고리즘 문제 풀이최근 지인들과 알고리즘 문제풀이를 시작했는데, 몇가지 문제 중 Farm 문제가 기억에남는다. 이 문제는 연립방정식을 세워서 해를 구하면 되는 문제였는데, 이 문제는 식을 세우거나 브루트포스(for문 돌리기)로 해결할 수 있다.후자의 경우 범위가 크게 늘어나면 시간이 오래걸린다는 단점이 있으므로 나는 식을 세우는 방향을 택했다.식을 세우는 작업은 예외도 같이 생각해야 하기 때문에 예외를 생각해서 처리하지 않으면 십중팔구 틀린다! 나는 식 및 예외는 잘 처리한 것 같은데 자꾸 틀려서 헤메다 자꾸 틀리는 원인이 부동소수점 때문이라는 걸 알게되었다.부동소수점에 대한 설명은 이 포스팅에 잘 나와있다.부동소수점이 일어나는 원인은 컴퓨터의 숫자는 2진수이기 때문에 특정값을 정확히 표현할 수 없으며 근사값을 얻어 계산하기 때문이다.이것을 해결하기 위해선 div_mod등을 사용하는 방법등이 있다.이 문제는 부동소수점의 중요성을 깨닫기에 좋은 문제인 것 같다! 항상 나누기를 할 땐 조심해야된다. Kafka최근 프로젝트에 Kafka를 도입할 각을 보고 있었다. 도입 이유로는 12345유연한 스케일링스케줄링 용이실시간성데이터의 무결성고가용성 등이 있었지만 초보인 내가 프로덕션에 도입하기엔 너무 위험한 것 같아 포기했다. Call for CodeCall for Code가 이제 제출까지 약 한달이 남았다! 최근엔 6/20일에 팀원이 모여서 24시간동안 버츄얼 해커톤을 진행했다.그러나 재난시엔 네트워크가 파괴되어 통신이 안되거나, 디바이스가 파손/분실되기도 하며배터리 이슈도 있기 때문에 한계가 많아서 아직 뚜렷한 아이디어는 내지 못했다. 좀 더 고민해봐야될 것 같다.. 2주간 목표 자료구조와 함께 배우는 알고리즘 학습 알고리즘 문제 풀이 Scala (맛보기) 공부 시작, Programming in Scala 3/e 총평이번달은 작년 슬럼프 이후로 가장 학습을 게을리 한 달 이었다..학습을 하기보단 과거에 한 학습을 써먹은 달이 되었는데, 나는 아직 배워야 할 것이 많기 때문에 아쉬운 달이 되어버렸다.다음 회고는 좀 더 알차고 게으르지 않은 회고가 되길..! 다음 회고까지 2주간 자료구조와 알고리즘에 전념할 예정이며 저번에 살짝 알아보기만 했던 Scala 공부를 천천히 시작할 것 이다 😄","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"AngelHack 2019 서울 참석 및 우승 후기","slug":"2019-06-13-angelhack-2019-seoul-win-review","date":"2019-06-12T15:00:00.000Z","updated":"2019-08-02T14:41:53.806Z","comments":true,"path":"2019/06/13/2019-06-13-angelhack-2019-seoul-win-review/","link":"","permalink":"https://sehajyang.github.io/2019/06/13/2019-06-13-angelhack-2019-seoul-win-review/","excerpt":"","text":"지난 6.1~6.2일에 엔젤핵 해커톤에 참가했다.참가한 해커톤은 AngelHack 2019 Seoul 라는 해커톤이었는데, 우승 후 진행되는 프로그램을 보니 투자를 받고자 하는 팀이 지원할 것 같은 해커톤이었고 그만큼 스폰서도 크고 많았다.해커톤은 처음이라 지인과 함께(개발자) 떨리는 마음으로 해커톤에 참가하게 되었다. 가기 전날엔 내 실력으로 민폐만 끼치는게 아닐까 하며 매우 걱정했었다.행사는 9시 시작이었는데 늦잠을 자는 바람에 10시에 도착했다. 장소는 마루 180의 지상1층과 지하1층이었는데 특이하게 지하는 차고같이 꾸며져 있었다. 실리콘밸리의 성공한 많은 기업들이 차고에서 탄생해서 그런것이었을까?굿즈(티셔츠와 스티커 등)를 받아들고 입장하니 많은 사람들이 벌써 도착해 자리가 꽉 차 있었다.150명정도 신청했는데 대략 100명정도 왔다고 한다. 일정표는 이러했다 11시부턴 팀 빌딩이었는데, 지인과 나는 둘다 백엔드 개발자였기 때문에 기획자, 디자이너, 프론트엔드 개발자를 찾아 팀을 꾸려야 했다(프론트엔드 개발자는 적었고 구할 수 없었다..)처음보는 분들과 얘기를 나누고 바로 팀으로 영입(?)시키는건 여간 어려운게 아니었다.여차저차 팀을 꾸리니 12시였고, 우리팀은 백엔드지만 프론트를 조금 하시는 개발자 한분, 백엔드인 지인과 나, 기획자, 디자이너 이렇게 다섯이서 팀을 꾸리게 되었다.그 후 후원사의 스피치가 있었고 제출은 내일 오후 1시라는것을 듣게 되었다. 이 해커톤이 제출기한이 좀 빠른거라고 개발하기 빠듯하겠다고 지인은 말했다.팀이 꾸려지자 바로 기획에 들어갔다.도전과제로는 AWS Amplify 사용, IBM 서비스를 사용, IBM의 call for code등이 있었다.처음엔 AWS Amplify를 사용하려고 했는데, 웹앱 혹은 앱 개발시에만 사용할 수 있었으므로 우린 사용할 수 없었다.IBM 서비스는 우리 모두 처음이라 셋팅하는데에 너무 오랜시간이 걸려 그냥 AWS 서비스를 사용했다. AWS에선 개발자 한명당 100$ 크래딧을 줬다! 우리팀은 Call For Code에 도전했는데, 당신의 코드로 세상을 구하다 라는 캐치프레이드로 공식 홈페이지에선자연재해 대비 및 구호를 위해 AI, 블록체인, 클라우드, IoT를 활용한 솔루션을 개발하는 글로벌 챌린지입니다라고 설명하고있다. 재난시에 사람을 살릴 수 있는 프로그램등을 개발하는 것 이다. 우리팀의 아이디어는 핫스팟을 엮어 재난시에 외부 네트워크 이용이 되지 않는(외부망에 접속이 안되는) 상황에 재난자들 사이에 프라이빗한 네트워크를 구축해 재난자들끼리 소통이 되게 하자는 것이었고 여러 아이디어중 지인이 낸 해당 아이디어로 채택되었다. 협업을 해 서비스를 짧은 시간안에 만들어야 되는 만큼 충분히 대화가 필요했다.또한, 같이 논의를 했지만 서로 이해하는바가 다르며 그 부분을 조율하고 서로 대화로써 풀고 이해하는것이 중요하다는 것을 많이 깨달았던 것 같다.멘토님들도 계셔서 멘토님들께 모르는 것을 물어보거나 작년 우승자 혹은 참가자와 컨셉이 겹치지는 않는지를 물어봤었다.다행히 전혀 겹치지 않는다고 하셔서 걱정없이 그 뒤 개발에 착수할 수 있었다.멘토님들은 돌아다니시면서 기술적으로 혹은 그 밖의 질문에 대해서 답을 해주시곤 했는데 큰 도움이 되었다. 개발은 대략 오후 3시즈음에 시작하게 되었다.내가 맡은 부분은 재난시 모니터링 및 채팅 등을 할 수 있는 이른바 어드민 페이지를 개발이었다.플라스크로 하려다 겪어본적 없는 오류가 나면 잡는데에 오랜시간이 걸릴까 불안해 익숙한 스프링부트로 개발을 했다.그리고 두번다시 해커톤에서 스프링부트를 사용하지 않으리라 다짐했다(내 숙련도에 문제가 있긴 했지만)JPA때문에 굉장히 고생을 했고 잡아뒀던 환경도 뭣도 아무것도 없었기 때문에(지금 생각해보면 뭔 자신감으로 아무것도 없이 갔나 싶다) 프로젝트 생성하고 환경 잡고 여차저차하니 대략 7시즈음이었던 것 같다.환경잡는데에 너무 많은 시간이 걸려서 당시엔 정말 속이 답답했었다. 당시 커밋로그들 밥은 정말 잘 나왔었는데 대체로 샐러드류라 조금 배가 고팠다..노트북은 한성 보스몬스터(게이밍)무겁다 새벽 2시즈음인가, JPA를 잘못 사용해서 select 순환 참조 오류가 생겼었다. 그때 정말 이거 다 밀고 플라스크로 작업할까 생각했었다. 해결하는데에 한시간정도 걸렸었는데, 정말 아찔했다.해결은 [링크] 와 같이 했다.개발시간이 빠듯하게 정해져 있어서 뭔가 이상한 오류가 나면 정말 심장이 쫄깃했던 것 같다. 한숨도 못자고 밤을 그렇게 샜다.중간에 피자와 치킨을 받았지만 먹을 시간이 없었다ㅠㅠ새벽 다섯시경 주위를 보니 다른팀 개발자분들도 안자고 열코딩중이었다. 해커톤은 원래 이렇게 빡샌가요.. 지인이 말하길 원래 이렇게 빡새다고 한다. 최초의 팀 이름은 angel cell 이었다 밤 사이 우리팀의 이름은 Conectus로 결정되었다. 맨처음엔 링크드리스트등의 후보가 있었지만 생존자를 잇는다는 의미로 Connect + Us 해서 Conectus 가 되었다.왜 Connect가 아니고 Conect인진 모르겠다 7시즈음에 대략 API를 다 완성했었다. 그 후 한 10분정도 자다가 아침이 되니 대략 정신이 나가서 아무것도 머릿속에 들어오지 않았다.나 외에 지인 및 다른 개발자분도 다 완성을 했고 우리팀은 다같이 실제 테스트(사람이 하는)를 해보고 수정하고 테스트하고를 반복하다보니 1시가 되었다. 사실 중간에 마크업 개발자의 부재로 인한 문제가 있었다. 그 때문에 어드민페이지는 API만 잔뜩 만들어두고 보여줄 수 없어서 아쉬웠다. 우리팀은 12번째 발표였다 발표 시간은 2분이었는데 굉장히 짧았다. 컨셉, 간단한 기능소개 하고 바로 시연하기에도 빠듯한 시간이었다. 후에 알게되었지만 샌프란시스코 데모데이의 발표시간이2분으로 제한되어있어 그런게 아닌가 싶다.2분의 발표 후엔 심사위원분들의 질문이 이어졌다. 질문에 대한 답은 총 14초 이상을 넘을 수 없었다. 그것 또한 데모데이의 룰과 같았다. 우리조는 간단한 기능소개(1분)+짧은 시연(1분) 으로 발표를 했는데, 다 보여주진 못했지만 아이디어나 컨셉은 잘 전달한 것 같았다.22개조의 발표가 끝나고 몇십분의 대기 후 바로 시상식이 시작되었다. 상은 IBM Challenge, AWS Challenge, AngelHack 전체 우승 이렇게 세개였는데 우리팀은 IBM과 Amplify를 사용하지 않았기에 IBM, AWS 챌린지상엔 전혀 관련이 없었고전체상 또한 굉장히 쟁쟁하고 잘 만든 팀이 많았기 때문에 나는 마음을 비우고 1박2일동안 이정도를 만들어냈다는것에 의의를 두고 있었고,아쉬운 부분도 많았지만 그냥 개인적으로 완성했다는 것에 뿌듯함을 느끼고있었다.그런데 최종우승 팀으로 우리팀이 호명되었다! 우리조원 전부 정말 하나도 기대를 하고 있지 않았었기 때문에 다같이 굉장히 놀랐었고 그야말로 대 패닉 상태였다.그렇게 얼떨떨하게 상을 받게 되었다. 많은 분들이 우리팀 아이디어가 좋았다고 칭찬해주셨다.이렇게 동료를 잘 만나 처음 참가해서 수상도 하고 정말 개발적으로 혹은 개발 외적으로 배울것도 많았던 해커톤이었다.혼자였으면 절대 못했을텐데,, 처음 만나서 다 같이 고생하고 다 같이 만들어내서 더 뜻 깊었던 것 같다.다음에 기회가 된다면 또 참가할 것 같다! 고마워요 엔젤핵!해당 소스 및 레포는 이곳에 있습니다.읽어주셔서 감사합니다!😄","categories":[{"name":"Seminar","slug":"Seminar","permalink":"https://sehajyang.github.io/categories/Seminar/"}],"tags":[{"name":"hackaton","slug":"hackaton","permalink":"https://sehajyang.github.io/tags/hackaton/"}]},{"title":"190522~190528 주간 회고","slug":"2019-05-28-190522~190528","date":"2019-05-27T15:00:00.000Z","updated":"2019-07-15T14:11:55.596Z","comments":true,"path":"2019/05/28/2019-05-28-190522~190528/","link":"","permalink":"https://sehajyang.github.io/2019/05/28/2019-05-28-190522~190528/","excerpt":"","text":"이번주엔 springboot로 약 일주일간 개발하던 사내 익명게시판 프로젝트가 어느정도 마무리 됐기 때문에 후기 겸 주간회고를 작성하게 되었다.개발하면서 가장 애먹었던 건 handlebars.js 였는데 helper가 등록되지 않는 이슈였다.나는 hbs(handlebars 확장자) 파일을 html로 변경을 한 후 springboot properties에서 그 html을 hbs 로 인식하게 했다.helper를 사용하고 싶으면, 그렇게 하면 안되는 거였다(어쩐지 구글링해도 안나오더라)그렇게 약 3일을 삽질하다 helper를 사용하고 싶다면 html를 hbs로 인식하게 하는걸 해제하고, html에 helper와 hbs 파일(혹은 script id 및 type 에 handlebars template를 삽입 하던가 )을삽입해야 한다는 것을 알게 되었다.혹은, Handlebar를 사용하여 배포까지 (+grunt +gradle) 이런 방법도 있다.하지만 최대한 간단하고 빠르게 개발하고 싶었고(이미 기존에 쓰던 기술 대신 새로운 기술로 도입한 시점부터 빠르게 개발은 무리였던 것 같지만) 무언가를 더 늘리고 싶지 않았기 때문에결국 handlebars는 순수하게 서버로부터 받아온 데이터를 보여주기만 했고, js(바닐라 및 jquery) 로 나머지.. DOM조작이라던지 를 했다.JSP에 비해 코드가 깔끔해져서 좋았지만 handlebar에 helper를 등록해서 썼다면 더 좋았을 것 같아서 아쉬웠다. JPA도 처음이었기 때문에 굉장히 고생했다. 처음엔 아무것도 모르고 늘상 하던 것 처럼 네이티브 쿼리를 짰다.심지어, @Query에 nativequery=true를 해서 쓰다가 뭔가 잘못됐음을 깨닫고, 뒤늦게 인프런에서 스프링 데이터 JPA를 수강하기 시작했다.나는 학습을 탑 다운방식으로 한다. 새로운 기술을 배울때 문서를 읽지않고 일단 get started 혹은 example 을 보고 시작하는 것이다.딱히 그게 좋아서 라기보단 그냥 탑 다운 방식에 익숙하기 때문인데, 그렇게 이번에 handlebars 및 JPA를 시작했다가 호되게 당했다. 이론/원리에 대해 혹은 문서를 좀 더 학습한 후 개발했으면 좋았을텐데 라는 생각이 들었다.아무튼, 잘못 짜고 있었다는 걸 뒤늦게 깨달았으므로 기존에 짰던건 그냥 남겨두고, 몇가지 함수만 변경했다.이번에 이런 ORM을 사용해봤는데 기존의 방식과 많이 달라서 힘들었고 삽질도 많이 했지만 재밌었다. 좀 더 강의를 수강하고 다시 이번 프로젝트를 고쳐보고싶다. 이번 토이프로젝트를 개발할 때에 gitHub 의 issue와 project를 적극 활용해봤는데, 이슈관리하기도 편하고, 좀더 다음에 무엇을 개발해야할지 우선순위 혹은 집중하기가 좋았다.이슈 하나 클리어 할 때 마다 Done 에 closed 된 이슈들이 차곡차곡 쌓이는 것도 좋았고, 이슈 넘버를 넣어서 커밋하면 자동으로 Done 으로 이동되는 것도 좋았다.다음에 개발할때에도 적극 활용할 예정이다.GitHub로 프로젝트 관리하기 Part1 - 이슈 발급 부터 코드리뷰까지이 포스팅을 참고해서 다음엔 이슈관리를 해봐야겠다. 플라스크 학습을 시작했다. 이번주에 있을 해커톤 때문인데, sanic과 비슷해서 할만한 것 같다! 애당초 sanic이 flask의 철학을 이어받아(?) 개발되었다고 한다.그래서 두 프레임워크가 비슷한 것 같다. 총평써보고 싶던 기술을 써봐서 좋았고 학습할 수 있어서 좋았다! JPA에 대해 더 알아보고 싶다.아쉬운 부분도 많았다. 특히, 탑다운 방식으로 학습하던 나는 호되게 당했다. 다음부턴 이론과 실습(?)이 핑퐁처럼 되도록 학습해야겠다.이번 프로젝트에 대해선, 좀 더 공통적인 부분을 모듈화하고 싶고 전체적으로 리팩토링을 좀 하고싶다. 최대한 레거시가 되지 않도록 노력했지만 나름대로 리팩토링을 했었지만, 결국 레거시를 잔뜩 만들고야 말았다..자꾸 많은것이 바뀌었었기 때문에 테스트코드 짜기가 힘들어서 테스트코드를 초반에만 조금 짜다가 포기했다.나는 아직 TDD는.. 잘 모르겠다. 빠르게 개발하면서 많은것이 바뀌고 계속해서 리팩토링을 하는데, 그럴때마다 테스트코드 리팩토링 하기가 참 힘든 것 같다.그래서 아직까진 다 짜둔 코드에대해(당분간 바뀌지 않을) 테스트 코드를 작성하는게 좋은 것 같다. 한주간 했던 것 springboot 익명 게시판 프로젝트 Flask 학습 시작 다음주 목표 springboot 익명 게시판 프로젝트 리팩토링 JPA 강의 학습 Flask 학습","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"190422~190521 월간 회고","slug":"2019-05-21-190422~190521","date":"2019-05-20T15:00:00.000Z","updated":"2019-07-15T14:11:55.595Z","comments":true,"path":"2019/05/21/2019-05-21-190422~190521/","link":"","permalink":"https://sehajyang.github.io/2019/05/21/2019-05-21-190422~190521/","excerpt":"","text":"어쩌다보니 2주치를 두번 밀려 월간 회고가 되어버렸다.이번달을 요약하자면 이것저것을 하다 초심으로(springboot) 돌아간 것 쯤 되겠다.슬럼프에 빠져 뭘 해도 의욕이 나지 않아서 새롭고 평소에 배우고 싶었던 걸 해보고 싶었다.그래서 스칼라도 해보고 코틀린도 해보고 카프카도 써봤다. 스칼라는 예전부터 관심이 있다가, KCD 에서 스칼라 세션을 듣고 라스칼라 슬랙에 들어가면서 더욱 관심이 많아졌었다.하지만 모든것에 초보가 되지 말라는 말을 듣고, 일단 지금은 하고있는것에 집중하고 스칼라는 나중에 해야겠다고 생각했었다.그러다 이번에 슬럼프가 오면서 일탈(?) 로 살짝 맛만(?) 봤는데 함수형과 관련이 없던 삶을 살아온지라 무슨 말인지 이해가 되지 않았다. 모나드는 대체 뭐란말인가.. 설명을 봐도 예제를 모르겠고 밑도끝도 없이 하나도 모르겠어서 나중을 기약하기로 했다.. 코틀린은 저번에 프로덕션에 적용하는걸 실패한 뒤로 개인적인 토이 프로젝트를 만들어 봐야겠다고 생각했었다.근데 아직 나는 코틀린이 엄청 좋다는건 못느끼겠다.자바에 익숙함과 그로인해 얻는 시간 및 비용의 절약을 버릴만큼 코틀린이 나에게 지금 필요하다고 생각하지 않는다.그리고 몇몇 자바 서드파티들과 호환이 되지 않는다는건 치명적이라고 생각한다.하지만 null safety 한 부분은 정말 매력적이라고 생각한다. 카프카는 그냥 메세징 큐 를 공부하다, springboot에 쉽게 시작할 수 있는 예제가 있길래 이것저것 환경을 잡아서 해봤다.우리 프로덕션 대형 문자를 보낼때 쓰면 좋겠다고 생각했다. 언젠가 카프카를 쓰는 빠른 실시간 처리가 필요한 프로젝트를 해보고싶다. 그렇게 이것저것을 하며 방황을 하던 중 사내 게시판(이라 쓰고 인트라넷이라 읽는다)이 필요하다 느껴 토이 프로젝트로 게시판 만들기를 시작했다.실제로 서비스 할 것이기 때문에 생각할게 많은 것 같다.그간 springboot + jsp + mysql로 작업을 했었는데, 이번엔 springboot+ JPA + handlebars + h2, postgreSql로 만들고 있어서 열심히 삽질하고 있다.과거의 내가 만들었던 허접한 게시판과 지금 진행중인 게시판을 비교하자면 굉장히 많은 변화가 있어서 나름 성장한 것 같다는 생각이 들기도 했다.오랜만에 처음부터 프로젝트를 만들고 설정을 잡고 이것저것 추가하고 그러한 작업이 스프링부트임에도 불구하고 거의 하루종일 했던 것 같다..그래도 최대한 기술부채 없이 하려고 나름대로 노력은 하고 있는데, 그렇게 한달 뒤에도 뿌듯한 프로젝트였으면 좋겠다. 다음달 초엔 해커톤을 나간다! 나는 스프링부트를 이용한 개발에 능숙한데(다른 프레임워크보다) 스프링부트는 스프링에 비해 설정 셋팅등이 간소화되었다고 해도 해커톤에서 쓰기엔 적합하지 않다고 생각한다.약간 소잡는 칼로 닭잡는 기분.. 그래서 가볍고 빠르게 개발할 수 있는 플라스크를 공부할 예정이다.최근에 했던 Sanic 토이프로젝트와 flask는 닮아있어서 배우는데에 큰 어려움이 없었음 좋겠다(본격 플라스크 벼락치기) 한달간 했던 것 Kotlin 학습 Scala 학습 시작 Kafka 환경잡고 써보기 Springboot 게시판 토이 프로젝트 다음주 목표 Springboot 게시판 토이 프로젝트 완성 JPA 강의 학습(인프런) Flask 학습","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"springboot migration","slug":"2019-05-07-springboot-migration-1.5to2.0","date":"2019-05-06T15:00:00.000Z","updated":"2019-07-15T14:11:55.594Z","comments":true,"path":"2019/05/07/2019-05-07-springboot-migration-1.5to2.0/","link":"","permalink":"https://sehajyang.github.io/2019/05/07/2019-05-07-springboot-migration-1.5to2.0/","excerpt":"","text":"공식 가이드대로 했을때 몇가지 오류때문에 버전 업그레이드가 잘 되지 않았었기 때문에 삽질을 줄이고자 이 포스팅을 작성하게 되었습니다 😊필수 사항 : JDK 8 이상 우선, 버전을 마이그레이션 할 때몇가지 라이브러리들은 버전을 업그레이드 해주지 않으면 에러가 납니다.그리고 한방에 버전을 쭉 올려버리면 오류를 잡았음에도 불구하고 자꾸 알수 없는 오류가 발생하며 빌드가 되지 않습니다(혹 이유를 아신다면 코멘트 부탁드리겠습니다 🙇)따라서 1.5 -&gt; 2.0 -&gt; 2.1 순서로 버전을 업그레이드 했습니다. 순서1. gradle 버전이 4.4 가 아닐경우 4.4-all 로 변경gradle &gt; wrapper &gt; gradle-wrapper.properties 에서 아래와 같이 gradle 버전을 수정합니다. 1distributionUrl=https\\://services.gradle.org/distributions/gradle-4.4-all.zip 2. build.gradle에 dependency-management를 추가12apply plugin: 'io.spring.dependency-management'runtime(\"org.springframework.boot:spring-boot-properties-migrator\") 3. springboot 버전 바꾸기1springBootVersion = '2.0.5.RELEASE' 아래부턴 쓰는 라이브러리가 다양하기 때문에버전 업그레이드로 인한 특정 라이브러리 설정의 변화로 발생하는 오류를 고치는 방법을 작성할 수 없었습니다. 대신 어떻게 고쳐야 하는지에 대한 문서는 common-application-properties 공식문서 링크 위 링크를 참고하시면 될 것 같습니다. 4. 빌드만약 컴파일 오류가 난다면 해당되는 오류를 고칩니다.(ex: log4j 오류가 나서 log4j2로 고쳤습니다) 5. application.properties 수정빌드 깨진 것을 확인 후 해당 설정을 application.properties에서 적절하게 고칩니다.(여담으로 datasource 쪽에서 자꾸 오류가 났습니다) 6. bean overridingorg.springframework.beans.factory.support.Bean Definition Override Exception위의 오류가 발생하면 application.properties 에 아래 코드를 추가합니다.spring.main.allow-bean-definition-overriding=true이것은 bean overriding을 허용한다는 것 입니다. 12The server time zone value ‘KST’ is unrecognized or represents more than one time zone : mysql-connector-java 위의 오류가 발생하면 아래와 같이 DB url의 DB명 뒤에 ?characterEncoding=UTF-8&amp;serverTimezone=Asia/Seoul 를 추가합니다 1jdbc:mysql://아이피:포트/DB명?characterEncoding=UTF-8&amp;serverTimezone=Asia/Seoul 7. 버전 업그레이드 2.0 -&gt; 2.1빌드 및 run이 성공적으로 되면 build.gradle에서 2.1.3.RELEASE 로 springboot 버전을 변경합니다. 1springBootVersion = '2.1.3.RELEASE' 그 후 위의 작업을 반복하며 오류를 잡으면 됩니다.2.1 버전 부턴 mysql 드라이버 명이 변경되었습니다. 12기존 : com.mysql.jdbc.Driver바뀐것 : com.mysql.cj.jdbc.Driver 8. properties-migrator 제거빌드 및 run이 성공적으로 되면 build.gradle 에서 추가해뒀던 아래 코드를 제거 합니다. 1runtime(\"org.springframework.boot:spring-boot-properties-migrator\") 혹 내용이 잘못되었거나 보충해야 될 부분이 있다면 코멘트 남겨주세요 🙏읽어주셔서 감사합니다 :) 추가(19.5월 기준) 만약 swagger를 쓰는데 마이그레이션 시 오류 날 경우 2.9.1로 올려주셔야 됩니다 :) 참고자료 spring-boot-migration-java 공식문서","categories":[{"name":"Spring","slug":"Spring","permalink":"https://sehajyang.github.io/categories/Spring/"}],"tags":[{"name":"Springboot","slug":"Springboot","permalink":"https://sehajyang.github.io/tags/Springboot/"},{"name":"migration","slug":"migration","permalink":"https://sehajyang.github.io/tags/migration/"}]},{"title":"spring camp 2019 참석 후기 (1부)","slug":"2019-04-29-springcamp-2019-review","date":"2019-04-28T15:00:00.000Z","updated":"2019-08-02T14:41:53.804Z","comments":true,"path":"2019/04/29/2019-04-29-springcamp-2019-review/","link":"","permalink":"https://sehajyang.github.io/2019/04/29/2019-04-29-springcamp-2019-review/","excerpt":"","text":"spring camp 2019를 다녀왔다! 티켓팅이 정말 어려웠기 때문에, 지인이나 회사의 다른 개발자분이 티켓팅에 실패해서 혼자 다녀왔다.공개된 세션들은 지금 내가 개발하고 있는 프로젝트에 많은 도움이 될 것 같아서 정말 기대를 많이 했다.특히 실전에 써먹는 스프링부트 나 Monitoring With Actuator, 무엇을 테스트할 것인가? 어떻게 테스트할 것인가?, Kotlin 프로젝트를 피할 수 없을 때 라는 세션이 그러했다.최근 테스트를 내가 제대로 하고 있는지에 대한 의문이 있었고, 모니터링에 대한 필요성을 느끼고 있어서였다.Kotlin은 저번에 Springboot에 붙이려다 실패했었기 때문에 위의 세션이 기대가 됐다.세션은 오전 10:40 분 부터 시작했는데 가는길에 시간이 조금 걸려 조금 지각을 해버렸다.로비에 들어가니 팔찌와 스티커 그리고 휴대용 선풍기를 줬다(왜인지는 모르겠는데 많은 개발세미나에선 휴대용 선풍기를 준다)굿즈를 받아들고 Track 1의 실전에 써먹는 스프링부트를 들었다.중후반에 들어왔기 때문에 아쉽게 기록을 하지 못했다. 정말 아쉬웠다. Monitoring With Actuator두번째로 들은 세션은 Monitoring With Actuator 였다.보안에 대한 의문이 있었기 때문에 예전에 한번 도입하려다 그냥 포기했었는데, 이 세션에서 어떻게 사용해야 하며 모니터링을 도와주는 도구 및 팁과룰에 대한 다양한 설명을 들을 수 있었다.Actuator는 springboot 2.0 부터 사용할 수 있는데, 다행히 저번에 버전업을 해서 도입한다면 바로 도입할 수 있을 것 같았다. 1.5에서도 사용할 수 있지만 제약사항이 많았다. Spring Actuator 란? 장애 예방, 원인파악 및 조치, 상태확인, 성능개선, 서비스상태분석을 위함 제어 도구 = endpoint 지표 제공 = metrics 사용중인 라이브러리 탐지도 한다 default endpoint default 는 health, info 만 제공 properties에서 설정할 수 있다. Enabling Endpoints web &gt; rest(health,info)로 보여줌 jmx &gt; 셧다운 제외한 모든 정보를 보여줌 spring boot 2.0 부터 spring security에 통합 혹은 따로 서버에 띄우는 방법(총 두개)으로 사용 가능 접근 가능 ip 설정 가능 Metrics 2.0 부터 특정 지표상의 key value 쌍의 지표 tag로 검색 가능 반드시 측정해야 할 지표 (RED Method) (Request)Rate (Request)Error (Request)Duration outcome code =&gt; status 간단히 잘 볼수있음 Micrometer Registry, Meter, Tag spring boot 2.0부터 지원 meterregistry cloudwatch도 있음! 자바에서 null을 안전하게 다루는 방법세번째로 들은 세션은 자바에서 null을 안전하게 다루는 방법 이었다. 내 생각에, 자바에서 가장 많이 일어나는 Exception은 nullPointer exception이 아닐까 싶다.인기가 정말 많았던 세션이라 아쉽게도 좌석 부족으로 서서 들어 기록을 하진 못했지만 ppt가 공개되었다! ppt 링크너무 너무 유익한 세션이었다. 만약 해당 강연을 듣지 못한 분은 ppt를 보고 이 강연이 얼마나 유익했을지 알 수 있을거라 생각한다.해당 세션이 끝난 후 한시즈음 점심을 먹었다. 배달의 민족 측에서 준비한 도시락이었다. 보통 세미나에선 샌드위치를 주는데 한식을 줘서 좋았다 :D 무엇을 테스트할 것인가? 어떻게 테스트할 것인가?네번째 세션은 정말 기대하던 TDD 세션이었다. TDD라기보단 테스트 세션이었지만 그래서 더 좋았다.그간 인터넷을 찾아보며 나름대로 테스트코드를 작성해오고 있었는데, 맞게 작성하고 있는지, 이건 테스트해야되는지 이건 아닌지, 이걸 테스트하기엔 너무 어려운데 과연 의미가 있는지이건 불가능한 테스트인데 어떻게 해야 하는지에 대한 고민이 많았다.그래서 Udemy에서 Master Java Unit Testing with Spring Boot &amp; Mockito 강의라도 들을까 하고 있던 차에, 한국에서! 그것도 실무자가 하고있는 스프링부트 테스트코드 강의라서 많은 기대가 됐다.그리고 이 세션은 그러한 내 많은 고민을 한번에 해결해 주었다! 그리고 나는 테스트코드를 맞게 짜고 있었다. 안도감이 들었다.강연 중간에 spock에 대한 언급이 있었는데, 생각보다 많은 분들이 사용하고 있어서 왠지 든든했다(?)spock는 정말 좋다. 처음엔 groovy가 낯설었지만 조금 적응이 되니 너무 편리했다. 테스트로부터 얻을 수 있는 것 안정감과 자신감 (정말 그렇다!) 대상은 나와 동료 무엇을 테스트 할 것인가 기존 플로우 안까지 할 필요없음 만약 걔를 테스트해야되면 걔를 빼는게 맞는거임 설계사항 그대로 테스트 코드로 옮기는게 좋음 테스트 가능한 것 불가능한 것 외부 API 테스트안됨(그렇다) 항상 성공할 수 있는것 동일한 결과가 나올 수 있는것을 테스트 어떻게 테스트 할 것 인가 바운더리 레이어까지 테스트안되는걸 끌어올려서 테스트 바운더리 레이어 = &gt; 한 모듈로서의 의미를 지니는 가장 바깥쪽 springcontext의 오용은 언어의 본질을 망각하게 될 수 있다. Context, framework 종속적이지 않은 테스트를 우선 Test double 테스트 할 수 없는 영역을 주입해서 테스트할 수 있게 해줌 무엇을 test double로 처리해야할까 H2 뭐 그런거 써서 enbedded 활용 =&gt; 제어할 수 없던 그 영역을 제어할 수 있다! Endpoint Test Spring contract test tip 테스트는 상호 독립적으로 작성 공유되는 데이터는 꼭 초기화를 한다(테스트간 서로 영향을 끼치지않도록) =&gt; Dynamic Test (Junit5) 테스트 에서 의도와 목적이 드러나도록 테스트 코드도 리펙토링 대상 앞으로 테스트코드를 더 즐겁고 확신있게(?) 짤 수 있을 것 같다. 이후에 들은 세션은 당신도 할 수 있는 레거시 프로젝트 개선 이야기, Kotlin 프로젝트 적응하기 이다.Kotlin + Spring Data JPA 세션을 듣고싶었는데, 중간에 일이 생겨 아쉽게 마지막 세션을 들을 수 없었다.이전에 kotlin 프로젝트에 자바 라이브러리를 사용하려다 대차게 실패한 적이 있기 때문에 꼭 듣고 싶었다.해당글 : Kotlin 에서 Lombok을 사용할 수 없는 문제강연 영상이나 ppt가 공개되면 봐야겠다.","categories":[{"name":"Seminar","slug":"Seminar","permalink":"https://sehajyang.github.io/categories/Seminar/"}],"tags":[{"name":"seminar","slug":"seminar","permalink":"https://sehajyang.github.io/tags/seminar/"},{"name":"spring","slug":"spring","permalink":"https://sehajyang.github.io/tags/spring/"},{"name":"Springboot","slug":"Springboot","permalink":"https://sehajyang.github.io/tags/Springboot/"}]},{"title":"190408-190421 주간 회고","slug":"2019-04-21-190408~190421","date":"2019-04-20T15:00:00.000Z","updated":"2019-07-15T14:11:55.594Z","comments":true,"path":"2019/04/21/2019-04-21-190408~190421/","link":"","permalink":"https://sehajyang.github.io/2019/04/21/2019-04-21-190408~190421/","excerpt":"","text":"이번 2주간은 조금 슬럼프였던 것 같다.늘 그렇듯 공부해야할 건 많았고 그간 해왔던 것 처럼 어떤 공부를 먼저 할지 계획을 세우기만 하면 되는데, 갑자기 그 많던 투두 리스트가 전부 사라진 것 같았다.지금 이걸 하는게 맞는지, 이렇게 공부한게 맞는지, 알수가 없었고 클린코드를 읽으면 읽을수록 이해가 안됐다.특히 테스트 코드를 작성하면서 이렇게 하는게 맞는건가 하는 생각을 많이 했다. 국내 자료도 해외 자료도 적었고, 얻을 수 있는 자료는 기본적인 것임에 불과했다.슬프게도 우아한 형제들 TDD 세미나는 떨어졌으나 다행히 Spring camp 2019 의 티켓팅에 성공했으므로 제대로 Spring TDD 에 대해 들을 수 있을 것 같다. 이번에 Sanic 실시간 채팅 토이프로젝트를 진행하며, Redis를 처음 써봤다. RDB만 쓰던 내겐 굉장히 생소했으며, PUB/SUB기능은 충격적이었다.인메모리 디비가 너무 생소해 이해하는데에 고생을 했다! 그러던 차에 AWSKRUG에서 ElastiCache [Redis/Memcached] 서비스 알아보기 밋업이 있어서 참석하기로 했다. 파이썬으로 크롤링을 시작했다. Fiddler로 HTTP/HTTPS 패킷 분석하는 법 부터 배우고 있다.회사에선 크롤링에 있어 다른 개발자가 짠 것을 고치거나 수정하거나 하는 등의 간단한(?) 작업만 해왔기 때문에이번 기회를 통해 내가 원하는 사이트의 크롤링하는 스크립트를 온전히 짤 수 있게될 것을 기대하고있다. 2주간 했던 것 TDD 공부 Sanic 실시간 채팅 토이 프로젝트 파이썬 크롤링 클린코드 사내 스터디 발표 준비다음주 목표 Sanic web chatting project 이슈 몇가지 해결 Spring camp 2019 참석 AWSKRUG 밋업 참석 총평슬럼프가 와서 벗어나려 뭐라도 해보려고 했던 것 같다. 다음주에는 좀 더 깊이있는 공부를 하고싶다.","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"비동기 기초 정리","slug":"2019-04-17-basic-of-asynchronous","date":"2019-04-16T15:00:00.000Z","updated":"2019-07-15T14:11:55.591Z","comments":true,"path":"2019/04/17/2019-04-17-basic-of-asynchronous/","link":"","permalink":"https://sehajyang.github.io/2019/04/17/2019-04-17-basic-of-asynchronous/","excerpt":"","text":"매주 목요일마다 진행하는 개발관련 사내스터디에서 비동기에 대한 발표를 들었는데 내용이 좋아서 정리를 했습니다.원본(발표자) 슬라이드는 이곳에 있고2부는 링크 에서 볼 수 있습니다 😄 1. IT Revolution 과 동시접속자 증가 직접회로를 쓰는 IC &gt; PC &gt; Internet &gt; Mobile로 발전해나감. 그 과정에서 사용자의 폭발적인 증가 사용자의 증가 =&gt; 동시 접속자 증가 이를 해결하려면? 연산을 더 빠르게 하드웨어 Upgrade(램을 더 달거나, 코어를 늘리거나..), H/W 적인 해결 Low Level Language (어셈블러 C 등) =&gt; but 어렵고 힘듦, S/W 적인 해결 동시성을 늘린다 Parallelism (병렬 처리) =&gt; CPU 더 달아서 듀얼코어.., H/W 적인 해결 Concurrency (동시성) 2. Thread and Process Thread Process보다 적은 overhead와 자원 사용 =&gt; Process안에서 Thread 영역만(그 안엔 Stack 영역만이 존재) 생성하면 되기 때문 멀티코어 활용이 어려움 =&gt; 구현하려면 굳이 멀티코어로 해줘야 됨(알아서 안해줌) Data 공유가 쉬움 공유 자원(양날의 검) Process Thread보다 더 많은 자원 사용(cpu, memory) 사용, 생성시 Code, Data, Stack, Heap영역을 다 만듦 멀티코어를 활용할 수 있음 =&gt; OS가 멀티코어를 알아서 해줌 Data 동기화가 어려움 3. Deadlock생략 추천도서 : 7가지 동시성 모델 4. Sub Routine 과 Coroutine 서브루틴 (Sub Routine) 루틴이 다 끝날 때 까지 아무것도 못함 (리턴할 때 까지 대기해야됨) 함수, 메소드 코루틴 (Coroutine) 루틴 진행 중간에 멈춰서 특정 위치로 돌아갔다가 다시 원래 위치로 돌아와 나머지 루틴을 실행 비동기와 결합하면 더 강력해진다 5. 동기(Synchronous)와 비동기(Asynchronous) 동기 sync를 맞추다 모든 루틴을 순차적으로 진행 시간관계를 동시에 또는 동일하게 유지하는 처리방식 (but 시간관계 는 어떠한 관점으로 보느냐에 따라 다름) 비동기 sync를 맞추지 않아도 되는 처리 방식 (맞출수도 아닐수도 있다) 몇몇 루틴을 비순차적으로 진행할 수도 있음 즉, 무조건 sync 다 맞추지 않아야 비동기! 이건 아님 다양한 곳에서 동기와 비동기를 활용 Serial 통신에서 활용 동기 : 클럭에 맞춰 시작과 끝 비동기: 시작과 끝을 정함 (ex)101로 시작하고 001로 끝내라) CPU 연산에서 활용(pipelining) 6. Non-block 프로세스를 비동기식으로 만들기 위해서 등장 Block 함수가 끝날 때 까지 기다림 함수의 결과를 return 함 Non Block 함수를 바로 return 함 함수의 결과를 따로 저장함 Main이 Non-block Object에 주기적으로 결과리턴을 물어봄(물어보는 건 blocking function) 리턴이 False면 기다리지않고 다른 작업을 하고 또 물어봄 리턴이 True가 되면 Non-block Object는 result를 보냄 이 과정에서 언제 끝나는지 계속 물어보는 게 필요함 =&gt; Event Loop 7. Event Loop 외부 환경에서 이벤트를 받음 이벤트 발생하면 해당 이벤트에 대한 루틴을 실행시킴 8. Non block + Event Loop → Async Non block 함수가 완료되었는지 아닌지 검사하는 event loop 작업이 완료된지 아닌지를 주기적으로 물어봄 더 효율적인 Async Loop는 어떤 작업의 상태가 바뀌었는지 select 한다 더더 효율적인 Async Loop는 작업의 상태가 바뀌면 event loop에게 알려준다(커널이 지원해줘야됨) Observer Pattern? 이런것들을 I/O multiplexing 기술들이라 한다. 9. Async Async loop에 non block이 아닌 block 함수가 들어오면? Block 함수가 실행되는 동안 event loop가 멈춘다 =&gt; 성능저하 Block 함수를 Thread나 Process로 concurrency하게 실행해서 non block처럼 만든다 But 공유자원 접근의 위험 발생 =&gt; deadlock 블라블라.. 코루틴! 10. Coroutine + Async 코루틴은 루틴 실행하고 중단했다가 다시 시작할 수 있다 동시성(concurrent) 구현 Single Thread에서 실행되기 때문에 shared data 접근 충돌 걱정이 사라짐 동시성이 있지만 또 다른 thread나 process 만들 필요가 없음 메모리 save Thread, Process를 만드는 것에 대한 오버헤드가 없음 But Blocking 함수 또는 CPU Bound 작업을 할 때 성능이 저하됨 한 작업을 할때 다른 작업을 처리할 수 없기 때문 따라서 Blocking 함수는 thread로 처리 그 Blocking 함수가 공유자원을 참조해야 하는 경우에는 동시성에 대한 지식 및 S/W 적 안전장치 마련해야됨 11. CPU Bound, IO Bound CPU Bound : 연산이나 처리량이 많은 경우 문자열 연산, 사칙연산, 영상/이미지 처리 동시성을 늘리려면 돈을 더 붓던가(h/w 업그레이드), 저급 언어로 코딩 I/O bound : 입력과 출력이 많은 경우 12. 언제 비동기를 써야할까 처리순서의 시간관계가 관련이 없는 작업이 많을 때 I/O 작업이 많을때 여러개 작업을 처리해야 할 때 궁금한 점 혹은 오류등은 아래 코멘트에 남겨주세요 😄","categories":[{"name":"Async","slug":"Async","permalink":"https://sehajyang.github.io/categories/Async/"}],"tags":[{"name":"asynchronous","slug":"asynchronous","permalink":"https://sehajyang.github.io/tags/asynchronous/"}]},{"title":"Kakao Geocode API, 주소로 위도 경도 java로 파싱하기","slug":"2019-04-17-kakao-api-geocode-parsing","date":"2019-04-16T15:00:00.000Z","updated":"2019-08-02T14:41:53.803Z","comments":true,"path":"2019/04/17/2019-04-17-kakao-api-geocode-parsing/","link":"","permalink":"https://sehajyang.github.io/2019/04/17/2019-04-17-kakao-api-geocode-parsing/","excerpt":"","text":"Kakao Geocode API로 부터 받은 데이터를 직렬화 하고 JSON객체로 바꾸고 특정 데이터를 얻어오는 작업을 할 것입니다.Kakao API를 이용하기 위해선 API Key가 필요한데, 이곳 에서 얻을 수 있습니다. 카카오 지도 API로부터 주소로 위도 경도를 받아오기 위해선 이곳에 공식 예제가 있습니다. 받아온 주소 데이터를 JSON으로헤더에 발급받은 API키를 등록 후 POSTMAN으로 요청을 날려보겠습니다. https://dapi.kakao.com/v2/local/search/address.json?query=판교역로 235 응답받은 데이터는 이러합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&#123; \"meta\": &#123; \"is_end\": true, \"total_count\": 1, \"pageable_count\": 1 &#125;, \"documents\": [ &#123; \"road_address\": &#123; \"undergroun_yn\": \"N\", \"road_name\": \"판교역로\", \"underground_yn\": \"N\", \"region_2depth_name\": \"성남시 분당구\", \"zone_no\": \"13494\", \"sub_building_no\": \"\", \"region_3depth_name\": \"삼평동\", \"main_building_no\": \"235\", \"address_name\": \"경기 성남시 분당구 판교역로 235\", \"y\": \"37.40209529907863\", \"x\": \"127.10863694633468\", \"region_1depth_name\": \"경기\", \"building_name\": \"에이치스퀘어 엔동\" &#125;, \"address_name\": \"경기 성남시 분당구 판교역로 235\", \"address\": &#123; \"b_code\": \"4113510900\", \"region_3depth_h_name\": \"삼평동\", \"main_address_no\": \"681\", \"h_code\": \"4113565500\", \"region_2depth_name\": \"성남시 분당구\", \"main_adderss_no\": \"681\", \"sub_address_no\": \"\", \"region_3depth_name\": \"삼평동\", \"address_name\": \"경기 성남시 분당구 삼평동 681\", \"y\": \"37.40206645815382\", \"x\": \"127.10864594007738\", \"mountain_yn\": \"N\", \"zip_code\": \"463400\", \"region_1depth_name\": \"경기\", \"sub_adderss_no\": \"\" &#125;, \"y\": \"37.40209529907863\", \"x\": \"127.10863694633468\", \"address_type\": \"ROAD_ADDR\" &#125; ]&#125; 위의 데이터에서 Y 좌표 값과 X 좌표값이 필요하기 때문에 해당 데이터만 가져오도록 하겠습니다. 우선 KAKAO 지도 API로 요청을 보내고 응답을 받습니다. 1234567891011String APIKey = \"발급받은 API 키\"; HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); //결과를 담을 maptry &#123; String apiURL = \"https://dapi.kakao.com/v2/local/search/address.json?query=\" + URLEncoder.encode(address, \"UTF-8\"); HttpResponse&lt;JsonNode&gt; response = Unirest.get(apiURL) .header(\"Authorization\", APIKey) .asJson(); 받아온 데이터를 JSON 객체로 변환하기 위해 ObjectMapper를 사용합니다. 12ObjectMapper objectMapper = new ObjectMapper();objectMapper.configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true); 위의 objectMapper.configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true); 는단일 리스트 객체를 싱글 값과 같게 인식합니다.ex) &quot;fruits&quot; : [&quot;apple&quot;] 를 &quot;fruits&quot; : &quot;apple&quot; 로 인식 지정된 VO에 응답받은 데이터를 셋팅지정된 형식에 잘 셋팅하기 위해 1KakaoGeoRes bodyJson = objectMapper.readValue(response.getBody().toString(), KakaoGeoRes.class); KakaoGeoRes에 응답받은 데이터를 잘 셋팅하도록 합니다. 123456789101112131415@Datapublic class KakaoGeoRes &#123; private HashMap&lt;String, Object&gt; meta; private List&lt;Documents&gt; documents;&#125;@Dataclass Documents &#123; private HashMap&lt;String, Object&gt; address; private String address_type; private Double x; private Double y; private String address_name; private HashMap&lt;String, Object&gt; road_address;&#125; X, Y값만 필요했기 때문에 위와 같이 작성했습니다.key가 응답받은 데이터와 다르면 에러가 나기 때문에 사용하지 않는 key 도 선언합니다. X,Y 값에 접근그 후 12bodyJson.getDocuments().get(0).getX()bodyJson.getDocuments().get(0).getY() 위와같이 접근할 수 있습니다. 읽어주셔서 감사합니다.혹 오류나 질문이 있다면 편하게 코멘트 부탁드리겠습니다!🙆‍♂️","categories":[{"name":"Java","slug":"Java","permalink":"https://sehajyang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://sehajyang.github.io/tags/Java/"}]},{"title":"프로젝트 내의 특정 문자 를 전부 삭제하는 법","slug":"2019-04-12-find-and-replace-all-string","date":"2019-04-11T15:00:00.000Z","updated":"2019-07-15T14:11:55.590Z","comments":true,"path":"2019/04/12/2019-04-12-find-and-replace-all-string/","link":"","permalink":"https://sehajyang.github.io/2019/04/12/2019-04-12-find-and-replace-all-string/","excerpt":"","text":"인텔리제이에서 프로젝트 내의 특정 소스를 전부 삭제해야 될 일이 있을 땐Shift + Ctrl + R위는 없앨 대상 소스를 작성하고, 아래는 그대로 놔두고 하단의 replaceAll 을 누르면 된다.","categories":[{"name":"Tip","slug":"Tip","permalink":"https://sehajyang.github.io/categories/Tip/"}],"tags":[{"name":"IntelliJ","slug":"IntelliJ","permalink":"https://sehajyang.github.io/tags/IntelliJ/"}]},{"title":"190325-190407 주간 회고","slug":"2019-04-07-190325~190407","date":"2019-04-06T15:00:00.000Z","updated":"2019-07-15T14:11:55.589Z","comments":true,"path":"2019/04/07/2019-04-07-190325~190407/","link":"","permalink":"https://sehajyang.github.io/2019/04/07/2019-04-07-190325~190407/","excerpt":"","text":"2주간 나에게 있어 가장 의미가 컸던 일은 일부지만 프로덕션에 테스트코드를 작성해 기존 코드들에 대한 테스트를 진행한 것 과 클린코드를 읽은 일 이었다.그간 TDD라던가 테스트 코드 작성에 대해 내가 아는 것 이라곤 assertThat이 전부였다.이 세상엔 TDD라는게 있고 핫하고 그걸 해야하고 그 정도로만 막연하게 느끼고 있었는데, 테스트코드를 작성 할 기회가 생겨 이것저것 찾아보며 작성 할 수 있었다.막연하게 알던 Mock 이라던가, 단위테스트라던가 통합테스트에 대해서 알 수 있었고 이젠 능숙하진 않지만 테스트코드를 작성 할 수 있게 되었다.특히 MVC 통합테스트를 하고 있을때 Post로 파라미터가 넘어가지 않는 이슈가 있었는데 개발하자 라는 슬랙 방 에서 도움 을 받아 며칠동안 고민하던 단번에 해결할 수 있었다! 클린코드를 드디어 읽었다.클린코드는 언젠간 꼭 읽어봐야지 라고 생각했었던 개발 관련 도서 중 하나였다.어떻게 함수를 작성하면 좋은지 네이밍은 어떻게 주석은 어떻게 해야되는지, 어떻게 작성하는게 독자(내 코드를 읽는 다른 개발자)에게 좋은 코드인지, 어떻게 얽혀져 있는 스파게티같은 소스를 분리해야 되는지에 대한 내용이 담겨 있다.이 책의 내용이 너무 충격적이다! 이건 새로알게된 엄청난 것 이다! 라는 부분은 별로 없다. 한번 쯤 정리가 있었으면 좋겠다고 생각했던 규칙같은 것을 정리해 둔 책 이다.아직 다 읽진 못했지만 이걸 읽고 내가 그간 작성해온 코드들이 얼마나 잘못 됐었는지, 어떤 실수를 하고 있었는지 알 수 있었다.이 책은 내 코딩 습관들을 정말 많이 바꿔 놓을 것 같다. 2주간 했던 것 Gitlab CI Beanstalk 배포(jenkins 연동) sentry 프로덕션에 적용 springboot version migraion(1.5 &gt; 2.x) springboot 테스트코드 작성(JUnit, Spock) 클린코드 읽기(진행중) 다음주 목표 Sanic web chatting project 이슈 몇가지 해결 총평더 나은 코드 및 품질에 대해 고민하고 개선했던 주 였던 것 같다.GitLab의 GitLab CI yml 파일을 작성해 자동 배포를 구현했고, Jenkins을 이용해 Beanstalk으로도 빌드 후 자동 배포를 구현할 수 있었고, springboot 프로덕션의 메이져 버전 업을 할 수 있었다.테스트 코드 작성과 클린코드를 읽은 건 내게 큰 의미가 있었다! 아직 클린코드를 다 읽지 못했지만 뒷 내용도 기대가 된다.","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"Springboot 에서 test code 작성하기 3편 - assetThat이 중복되는 테스트와 Spock","slug":"2019-04-05-springboot-test-code-3","date":"2019-04-04T15:00:00.000Z","updated":"2019-07-15T14:11:55.588Z","comments":true,"path":"2019/04/05/2019-04-05-springboot-test-code-3/","link":"","permalink":"https://sehajyang.github.io/2019/04/05/2019-04-05-springboot-test-code-3/","excerpt":"","text":"Springboot 에서 test code 작성하기 시리즈 Springboot 에서 test code 작성하기 1편 - 통합테스트(MVC) Springboot 에서 test code 작성하기 2편 - 단위테스트(Service) 추후 작성 Springboot 에서 test code 작성하기 3편 - assetThat이 중복되는 테스트와 Spock 1. 그 외의 메소드 테스트와 Spock프로덕션엔 CommonUtil이라는 클래스가 있다.그 클래스엔 문자열을 조작한다던가, 리스트를 조작하거나 어떠한 값을 검증하는 등의 메소스들이 있는데 그 클래스 내의 메소드들이 잘 동작하는지 테스트하기 위해선 많은 assertThat 이 필요했고, 그러한 중복코드를 없애기 위해 검색을 하던 중 Spock 소개 및 튜토리얼라는 튜토리얼을 보게 되었다. BDD(Behaviour-Driven Development)는 TDD가 진화한 테스트 코드 작성 방식이며사람이 쉽게 이해하기 쉬운 작성, 즉 테스트의 동작 및 의도를 직관적으로 알 수 있다는 장점이 있다.Spock는 groovy 로 작성된 프레임워크인데 JVM에서 실행되며 테스팅을 하기 위한 BDD 프레임워크이다.따라서 Given-When-Then-Expect_Where 로 시나리오를 작성하게 된다.또한 테스트 실패 시 상세하게 이유가 출력 된다 예를들어 특정 시간의 예약 가능 여부를 True/False 로 리턴하는 checkReserveYN 라는 함수가 있다고 가정한다.일반적으론 그 함수를 테스트 할 때 1234567891011@Testpublic void Test() &#123; boolean data1 = CommonUtil.checkReserveYN(\"월요일 09:00~19:00, 토요일 13:00~16:00\"); assertTrue(data1); boolean data2 = CommonUtil.checkReserveYN(\"금요일 09:00~24:00\"); assertTrue(data2); boolean data3 = CommonUtil.checkReserveYN(\"월,화 13:00~16:00\"); assertTrue(data3);&#125; 이렇게 작성하게 되는데 테스트 케이스 하나를 만들 때 마다 중복이 발생하고 있는 것을 알 수 있다.하지만 spock를 사용하면 이 부분을 해결할 수 있다. 1234567891011@Unrolldef \"#time 시간의 예약 가능 여부 : #result\"() &#123; expect: result as Boolean == CommonUtil.checkReserveYN(time as String) where: time | result \"월요일 09:00~19:00,토요일 13:00~16:00\" | true \"금요일 09:00~24:00\" | false \"월,화 13:00~16:00\" | true&#125; @Unroll 어노테이션은 메소드 명에 where의 객체값을 대입해 테스트를 수행해 위의 테스트의 결과는이렇게 나타난다. 만약 테스트가 실패한 경우 아래와 같이 상세하게 테스트 실패 이유를 출력한다.또한 request 나 session값 등은 메소드 필드에 그냥 선언해서 사용할 수 없다.즉 이렇게 사용하면 안된다. 1234567891011121314def \"세션 Id가 없으면 false를 리턴해야한다\"() &#123; given: MockHttpSession session = null MockHttpSession sessionNossId = null session.setAttribute(\"ssId\", \"1\") expect: result as boolean == CommonUtil.SessionIdCheck(ss as MockHttpSession) where: ss | result session | true sessionNossId | false&#125; 위 코드는 groovy.lang.MissingPropertyException : No such property session 가 발생한다.생성한 session 객체를 공유 하기 위해선 @shared 어노테이션을 사용하거나 static 변수로 선언하는 방법이 있다.@shared는 메소드간의 객체를 공유할 수 있게 해준다.하지만 공유 객체를 만들고 사용하는 것 보다 더 좋은 방법이 있다. 12345678910111213def \"세션 Id가 없으면 false를 리턴해야한다\"() &#123; expect: result as boolean == CommonUtil.SessionIdCheck(ss as MockHttpSession) where: ss &lt;&lt; &#123; MockHttpSession session = new MockHttpSession() MockHttpSession sessionNossId = new MockHttpSession() session.setAttribute(\"sessionId\", \"1\") [session, sessionNossId] &#125;() result &lt;&lt; [true, false]&#125; where 내 에서 session 객체를 생성한다.위와 같이 작성하면 @shared 없이 깔끔하게 코드를 작성할 수 있다.또한 result &lt;&lt; [_,false] 등으로 무시할 수 있다.자세한 내용은 링크 에서 확인할 수 있다. 참고자료 Spock Framework Reference Documentation Spock 소개 및 튜토리얼 Spock으로 테스트코드를 짜보자","categories":[{"name":"Spring","slug":"Spring","permalink":"https://sehajyang.github.io/categories/Spring/"}],"tags":[{"name":"TDD","slug":"TDD","permalink":"https://sehajyang.github.io/tags/TDD/"},{"name":"Springboot","slug":"Springboot","permalink":"https://sehajyang.github.io/tags/Springboot/"}]},{"title":"Springboot 에서 test code 작성하기 1편 - 통합테스트","slug":"2019-04-05-springboot-test-code-1","date":"2019-04-04T15:00:00.000Z","updated":"2019-07-15T14:11:55.588Z","comments":true,"path":"2019/04/05/2019-04-05-springboot-test-code-1/","link":"","permalink":"https://sehajyang.github.io/2019/04/05/2019-04-05-springboot-test-code-1/","excerpt":"","text":"Springboot 에서 test code 작성하기 시리즈 Springboot 에서 test code 작성하기 1편 - 통합테스트(MVC) Springboot 에서 test code 작성하기 2편 - 단위테스트(Service) Springboot 에서 test code 작성하기 3편 - assetThat이 중복되는 테스트와 Spock 최근 사내 프로젝트에 테스트 코드를 작성할 기회가 있었다.컨트롤러는 운영 환경과 비슷하게 테스트 하기 위해 통합 테스트, 서비스는 의존성을 줄이고 해당 서비스의 목표에만 집중하기 위해 단위테스트를 하기로 결정했다.목표는 해당 컨트롤러의 메소드가 잘 동작하는지(요청을 잘 보내고 예상한 응답을 잘 받는지), 서비스가 개별적으로 잘 동작하는지 확인하는 것 이다. 테스트에 관한 글을 찾아보던 중 우아한형제들 기술블로그에서 테스트 메소드의 이름을 한글로 짓는다는 것을 알게 되었다.테스트가 실패했을 때 어느 기능에서 오류가 났는지 직관적으로 알 수 있어 좋은 것 같아서 테스트 메소드 명을 한글로 작성했다. 1. MVC 컨트롤러 통합 테스트목표는 고객 정보를 조회 및 등록하는 메소드를 통합테스트 하는 것 이다.컨트롤러 통합 테스트는 클래스 상단에 @SpringbootTest 을 선언한다.모든 Bean을 올리는 것으로 다른 테스트에 비해 테스트 시간이 오래 소요되지만 운영환경과 비슷하게 테스트 할 수 있다.따라서 클래스에 선언한 어노테이션은 다음과 같다. 어노테이션 설명 @RunWith(SpringRunner.class) 테스트를 실행하기 위해 참조하는 클래스(SpringRunner) @AutoConfigureWebMvc MVC와 관련된 Bean을 올린다 @Transactional 테스트 후 DB 롤백 @Ignore 실제로 실행할 필요가 없기 때문에 Ignore를 선언 @SpringBootTest 모든 Bean을 올리는 통합 테스트 123456789101112131415161718192021222324252627/** * @author sehajyang * @date 2019-04-05 */@RunWith(SpringRunner.class) @AutoConfigureWebMvc @Transactional @Ignore @SpringBootTest public class CustomerControllerTest &#123; @Autowired private MockMvc mvc; @Autowired private WebApplicationContext webApplicationContext; @SpyBean private CustomerService customerService; @Autowired private ObjectMapper objectMapper; private MockHttpSession session = new MockHttpSession(); private MockHttpServletRequest request = new MockHttpServletRequest(); @SpyBean은 해당 객체를 주입받아 사용하다 given을 주면 선언한 해당 기능으로 동작하는 Bean 이다. 고객정보를 조회 및 등록하는 메소드가 있는 도메인 인 CustomerController 가 있다.아래 코드는 예시입니다. 12345678910111213141516171819202122232425262728293031@Controller@RequestMapping(\"customer\")public class CustomerController &#123; @Autowired CustomerService customerService; @GetMapping(\"\") public ModelAndView getCustomerList(HttpSession session, HttpServletRequest request)&#123; ModelAndView mav = new ModelAndView(\"customerListPage\"); List&lt;Customer&gt; customerList = customerService.getCustomerList(); mav.addObject(\"customerList\", customerList); return mav; &#125; @PostMapping(\"\") public Object regCustomerData(@RequestBody Customer customer, HttpSession session, HttpServletRequest request)&#123; // 기존에 해당 유저가 있는지 확인후 등록하는 메소드 (이렇게 하면 안됩니다(예시일뿐!)) int result; int userExist = shopService.getCustomerByCustno(customer.getCustno(1)); if(userExist &lt; 1)&#123; return Constant.RESULT_FAIL; &#125;else&#123; result = shopService.regCustomerData(customer); &#125; return (result &gt; 0) ? Constant.RESULT_SUCCESS : Constant.RESULT_FAIL; &#125;&#125; 코드상엔 없지만 CustomerController의 모든 메소드의 session과 header에는 특정 값이 셋팅되어 있어야 한다고 가정한다.따라서 위 getCustomerList 를 테스트 하는 코드는 다음과 같다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Before //테스트 수행시 실행 public void setUp() &#123; //Integration Test this.mvc = MockMvcBuilders.webAppContextSetup(webApplicationContext) .dispatchOptions(true) //HTTP TRACE 요청을 디스패치할지 여부를 설정 (default는 false) .alwaysDo(print()) .build(); session.setAttribute(\"Id\", \"셋팅 값\"); request.addHeader(\"X-FORWARDED-FOR\", \"셋팅 값\"); &#125; @Test public void 고객리스트_조회가_정상적으로_되어야한다() throws Exception &#123; List&lt;Customer&gt; customerList = customerService.getCustomerList(); this.mvc.perform(get(\"/customer\") .session(session) .header(\"X-FORWARDED-FOR\", request.getHeader(\"X-FORWARDED-FOR\")) ) .andExpect(status().isOk()) // 200 return .andExpect(view().name(\"customerListPage\")) // 리턴할 view page name .andExpect(model().attribute(\"customerList\", customerList)); // 리턴할 model attribute name // redirect 리턴일 경우 //.andExpect(redirectedUrl(\"/\")) //.andExpect(status().is3xxRedirection()) &#125; @Test public void 고객정보_등록이_예외없이_되어야한다() throws Exception &#123; Customer customer = new Customer(\"1\",\"sehajyang\"); // Customer(custno, custname) given(customerService.getCustomerByCustno(customer.getCustno())).willReturn(1); // getCustomerByCustno 의 result는 1을 리턴 this.mvc.perform(post(\"/customer\") .contentType(MediaType.APPLICATION_JSON) .content(objectMapper.writeValueAsString(customer)) // JSON으로 만들어준다 .session(session) .header(\"X-FORWARDED-FOR\", request.getHeader(\"X-FORWARDED-FOR\")) ) .andExpect(status().isOk()) .andExpect(content().string(\"SUCCESS\")) .andReturn() .getResponse(); &#125; 그 밖에도 param() 등 으로 파라미터를 넘길수도 있다.이렇게 Controller를 통합테스트 를 실행해 전체 플로우를 테스트 할 수 있다. @SessionAttributes를 사용하는 방법도 있는데 이 경우엔 테스트 코드에서 requestAttr() 대신 sessionAttr()을 사용할 수 있다.이 방법은 이곳의 예제로 확인할 수 있다. 만약 123@PostMapping(\"\")public Object regCustomerData(Customer customer, HttpSession session, HttpServletRequest request)&#123; 이렇게 DTO에 @RequestBody가 없는 도메인을 테스트하려면 조금 복잡해진다.나는 회사 코드의 POST 도메인 파라미터 DTO에 일부 @RequestBody가 없었고, @RequestBody를 추가 할 경우 문제가 생길 수 있었기 때문에기존 코드를 변경하지 않고 테스트 하는 방법을 찾아보았다. 우선 Spring에서는 권장하지 않는다 그 이유는 아래와 같다.대략 이렇게 이해할 수 있다. 통합 테스트의 주 목적 중 하나는 MockMvc 모델 객체가 Object 데이터로 바뀌었는지 확인하는 것 이다.NewObject(DTO)를 자동으로 변환하면 NewObject(DTO)가 실제 form과 호환되지 않는 문제가 있는데, 이러한 문제가 있는 파라미터는 테스트에서 제외되기 때문이다. 그래서 @RequestBody가 없는 도메인의 DTO 파라미터는 십중팔구 넘어가지 않으며 null이된다.이것을 해결하기 위한 방법은 두가지 정도가 있다. HttpClient 사용1234567891011121314151617@Test public void 고객정보_등록이_예외없이_되어야한다() throws Exception &#123; Customer customer = new Customer(\"1\",\"sehajyang\"); // Customer(custno, custname) given(customerService.getCustomerByCustno(customer.getCustno())).willReturn(1); // getCustomerByCustno 의 result는 1을 리턴 this.mvc.perform(post(\"/customer\") .contentType(MediaType.APPLICATION_FORM_URLENCODED) .content(EntityUtils.toString(new UrlEncodedFormEntity(Arrays.asList( new BasicNameValuePair(\"custno\", \"1\"), new BasicNameValuePair(\"custname\", \"sehajyang\") ))))) .andExpect(status().isOk()) .andExpect(content().string(\"SUCCESS\")) .andReturn() .getResponse(); &#125; buildUrlEncodedFormEntity() 이용1234567891011121314151617181920212223242526272829303132333435363738394041@Test public void 고객정보_등록이_예외없이_되어야한다() throws Exception &#123; Customer customer = new Customer(\"1\",\"sehajyang\"); // Customer(custno, custname) given(customerService.getCustomerByCustno(customer.getCustno())).willReturn(1); // getCustomerByCustno 의 result는 1을 리턴 this.mvc.perform(post(\"/customer\") .contentType(MediaType.APPLICATION_FORM_URLENCODED) .contentType(MediaType.APPLICATION_FORM_URLENCODED) .content(buildUrlEncodedFormEntity( \"custno\",\"1\", \"custname\",\"sehajyang\" )))) .andExpect(status().isOk()) .andExpect(content().string(\"SUCCESS\")) .andReturn() .getResponse(); &#125;private String buildUrlEncodedFormEntity(String... params) &#123; if( (params.length % 2) &gt; 0 ) &#123; throw new IllegalArgumentException(\"Need to give an even number of parameters\"); &#125; StringBuilder result = new StringBuilder(); for (int i=0; i&lt;params.length; i+=2) &#123; if( i &gt; 0 ) &#123; result.append('&amp;'); &#125; try &#123; result. append(URLEncoder.encode(params[i], StandardCharsets.UTF_8.name())). append('='). append(URLEncoder.encode(params[i+1], StandardCharsets.UTF_8.name())); &#125; catch (UnsupportedEncodingException e) &#123; throw new RuntimeException(e); &#125; &#125; return result.toString(); &#125; Testing Form posts through MockMVC에서 더 알아볼 수 있다. 위 시리즈는 3부로 나뉘어 통합테스트, 단위테스트, spock를 사용한 테스트로 작성 될 예정입니다.많이 미숙하지만 지속적으로 알아가고 있습니다.혹 틀린 부분 혹은 궁금한 점이 있다면 댓글 부탁드리겠습니다 읽어주셔서 감사합니다!🙏 참고자료 Mokito 공식 문서 Mokito github wiki Yun 님의 Test Guide","categories":[{"name":"Spring","slug":"Spring","permalink":"https://sehajyang.github.io/categories/Spring/"}],"tags":[{"name":"TDD","slug":"TDD","permalink":"https://sehajyang.github.io/tags/TDD/"}]},{"title":"190311-190324 2주간 회고","slug":"2019-03-24-190311~190324","date":"2019-03-23T15:00:00.000Z","updated":"2019-07-15T14:11:55.587Z","comments":true,"path":"2019/03/24/2019-03-24-190311~190324/","link":"","permalink":"https://sehajyang.github.io/2019/03/24/2019-03-24-190311~190324/","excerpt":"","text":"2주간 토이 프로젝트인 파이썬 실시간 채팅서버 작업을 했고, 알고리즘을 풀었다.3/16일엔 코무에서 주최한 프론트엔드와는 무관합니다만, 을 다녀왔었다.사내에선 jenkins를 서비스중인 라이브 프로젝트에 적용해 특정 브랜치에 push or merge request accept 이벤트가 발생하면 빌드 후 배포 및 slack 알림이 가능하게 되었고, sentry도 붙여봤다. 파이썬 실시간 채팅 프로젝트는 설계를 잘 못해서 유저 간 채팅 기능을 추가하려하자 구조적으로 문제가 있어서 전부 다시 뜯어고쳤다.다행히 잘 해결되었고, 이제 asyncio-redis를 보며 적용할 생각인데 그냥 처음부터 redis를 쓸걸 하는 후회가 된다.. 알고리즘은 프로그래머스의 (2017년)KAKAO BLIND RECRUITMENT를 풀고 있다.그 중 이 문제는 정규식을 잘 만들어야되는 문제였는데 과거의 나라면 못 했을 것이다.하지만 이젠 어느정도는(?) 정규식을 짤 수 있어서 기뻤다. 프론트엔드와는 무관합니다만, 세미나는 정말 좋았다. 특히 ES10 변경점을 설명한 세션과 vue의 Virtual DOM에 대한 세션이 좋았다.이러이러한 변경점이 있습니다 하고 끝나지 않을까 조금 걱정했었는데, 그런 걱정이 무색하게 어느정도 깊이있고 좋은 내용이었다.observer pattern이나 generator 에 대한 이해가 있으면 더 즐겁게 들을 수 있었다.필기를 하면서 들었으면 좋았을텐데 아쉽게도 필기를 하지 못했다.다음에 또 참석하게 된다면 그땐 필기를 하며 들을 생각이다. 세미나를 다녀온 뒤 알고리즘을 풀다 flatten을 할 일이 있었다. 세미나에서 들었던 es10의 변경점 중 하나인 flatten 은 쉽게말해 배열을 펴는 건데, 그 중 flat(Infinity)는 다중 배열도 1차원 배열로 펼 수 있다. 123const array = ['a', ['b', ['c', 'd'], 'e' ]array.flat(); // ['a', 'b', Array(2), 'e']array.flat(Infinity); // ['a','b','c','d','e'] 파이썬에 flat(Infinity)같은 건 없없지만 itertools를 활용하니 비슷하게 해결할 수 있었다! 참고 링크 2주간 했던 것 Python 으로 알고리즘 문제 몇 개 Sanic web chatting project 프론트엔드와는 무관합니다만, 참석 Jenkins Sentry blog 페이징 이슈 해결 다음주 목표 Sanic web chatting project 현재 열려있는 이슈들 해결 Python 으로 알고리즘 문제 몇 개 계속 총평이번주는 나름대로 그간 성장해왔음을 알 수 있었던 주 였던 것 같다! 예를들면 알고리즘을 풀며 느꼈고, 세미나를 듣는데 전보다 이해를 할 수 있을때 느꼈고, 도큐먼트와 라이브러리를 까보며 문제를 해결했을 때 느꼈고, 묵혀뒀던 블로그 관련 이슈들을 하나씩 고쳐가며 느꼈다. 과거에 할 수 없을거라 느꼈던 것을 해결하거나 할 수 있게 되었을때의 순간이 있는데 그게 내가 개발을 좋아하는 큰 이유중 하나라는 생각이 들었다.","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"gitlab에 이미 push된 commit 삭제","slug":"2019-03-11-git-reset-push","date":"2019-03-10T15:00:00.000Z","updated":"2019-07-15T14:11:55.587Z","comments":true,"path":"2019/03/11/2019-03-11-git-reset-push/","link":"","permalink":"https://sehajyang.github.io/2019/03/11/2019-03-11-git-reset-push/","excerpt":"","text":"gitlab, github등에 취소해야 되는 commit이 있는데 이미 push 해버렸을 때git bash에서 1git reset --hard 되돌아가고자 하는 커밋주소 커밋 주소는 git log 로 알 수 있다 reset 옵션으론 hard, soft, mixed 가 있다 링크 그 후 1git push origin +브랜치명 브랜치 명 앞에 +를 붙여야 한다(덮어씌운다는 의미)+ 없이 push 해버리면 최근 커밋을 pull 하라며 에러가 난다. 만약 1! [remote rejected] master -&gt; master (pre-receive hook declined) 이런 에러가 났다면 해당 project settings &gt; Repository &gt; Protected Branches에서 unprotected로 해당 브랜치를 설정해주면 된다 (보통 master에 걸려있음)","categories":[{"name":"Git","slug":"Git","permalink":"https://sehajyang.github.io/categories/Git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://sehajyang.github.io/tags/git/"}]},{"title":"190225-190310 2주간 회고","slug":"2019-03-10-190225~190310","date":"2019-03-09T15:00:00.000Z","updated":"2019-07-15T14:11:55.585Z","comments":true,"path":"2019/03/10/2019-03-10-190225~190310/","link":"","permalink":"https://sehajyang.github.io/2019/03/10/2019-03-10-190225~190310/","excerpt":"","text":"저번 주 회고에 이어서 Python으로 몇 가지 알고리즘 문제를 풀었다.또한, 사내 프로젝트에 Jenkins를 붙였다.약 2일이 걸렸고, 그 과정에서 발생했던 삽질들을 모아 Jenkins 삽질기를 작성하고 있다. Python 비동기 웹 프레임워크인 Sanic으로 실시간 채팅 웹 애플리케이션을 만들고 있다.그간 써온 웹 프레임워크는 커뮤니티가 커서 웬만한 오류는 검색하면 다 나왔었는데Sanic은 자료가 적고 인지도도 낮아서 고생하고 있다.그래도 async를 자유자재로 쓸 수 있다는 건 굉장히 매력적이다. 회사에서 어떤 python script를 async로 고쳤다! 기존엔 작업 완료까지 18분 정도 걸렸는데, 이젠 1분이면 작업이 완료된다.그간 async이론만 공부했었는데, 이번에 실제로 해보고 나니 굉장히 충격적이었다! (그리고 어려웠다)async는 어려운 만큼 매력적인 것 같다. Intelli J의 springboot starter로 Kotlin + Springboot 프로젝트를 시작해봤다.Kotlin에 Java를 섞어 쓸 수 있다고 듣기만 했지 실제로 자바 파일을 섞어보진 않았었는데,이번에 섞어볼 수 있어서 Springboot + Kotlin + Java로 만들어봤다.역시 100% 호환이 되었다! 왜 많은 서비스가 Java에서 Kotlin으로 바꾸고 있는지 조금이나마 알 것 같았다.앞으로 좀 더 알아볼 생각이다. 2주간 했던 것 Python 으로 알고리즘 문제 몇 개 Sanic web chatting project Jenkins Springboot + Jenkins blog 가독성 업데이트 다음주 목표 Python Study Sanic web chatting project Jenkins 학습 간간히 총평무려 Jenkins를 개발 팀장님의 배려로 사내 프로젝트에 붙일 수 있었는데, 라이브 서비스에 붙여보긴 처음이라 실수도 많이 하고 삽질도 많이 했었다. 그래도 완성하고 나니 정말 뿌듯했다.최근 여러가지 기술 블로그를 보고 가독성의 중요성을 깨닫게 되어 몇 개월간 미뤄뒀던 블로그의 카테고리 분류 및 가독성 향상 작업을 했다.아직 마음에 안드는 부분이 조금 있어서 차차 고쳐야 될 것 같다. Python 기존 스크립트를 비동기로 바꾸기도 했는데, semaphore를 걸지 않고 request를 날리다가 차단당하는 등의 일이 있었지만. 구글링과 주변 개발자분의 도움으로 제대로 완성할 수 있었다.그 과정에서 알던 것도 있었고 새롭게 배운 것도 있었다. 다음엔 꼭 내 힘으로 완성해보고 싶다. 우연히 패스트 캠퍼스에서 올렸던 몇 가지 동영상을 보게 되었는데, 그 영상들을 보고 많은 생각을 하게 됐다.영상 링크1, 링크2최근들어 내가 한가지 기술에 집중하는게 아닌, 넓고 얕게 이것저것 배우고 있다는 생각을 하고 있었다.그래서, 지금 진행중인 Python web framework인 Sanic으로 실시간 채팅 웹 토이 프로젝트를 조금 오래 걸리더라도 제대로 해서 내 것으로 만들 수 있도록 해야겠다..!","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"Kotlin 에서 Lombok을 사용할 수 없는 문제","slug":"/etc/2019/03/07/kotlin-and-lombok.html","date":"2019-03-06T15:00:00.000Z","updated":"2019-07-15T14:11:55.584Z","comments":true,"path":"2019/03/07//etc/2019/03/07/kotlin-and-lombok.html/","link":"","permalink":"https://sehajyang.github.io/2019/03/07/etc/2019/03/07/kotlin-and-lombok.html/","excerpt":"","text":"최근 자바 스프링부트로 되어있는 사내 프로젝트에 코틀린을 일부분 도입하려다 대차게 실패했다..사내 프로젝트에 Lombok을 사용하고 있었는데, 코틀린이 롬복을 사용한 Bean Class 에 접근하지 못하고 있었다. 당시 1Kotlin: Cannot access &apos;가가&apos; it is private member of &apos;나나&apos; 이런 에러 메세지를 띄우며 컴파일이 되지 않았다. 처음엔 자바로 짜여진 클래스의 private object에 접근을 못해서 나는 에러인 줄 알았으나 롬복 문제였다.kotlin-doesnt-see-java-lombok-accessors그리고 위 링크에서 이유를 알 수 있었다. 위 링크를 요약하자면 일반적으로 JVM 에선 코틀린이 먼저 컴파일 된 후 자바가 컴파일 된다.코틀린이 자바의 롬복으로 된 클래스에 접근하려 했으나 getter setter가 만들어지지 않아서 접근을 하지 못한다.롬복은 컴파일시 동작 하는 어노테이션이기 때문이다.강제로 컴파일러가 자바 먼저 컴파일하게 바꿀 순 있지만 그렇게 되면 자바에서 코틀린 코드를 사용할 수 없다. 코틀린과 자바가 100% 호환은 맞지만 자바로 만들어진 third-party 라이브러리 들과 호환 되는건 아닌 것 이다.롬복을 사용한 자바 파일들을 전부 코틀린으로 바꾸지 않는 한 코틀린을 현재 진행 중인 프로젝트에 적용 하긴 힘들 것 같다. 두줄요약 코틀린과 롬복을 같이 쓸 수 없다. 코틀린을 정말 쓰고싶다면 롬복을 사용한 자바 파일을 코틀린 파일로 바꿔야 된다. 19.06.26 기준 자세한 포스팅이 나왔습니다! Naver D2 Kotlin 도입 과정에서 만난 문제와 해결 방법 혹 궁금하거나 오류가 있다면 댓글 남겨주세요😄","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://sehajyang.github.io/categories/Kotlin/"}],"tags":[]},{"title":"190221-190224 반 주간 회고","slug":"2019-02-24-190221~190224","date":"2019-02-23T15:00:00.000Z","updated":"2019-07-15T14:11:55.583Z","comments":true,"path":"2019/02/24/2019-02-24-190221~190224/","link":"","permalink":"https://sehajyang.github.io/2019/02/24/2019-02-24-190221~190224/","excerpt":"","text":"주간회고 주기를 맞추기 위해 이번주는 두개나 올리게 되었다..며칠간 주문했던 TDD책이 오거나 scala 강의를 신청하거나 알고리즘을 풀거나 KCD를 가는 등의 이슈가 있었다. 조만간 내가 개발하고 있는 서비스에 jenkins를 붙일 것 같다! 과거 내 springboot에 jenkins를 붙일 때 큰 문제가 없었던 걸 생각해보면 크게 어렵지 않을 거라고 생각하고있다.. 아마도..? 반 주간 했던 학습 Python Study 알고리즘 몇 문제 KCD 참석 다음주 목표 스프링 기반 TDD REST API 개발공부 및 기록 계속 Python Study 알고리즘 계속 KCD(Korea Community Day) 2019주말에 KCD를 갔다왔다.간략한 정리 총평KCD 에서 스칼라와 코틀린에 대한 세션을 들었다.코틀린은 현업에서 사용할 수 있을 것 같았다.스칼라는 시작하고 싶지만 요즈음 파이썬을 공부하고 있기 때문에 나중으로 조금 미루기로 했다.조만간 알고리즘 푼 것 들을 정리할 생각이다.","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"190204-190220 몇 주간 회고","slug":"2019-02-20-190204~190220","date":"2019-02-19T15:00:00.000Z","updated":"2019-07-15T14:11:55.582Z","comments":true,"path":"2019/02/20/2019-02-20-190204~190220/","link":"","permalink":"https://sehajyang.github.io/2019/02/20/2019-02-20-190204~190220/","excerpt":"","text":"회사일 및 기타 사정으로 인해 연휴 이후에 주간회고를 작성하지 못했는데그로인해 몇 주 지나니 2월간 내가 무엇을 학습했는지 모르는 상태가 되어서 급하게 주중에 다시금 주간회고를 작성하게 되었다. 주간회고를 작성하지 않은 기간 동안 비동기 및 쓰레드 공부를 해서 1월에 비해보다 깊이 비동기 및 python asyncio에 대해서 배우고 공부할 수 있었다. Springboot 의 강력한 기능중 하나인 Actuator를 도입할 생각을 하고있다 Vue.js 입문, Typescript 입문을 했다. Vue는 예전에 잠깐 사용해본 React랑 비슷한 부분도 다른 부분도 있었는데일단, 굉장히 React에 비해 사용하기 쉽고 공식문서가 잘 되어있다는 느낌을 받았다. 몇 주간 했던 학습 스프링 기반 TDD REST API 개발 수강 후 기록 Springboot migration JDK8 stream에 대한 공부 Python Syntax 공부 Python Built-in Library &gt; asyncio — Asynchronous I/O 관련 학습 asyncio / thread를 사용한 request 예제 kocw 운영체제 강의 Jenkins 삽질 Springboot Actuator 토이프로젝트에 적용 및 체험 Vue, Typescript 입문 다음주 목표 스프링 기반 TDD REST API 개발공부 및 기록 계속 Python Study asyncio / thread 공부 계속 이번주에 읽었던 글 몇가지 자바 프로그래머가 자주 실수 하는 10가지 읽는 내내 내 얘기같아서 너무 찔렸다. 이 글을 읽고 어느정도 그러한 문제들을 개선하게 되었다. 예를들면 아무 생각없이 ArrayList를 사용하거나 그러한것들 말이다. 몇달전에 loop에서 list의 아이템을 제거하는 예제를 만든적이 있다이 글의 3번째 타이틀에서 보다 잘 알수 있어서 좋았다. Promise 내가 지금껏 본 Promise 글 중 가장 이해가 잘 되었다. 우린 Git-flow를 사용하고 있어요 현재 내가 개발중인 서비스에 Git Flow를 도입할 생각을 하고있어서 참고가 될 것 같다. Spring 웹 애플리케이션에서 사용하지 않는 API를 찾아보자 내가 개발중인 서비스에도 사용하지 않는 API가 많아서 정리의 필요성을 느끼고 있었다. 이 글이 큰 도움이 되었다. 몇 개월 내로 실행해 볼 생각이다. 총평몇주간 밀린것을 한꺼번에 쓰니 굉장히 열심히 공부한 것 같은데, 요 몇주간은 굉장히 루즈하게 공부했다.그래도 파이썬을 다시 공부하거나 비동기를 보다 깊게 공부하거나 새로운 몇가지 기술을 적용해보는 등 새로운 시도를 많이 한 주 였다.이번주엔 KCD(Korea Community Day) 2019 를 갈 예정이다.JS 및 DevOps에 대한 세션이 많아서 기대된다!","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"mybatis association","slug":"/java/2019/02/18/mybatis-association.html","date":"2019-02-17T15:00:00.000Z","updated":"2019-08-02T14:41:53.801Z","comments":true,"path":"2019/02/18//java/2019/02/18/mybatis-association.html/","link":"","permalink":"https://sehajyang.github.io/2019/02/18/java/2019/02/18/mybatis-association.html/","excerpt":"","text":"Lombok 사용Service 생략 File Shop.java ShopDetail.java ShopMapper.xml Shop.java 12345678@Datapublic class Shop &#123; private String shopno; private String id; private String pwd; private ShopDetail shopDetail; //변수명 앞문자 capital 주면 안됨(getter, setter 때문)&#125; ShopDetail.java 123456public class ShopDetail &#123; private String shopno; private String name; private String price; private String count;&#125; ShopMapper.xml 123456789101112131415161718&lt;!-- 중략 --&gt;&lt;mapper namespace=\"com.test.mapper.ShopMapper\"&gt; &lt;resultMap id=\"ShopMap\" type=\"com.test.domain.Shop\"&gt; &lt;result property=\"shopno\" column=\"shopno\" /&gt; &lt;result property=\"id\" column=\"id\" /&gt; &lt;result property=\"pwd\" column=\"pwd\" /&gt; &lt;association property=\"shopDetail\" javaType=\"com.test.domain.ShopDetail\"&gt; &lt;result property=\"shopno\" column=\"shopno\" /&gt; &lt;result property=\"name\" column=\"name\" /&gt; &lt;result property=\"price\" column=\"price\" /&gt; &lt;result property=\"count\" column=\"count\" /&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id = \"selectTestQuery\" resultMap = \"ShopMap\"&gt; select s.*, sd.* from shop s join shopdetail sd on s.shopno = sd.shopno &lt;/select&gt; Result1Shop[(shopno=1, id=aa, pwd=1234, shopDetail=shopDetail(shopno=1, name=김뭐뭐, price=1000, count=100))] association, result map collection 등으로 검색하면 더 자세히 알 수 있습니다.","categories":[{"name":"Java","slug":"Java","permalink":"https://sehajyang.github.io/categories/Java/"}],"tags":[{"name":"tip","slug":"tip","permalink":"https://sehajyang.github.io/tags/tip/"},{"name":"mybatis","slug":"mybatis","permalink":"https://sehajyang.github.io/tags/mybatis/"},{"name":"spring","slug":"spring","permalink":"https://sehajyang.github.io/tags/spring/"}]},{"title":"Springboot auto build 안되는 문제","slug":"2019-02-14-springboot_autobuild_problem","date":"2019-02-13T15:00:00.000Z","updated":"2019-07-15T14:11:55.581Z","comments":true,"path":"2019/02/14/2019-02-14-springboot_autobuild_problem/","link":"","permalink":"https://sehajyang.github.io/2019/02/14/2019-02-14-springboot_autobuild_problem/","excerpt":"","text":"최근 Eclipse에서 Intelli J로 갈아탔는데 java 파일 수정시 auto build가 되지 않는 문제가 발생했다. 실행 환경OS: win10IDE : Intelli J 2018.3 해결 방법 build.gradle에 의존성 추가 1compile(\"org.springframework.boot:spring-boot-devtools\") application.properties 사용할 경우 1spring.devtools.livereload.enabled=true Intelli J Settings &gt; Compiler 검색 &gt; Buld Project automatically 체크 왼쪽 shift 두번 누름 &gt; Registry 검색&gt; compiler.automake.allow.when.app.running 체크 Run SpringbootApplication (Gradle일 경우 bootRun인데 이거 아니고 SpringbootApplication으로 실행해야됨)","categories":[{"name":"Spring","slug":"Spring","permalink":"https://sehajyang.github.io/categories/Spring/"}],"tags":[{"name":"Springboot","slug":"Springboot","permalink":"https://sehajyang.github.io/tags/Springboot/"},{"name":"Build","slug":"Build","permalink":"https://sehajyang.github.io/tags/Build/"}]},{"title":"190128~190203 주간회고","slug":"2019-02-03-190128~190203","date":"2019-02-02T15:00:00.000Z","updated":"2019-07-15T14:11:55.579Z","comments":true,"path":"2019/02/03/2019-02-03-190128~190203/","link":"","permalink":"https://sehajyang.github.io/2019/02/03/2019-02-03-190128~190203/","excerpt":"","text":"요 몇주간 회사일로 바쁘거나, 스터디 자료 준비를 하느라 주간회고를 쓰지 못했었는데 이번 명절에 시간이 남아 작성할 수 있었다.변화가 많은 주 였다. Eclipse 에서 Intelli J 로 전환 electron + vue Python 다시 시작 자바스크립트 생태계 관련 학습 및 발표 비동기 공부 이번주 학습Eclipse 에서 Intelli J로 전환문제1. springboot로 java파일 수정시 auto build를 체크해뒀는데, auto build를 할 때 마다 거의 모든 JPA를 재등록 하는 것 같았다.가끔 그것때문에 웹서버가 업데이트 되지 않는다거나 락이 걸리는 등의 문제가 있었다.그럴때는 이클립스 프로그램을 다시 껐다 켜고(심지어 프로세스를 직접 지워야했다), project clean &gt; build 를 했는데 여간 불편한게 아니었다. 문제2. 무언가 입력하려고 할때 자주 버퍼링이 걸렸다. 내 노트북의 성능은 충분했고(i7-7700) 메모리또한 넉넉했다. 문제3. 이유없는 error reporting, 말 그대로 아무 이유 없이 아무런 작업을 하지않는데 error report를 띄우는 경우가 잦았다.그 밖에도 불편한점이 있었지만 크게 불편했던건 위와 같다. 그래서 Intelli J를 생각하고 있었는데 회사 동료의 도움으로 도입할 수 있게 되었다.전환 후 초반엔 셋팅 문제를 조금 겪긴 했지만 굉장히 만족중이다! 상기된 모든 문제가 사라졌고, 그 외의 불편한점은 아직 느끼지 못했다. Python 다시 시작과거에 알고리즘 풀이 이후로 놓았던(발만 담궜던) 파이썬에 대해 그간 별 생각이 없었는데, 최근에 주변인을 통해 좀더 알게되면서 파이썬으로 무언가 만들어봐야겠다고 생각했다.연휴때 spring reactor를 사용한 채팅 프로그램을 만들려 했는데, python으로 짜볼 예정이다. 자바스크립트 생태계 관련 학습 및 발표사내 스터디 이번주 발표자가 되어서 약 4일간 발표 준비를 했었다.자바스크립트의 특징과 역사 그리고 라이브러리, 프레임워크에 대한 내용을 다룸으로써 큰 그림을 보려는 목적이었다.개인적으로 아직 잘 몰라서 아쉬웠던 부분도 있었지만 전반적으로 즐겁게 준비했던 것 같다.특히 어디서 들어봤던 라이브러리 혹은 프레임워크에 대해 찾아보며 동작 원리나 특징을 알 수 있었고 산재되어있는 내용들을 모으며 흐름이 그려지기도 해서 준비하면서도 많은 공부가 됐었다.또한 2주전에 골머릴 앓던 자바스크립트의 Callback,Promise,Closer 그 기타등등을 이제 알 것 같아서 기쁘다! 다음에 발표를 한다면 노드의 비동기로 하고싶다.시간상 노드에 대한것을 넣을 수 없어서 아쉬웠다.발표자료는 sildeshare에서 볼 수 있다. 비동기 공부몇주 전 아파서 더 듣지못했던 비동기에 대한 걸 들을 수 있었다. 조금씩이나마 짜맞춰져가는 것 같아서 굉장히 즐거웠다.발표자분이 굉장히 잘 준비해주셔서 처음 듣는데도 무리 없이 잘 이해할 수 있었다.그 후 한번 정리하니 전체적인 그림이 그려지는 것 같았다.하지만 내가 제대로 이해한건지 확신을 할 수 없고, 아직 뿌연 느낌이라서 7가지 동시성 모델(자바로 쓰여져있다)을 볼 예정이다. 다음주 연휴 학습 예정 Python 비동기 (시간이 된다면)Virtual DOM 좀더 깊이! 총평배운게 많은 주 였다. 그간 많은 기술을 해보며 즐겁기도 했지만 왠지 모르게 정체되어있는 느낌을 받았었다.그래서 나름대로 조언을 구하기도 하고 이것저것 시도해보기도 했는데, 다행히 길을 찾은 것 같다.한동안 파이썬을 하다 electron + vue를 할 예정이다(backend는 파이썬으로 할 것이다)","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"190114~190120 주간회고","slug":"2019-01-20-190114~190120","date":"2019-01-19T15:00:00.000Z","updated":"2019-07-15T14:11:55.578Z","comments":true,"path":"2019/01/20/2019-01-20-190114~190120/","link":"","permalink":"https://sehajyang.github.io/2019/01/20/2019-01-20-190114~190120/","excerpt":"","text":"이번주는 수요일부터 주말인 일요일까지 고열+장염 크리로 개인공부를 단 하나도 하지 못했다.손 끝 하나 들 힘조차 없어 컴퓨터는 커녕 카톡도 간신히 했다.이번주에 배운건 건강을 잘 챙기자.. 정말 그간 쌓아오던 공부 계획이 속절없이 무너지는 걸 경험했다.깃허브의 잔디에 연연하지 않기로 했지만 일주일 내리 텅텅 비어버린 잔디를 보니 속이 쓰리다.. 이번 주 학습 러닝 자바스크립트 콜백, 프로미스, 스코프 학습 고열, 장염에 좋은 음식 등 다음주 학습 예정 러닝 자바스크립트 총평이번주는 너무 조급하게 초조해하며 공부하다 그대로 건강을 못 챙기고 엎어져버린 주 였다.그래서 앞으론 진도를 늦게 빼는 한이 있더라도 예전보단 조금 더 여유롭게 스트레스 받지 않으면서 공부해야겠다고 생각했다.그간 자바스크립트 + 스프링부트 강의 + 알고리즘 + 기타(최근엔 비동기) 공부를 하고있었는데 당분간 자바스크립트 하나만 가지고 여유롭게 공부할 생각이다.","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"181231~190113 2주간회고","slug":"2019-01-13-181231~190113","date":"2019-01-12T15:00:00.000Z","updated":"2019-07-15T14:11:55.578Z","comments":true,"path":"2019/01/13/2019-01-13-181231~190113/","link":"","permalink":"https://sehajyang.github.io/2019/01/13/2019-01-13-181231~190113/","excerpt":"","text":"요즘들어 어떤 개념을 습득한 건 기억이 나는데, 내가 어떤 것을 했는지가 기억이 잘 나지 않는다.예를들어 메소드 개념을 습득했다고 치자, 그 개념에 대해선 굉장히 기억을 잘 하고 있는데몇 시간전에 작업한게 뭐였는지 어제 작업한게 뭐였는지 그런게 기억이 잘 나지 않는 식이다.딱히 스트레스 받지도 않고 잘 쉬면서 학습 하고 일 하는 것 같은데 이상하다.아무래도 요즘 내 머릿속 RAM 휘발이 너무 잘 되는 것 같다.. 저번주의 주간회고가 밀렸으므로 2주치를 같이 작성하게 되었다. 저번주에 왜 밀렸었는지 기억이…대신 학습한 것에 대한 기억은 다행히도 잘 있어서 주간회고를 작성할 수 있다. 이번주 2주치 학습 러닝 자바스크립트 콜백, 프로미스, 스코프 학습 스프링 기반 REST API 개발 수강 후 기록 @MockMVC 나 hateoas, mokito 등 기존의 내가 알던(?) TDD와는 완전 다른 것을 새로운 것을 많이 배웠다. 사내 스터디의 비동기에 대한 세미나 다음주 학습 예정 러닝 자바스크립트 스프링 기반 REST API 개발 수강 마무리 사내 스터디의 비동기에 대한 세미나 2부 총평나는 종종 자바스크립트로 개발한다. 하지만 콜백, 프로미스, 스코프에 대해서 잘 모르고 있었다. 내가 개발할 때 쓸 일이 별로 없었기 때문이다..하지만 최근에 내가 그것들에 대해서 잘 모른다는걸 깨달았을 때 굉장히 창피하고 부끄러웠다.그래서 요즘 러닝 자바스크립트와 구글링을 통해 공부하고 있다.콜백과 프로미스에 대해서 좀더 공부하고 있는데, 마침 사내 개발 스터디 발표 주제가 비동기였다.발표자분이 비동기에 대해서 깊이있게 발표해주셔서 큰 가닥을 잡을 수 있었다! 각각의 개념(동시성, coroutine, Non-block 함수 등)은 알았는데 그 개념들을 연결하는게 안되고 있다.한번에 이해하기엔 어려운 개념인 것 같다. 다음주엔 내가 조금 더 잘 이해하고 있길.. 스프링 기반 REST API 개발 수강은 퇴근 후 약속이 있지 않으면 매일 한 강의씩 들었는데, 처음 써보는 라이브러리나 함수가 너무 많아서 나중엔 그냥 이해 못하고 따라치게 되었던 것 같다. 게다가 내가 띄엄띄엄 수강한 것도 한 몫 했다.그래서 다음주엔 띄엄띄엄 수강하지 말고 일단 한번 완강을 하고 모르는 것을 따로 복습하는 식으로 흐름을 끊지 않게 공부하려고 한다. git add -p 와 git commit -v 의 사용 이 글을 읽고 commit -v 하고 소스를 검토하는 습관을 들이게 됐다.그 덕분에 내가 실수로 커밋할뻔한 잘못된 코드를 커밋하지 않을 수 있었다. 종종 급하게 소스를 커밋하고 푸쉬해버리는데 정말 좋은 습관을 들일 수 있었다. 최근 콜백+프로미스와 노드 그리고 비동기 스터디가 더해지면서 머릿속을 비동기가 점령해버렸다.앞으로 몇주간은 그럴 것 같다. 그 몇주가 끝난 후 내가 비동기에 대해서 잘 이해하고 있었음 좋겠다..!","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"2018 연간회고","slug":"2018-12-31-2018-review","date":"2018-12-30T15:00:00.000Z","updated":"2019-07-15T14:11:55.577Z","comments":true,"path":"2018/12/31/2018-12-31-2018-review/","link":"","permalink":"https://sehajyang.github.io/2018/12/31/2018-12-31-2018-review/","excerpt":"","text":"2018년을 마무리하며, 아직은 부족한게 많고 부끄러워서 연간회고를 쓸까말까 고민을 많이 했다. 많이 부족하지만 연간회고를 해 보기로 했다. 2018년은 굉장히 도전적인 해 였다. 웹 개발 교육 및 공부 시작 개인 프로젝트 및 세미나 취업 으로 크게 나눌 수 있다! 1. 웹 개발 교육 및 공부 시작원래 보안쪽으로 공부를 하다가 우연히 웹 개발에 관심을 갖게 되어 관련 교육을 듣고 다양한 기술을 접하고 공부하고 프로젝트를 만들었었다. 그 과정에서 Joshua님의 블로그와 gwonsungjun님의 TIL과 블로그를 보며 방향을 잡을 수 있었다. 나는 주간회고를 남기기 시작했고, 꾸준히 기록하는 것에 대해서 배울 수 있었고 이건 나에게 큰 변화중 하나였다! 그 밖에 많은 기술을 공부했다. 2. 개인 프로젝트 및 세미나 기억에 남는 2018년에 배운 기술 Git, Github =&gt; 연초에 형상관리를 처음 접해봤었다. 처음엔 삽질도 사고도 많이 치고 conflict도 엄청났으며, 날린적도 한두번이 아니었지만그런 시행착오를 회사 가서 하지 않아서 정말 다행이라고 생각한다.. 깃허브 블로그 =&gt; jekyll를 이용해서 깃허브 블로그를 만들었었다.루비로 짜여있는데, 루비를 할 줄 몰라서 제대로 되어있지 않은 상태이다, 리뉴얼 할 것 투성이다.처음엔 나도 개발관련 포스팅을 하고 싶었지만 부족한점이 많아서 주간회고 기록용으로 쓰고있다. React =&gt; 올해의 가장 큰 벽이었던 것 같다. 2019년 초에 다시 도전할 생각이다 CI/CD =&gt; 리눅스에 배포 환경을 일일히 설치하고, 소스코드를 리눅스로 옮기고 라이브러리를 수동으로 넣고그렇게 선사시대같은 방법으로 배포를 하던 나에게 엄청난 충격이었다. 그 밖에도 Spring, Springboot, Nodejs, ReactNative, 챗봇 등 크고 작은 개인 혹은 팀 프로젝트들을 했었다. 힘들고 지루했던 프로젝트는 없었던 것 같다 가장 기억에 남았던 세미나 Open Infra Day Korea 2018 인프라에 관심이 없었는데 이 세미나를 계기로 굉장히 관심이 많아졌었다.아마 이 세미나를 가지 않았으면 지금까지도 크게 관심이 없었을 것 같다.가서 정말 다행이었다 Seoul js 백엔드 개발자인 내가 가도 될까..? 라고 생각했었고 가서도 나는 하나도 이해하지 못했지만..프론트엔드에 관심을 갖게 된 계기가 된 좋은 세미나였다! 이 세미나를 갔다오고나서 리액트와 타입스크립트를 공부했었다. 지금도 계속 공부하고 싶은 욕심이 있다.아마 이 세미나를 가지 않았다면 나는 그냥 백엔드 공부만 했을 것 이다.그런의미에서 오픈 인프라데이 컨퍼런스보다 나에겐 더 의미가 큰 세미나였다. 기회가 된다면 또 가고싶다. 3. 취업이전 회사를(실습) 잠깐 다녀 본 내 결론은 취업 전에 하고싶은 공부를 하자! 였다그래서 원없이 하고싶은 공부(React, Devops 등)를 실컷 하고 운 좋게 백엔드 포지션으로 좋은 회사에 취직했다내가 바라던 개발 환경이었고, 매주마다 사내 세미나같은 스터디를 해서 즐겁다회사에선 Springboot로 개발을 하고있다. 내가 많이 부족함을 느끼고 있다.. 총평원래 보안쪽으로 가려던 내가 웹 개발을 시작하게 되면서 굉장히 많은 정보와 기술을 알게 된, 변화가 많은 해 였다. Spring, Nodejs Reactjs MongoDB부터 Jenkins AWS Docker등 백엔드 DB 프론트엔드 인프라 등 단기간에 많은걸 접해보고 사용해보고 만들어본 해 였다. 힘든 순간도 있었고 슬럼프가 오기도 했지만 나름대로 이겨낸 것 같다. 아직 글쓰기도 그렇고 개발도 그렇고 부족한게 많지만 2019년도 꾸준히 하도록 노력해야겠고,2018년처럼 2019년도 이것저것 많이 해보고 좀더 꼼꼼하고 어느정도 능숙해 질 수 있는 한해가 됐으면 좋겠다!","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"1801217-1801223 주간회고","slug":"2018-12-23-181217~181223","date":"2018-12-22T15:00:00.000Z","updated":"2019-07-15T14:11:55.576Z","comments":true,"path":"2018/12/23/2018-12-23-181217~181223/","link":"","permalink":"https://sehajyang.github.io/2018/12/23/2018-12-23-181217~181223/","excerpt":"","text":"이번주엔 기존의 스프링 강의와 더불어 스프링 기반 REST API 개발강의 수강을 시작했다! 강의를 들으면서 기록하는게 쉽지 않아서 생각보다 기록에 많은 시간이 걸리고 있지만 나중에 도움이 될거라고 생각한다. 예전에 읽었던 HeadFirst DesignPatter 책을 예제를 따라가며 다시 보고있다. 그리고 자바스크립트 바이블 서적 같은 러닝 자바스크립트를 공부하며 기록을 시작했다. 아는부분은 건너뛰고 모르거나 애매했던 부분부터 보고있다. 이번주에 했던 학습 스프링 기반 REST API 개발 수강 후 기록 백기선의 스프링부트 수강 후 TIL에 기록 러닝 자바스크립트 공부 후 TIL에 기록 CodeWars 3문제 다음주 목표 스프링 기반 REST API 개발공부 및 기록 계속 백기선의 스프링부트보고 TIL에 정리하기 계속 러닝 자바스크립트 공부 후 TIL에 정리하기 계속 Design Pattern 책 읽으며 개인 프로젝트 진행 계속 간간히 CodeWars 문제 풀기 총평이번주는 이것저것 하고싶은 공부를 시작한 주 였다. 잘 하는 것 보단 중간에 포기하는 일 없이 끝까지 하는걸 중심으로 해야겠다. 목표치 만큼 하지 못해서 더디다고 생각하고 있지만 조금씩 꾸준히 한다는것에 의의를 두기로 했다!","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"두개의 리스트 아이템을 비교해 추가,삭제","slug":"2018-12-19-compare-items-in-two-arraylists","date":"2018-12-18T15:00:00.000Z","updated":"2019-08-02T14:41:53.799Z","comments":true,"path":"2018/12/19/2018-12-19-compare-items-in-two-arraylists/","link":"","permalink":"https://sehajyang.github.io/2018/12/19/2018-12-19-compare-items-in-two-arraylists/","excerpt":"","text":"최근 두개의 ArrayList의 아이템을 비교해, 추가되는 아이템과 삭제되는 아이템을 구분할 필요가 있어서 만들었습니다. 조건 list1 = [a, b, c, d] =&gt;새로 받아온 ArrayList list2 = [a, b, e] =&gt; 기존 DB 있던 데이터를 담은 ArrayList 기존 리스트에 영향을 주지 않으며, 새로운 리스트를 생성해 리턴해야 한다. 123456789101112131415161718192021ArrayList&lt;String&gt; resultList = compageAndDel(list1, list2);for (int i = 0; i &lt; resultList.size(); i++) &#123; System.out.println(\"Inst \" + resultList.get(i)); // c,d 출력 =&gt; DB에 없던, 새롭게 추가될 데이터&#125;ArrayList&lt;String&gt; resultList2 = compageAndDel(list2, list1);for (int i = 0; i &lt; resultList2.size(); i++) &#123; System.out.println(\"Del \" + resultList2.get(i)); // e 출력 =&gt; 기존 DB에 있었지만 삭제된 데이터&#125;private static ArrayList&lt;String&gt; compageAndDel(ArrayList&lt;String&gt; target, ArrayList&lt;String&gt; source) &#123; ArrayList&lt;String&gt; tmpArr = new ArrayList&lt;&gt;(); tmpArr.addAll(target); for (String item : source) &#123; if (target.contains(item) == true) &#123; //일치하는 아이템을 지움 tmpArr.remove(item); &#125; &#125; return tmpArr;&#125; 위의 코드로 새로 추가될 아이템과 DB에 있었지만 삭제될 아이템을 구분할 수 있습니다.만약 기존 리스트에 영향을 줘도 된다면 다음과 같이 작성합니다. 12345// list1기준 삭제된 요소 리턴 list1.removeAll(list2); //[c,d]// list1기준 추가된 요소 리턴list2.removeAll(list1); //[e] +2019.7.6 추가자바8 람다를 이용해 위 코드를 다음과 같이 리팩토링 해 봤습니다. 12345678910List&lt;String&gt; list1 = new ArrayList&lt;&gt;(Arrays.asList(\"a\", \"b\", \"c\", \"d\"));List&lt;String&gt; list2 = Arrays.asList(\"a\", \"b\", \"e\");System.out.println(list1.stream() .filter(x -&gt; !list2.contains(x)) .collect(Collectors.toList())); //[c, d]System.out.println(list2.stream() .filter(x -&gt; !list1.contains(x)) .collect(Collectors.toList())); //[e] 과거 코드와 비교해 소스가 깔끔하게 정리된 것을 알 수 있습니다. 스칼라로는 다음과 같이 작성할 수 있습니다.+scala 버전 val diff1 = list1.diff(list2) //Set(c, d) val diff2 = list2.diff(list1) //Set(e) // 공통 아이템만 리턴 var match1 = list1.intersect(list2) // Set(a, b) 읽어주셔서 감사합니다. 혹 오류/문의할 내용이 있다면 코멘트 남겨주세요!🙆","categories":[{"name":"Java","slug":"Java","permalink":"https://sehajyang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://sehajyang.github.io/tags/Java/"}]},{"title":"1801210-1801216 주간회고","slug":"2018-12-16-181210~181216","date":"2018-12-15T15:00:00.000Z","updated":"2019-07-15T14:11:55.575Z","comments":true,"path":"2018/12/16/2018-12-16-181210~181216/","link":"","permalink":"https://sehajyang.github.io/2018/12/16/2018-12-16-181210~181216/","excerpt":"","text":"이번주는 바빠서 틈틈히 스프링 관련 강의를 듣고 정리하거나 유용한 글을 읽고 정리를 해서 TIL에 올렸다. REST API에 대해서 대략 알지만 제대로 강의나 책을 보고 공부하기보단 인터넷으로 짧은 지식등을 보고 익혔었기 때문에 부족함을 많이 느껴서 스프링 기반 REST API 개발 신청을 했다! TDD로 진행한다고 되어있는데, 최근 사내에서 TDD에 대한 언급이 있어서 TDD를 익힘에 있어 많은 도움이 될 것 같다. 이번주에 읽은 글 카카오 헤어샵 개발과정 및 후기 비둘기로 설명하는 HTTPS(HTTPS explained with carrier pigeons) 웹 아키텍쳐 입문 이번주에 했던 학습 백기선의 스프링부트 수강 후 TIL에 기록 다음주 목표 백기선의 스프링부트 보고 TIL에 정리하기 계속! 스프링 기반 REST API 개발 총평목표치만큼 학습하지 못해서 아쉬운 주 였다. 연말이라서 그런 것 같은데 다음주에는 조금 더 목표를 달성 할 수 있었으면 좋겠다","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"1801203-1801209 주간회고","slug":"2018-12-09-181203~181209","date":"2018-12-08T15:00:00.000Z","updated":"2019-07-15T14:11:55.573Z","comments":true,"path":"2018/12/09/2018-12-09-181203~181209/","link":"","permalink":"https://sehajyang.github.io/2018/12/09/2018-12-09-181203~181209/","excerpt":"","text":"이번주는 많은 일이 겹쳐서 공부를 할 수가 없었다. 다음주 부터는 할 수 있을 것 같다. 그래서 출퇴근 몇가지 읽었던 글/포스팅을 정리하는 식으로 이번주의 주간회고를 하려고 한다. 기록해두지 않으니 전부 까먹어서 앞으로 좋았던 글 등을 깃허브 TIL/Review에 정리해두려고 한다! 이번주에 읽었던 글 대규모 서비스를 지탱하는 기술 좋은 코딩을 위한 13 가지 간단한 규칙 슈퍼마켓에서 우유를 사면서 웹 캐싱(Web Caching)을 알아봅시다 다음주 목표 백기선의 스프링부트 보고 TIL에 정리하기 러닝 자바스크립트 읽고 정리 슬프게도 이번주에 아무것도 못했기 때문에 저번주와 같다. 총평다음주 부턴 공부를 할 시간이 좀 생길 것 같다! 지금 하고있는 스프링부트나 자바스크립트를 완강 후 함수형 프로그래밍 이 강의를 들을 생각을 하고 있다. 국내에 함수형 프로그래밍에 대한 강의도 자료도 많지 않았었는데 이렇게 강의가 생겨서 너무 기쁘다.","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"2018-11 월간회고","slug":"2018-11-27-2018-11-월간회고","date":"2018-11-26T15:00:00.000Z","updated":"2019-07-15T14:11:55.572Z","comments":true,"path":"2018/11/27/2018-11-27-2018-11-월간회고/","link":"","permalink":"https://sehajyang.github.io/2018/11/27/2018-11-27-2018-11-월간회고/","excerpt":"","text":"어쩌다보니 월간 회고가 됐다. 저번달 이맘때즈음 결국 리액트 프로젝트에서 발생한 오류를 해결하지 못하면서 슬럼프가 강하게 왔었다. 책도 많이 찾아보고 stackOverFlow에 질문도 몇번 올렸지만 결국 해결하지 못해서 그대로 개발도 주간회고도 길게 쉬었다. 그래도 언젠간 그 리액트 문제를 해결해보고 싶다. 그 간 몇가지 회사에서 코딩테스트를 보기도 하고 과제를 받기도 했는데 그 중 인상깊었던 과제를 몇가지 적어볼까 한다. (지금은 좋은 회사에서 좋은 분 들과 함께 일하고있다 😊) 개인공부 과제리액트+다이나모 디비+서버리스 과제모 회사 2차 면접 과제로 받았던 과제였다. 기간은 일주일(이지만 5일) 이었고 멜론같은 뮤직 어플리케이션 웹앱을 만드는 과제였다. 리액트로 프론트, 백엔드는 서버리스(Lambda+API Gateway+S3(Cloud Front) 등등), 디비는 다이나모 디비를 사용하는 것 이었다. 서버리스는 ASUG 핸즈온랩 세미나 이후로 한 적이 없었기 때문에 그야말로 대 패닉이었다! 여차저차 서버리스는 구현했고 다이나모 디비는 몽고디비와 비슷해서 괜찮았는데 리액트가 문제였다. 결론적으로 서버리스보단 리액트를 못해서 실패했다 😢 서버리스는 ASUG 세미나덕에 생각보다 빠르게 구현할 수 있었다. 기회가 된다면 또 가고싶다! 크롤링 과제모 회사의 과제였는데 두가지 알고리즘 문제를 푼 후 4가지 구현 과제 중 하나를 선택하는 것이었다. 그 4개 중 3개는 GraphQL 과제였는데 하나도 모르는 관계로 그나마 들어본(?) 크롤링을 선택했었다. node로 cheerio 라는 모듈을 사용해서 구현했었는데, 정말 잘 만들어져 있는 모듈이라서 생각보다 쉽게 구현 할 수 있었다. 그 당시 구글에서 만든 puppeteer라는 것을 사용하려고 했는데 국내에 예제가 없어 포기했던 기억이 난다. 시간이 있다면 크롤링은 꼭 해보고 싶은 것 중 하나다. 그 외과제가 작게는 게시판을 만드는 것 부터 쇼핑몰 홈페이지를 만드는 것 까지 더 나아가 서버리스..를 사용하는 것 까지 다양했다. 대게 공통점은 AWS로 배포하라는 것 이었는데, 요즘은 정말 많은곳에서 AWS를 필요로 하고있다는 생각이 든다. 아직 난 출발선인 것 같다 그래도 과거엔 AWS가 뭔지도 몰랐는데 지금은 조금이지만 안다는 것에서 발전하고 있는 것 같아 위안이 된다. 다음주 목표 백기선의 스프링부트 보고 TIL에 정리하기 러닝 자바스크립트 읽고 정리 자바스크립트를 너무 못하기 때문에.. 이제는 다른거 하지 말고 자바스크립트에 집중을 해야겠다는 생각이 들었다. 총평리액트 프로젝트에서 발생한 오류를 일주일 이상 잡지 못하면서 그대로 슬럼프가 왔었다. 나는 고작 이런 오류를 해결을 못했는데 과연 개발자에 재능이 있는가? 적성에 맞는가? 라는 의문이 들었기 때문이었다. 그래서 한동안 개발하는게 좀 꺼려졌었는데, 그러던 차에 우연히 좋은 회사에 들어가게 됐다. 다시 마음을 잡고 개발을 할 수 있을것 같다! 슬럼프 기간 동안 좋은 세미나가 많았는데 신청해두고 가지않거나 지인에게 줬었다. 왜 그랬을까.. Dev Festa, Jet BrainDay.. 정말 아깝다. 다음엔 슬럼프가 와도 세미나는 가야겠다. 개발할 때 동료나 팀원이 있는건 정말 중요하다는 걸 리액트 프로젝트 오류로 절절히 느꼈다. 그 때 주변에 같이 리액트를 공부하던 사람이 있었다면슬럼프가 오지 않았을 거 같다고 생각한다 😢 이번주는 좀 바빠서 본격적으로 다음주부터 공부를 시작할 것 같다 :D","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"Java Interview Answer","slug":"2018-11-27-java-interview-answer","date":"2018-11-26T15:00:00.000Z","updated":"2019-08-06T14:31:35.584Z","comments":true,"path":"2018/11/27/2018-11-27-java-interview-answer/","link":"","permalink":"https://sehajyang.github.io/2018/11/27/2018-11-27-java-interview-answer/","excerpt":"","text":"KimJunJin님의 면접에 나왔던 질문의 답을 찾아서 정리 했습니다.Link 간결한 답을 위해 질문에 대한 답을 되도록 짧게 정리했습니다.이 문서는 종종 업데이트 됩니다 JAVA1. JVM 구조class(method area), stack, heap, native method, pc register로 이루어져있음 class : 값 임시저장, 상수 풀 , static변수 저장 stack: 메소드 안에서 사용되어지는 값 저장, 매개변수, 지역변수, 리턴 값 등 임시저장, 수행끝나면 프레임별로 삭제 heap : new로 생성된 객체와 배열 저장, gc를 통해 메모리 반환, 객체 주소값 저장 native method: 타 언어 메소드 저장 pc register: 쓰레드 생성시 생성되는 영역추가 2. GC 처리방법major, minor부분이 있다. 더이상 콜이 되지 않을 new로 만들어진 힙역에 할당된 아이템들을 수집해 삭제하는 작업을 한다.삭제된 객체의 메모리를 반환 Minor Garbage Collection 1. New 영역에서 일어나는 Garbage Collection ii) Eden영역에 객체가 가득 차게 되면 첫 번째 Garbage Collection 발생 iii) Survivor1 영역에 값 복사 iv) Survivor1 영역을 제외한 나머지 영역의 객체들을 삭제 v) Eden영역과 Survivor1영역의 메모리가 기준치 이상일 경우, Eden 영역에 생성된 객체와 Survivor1영역에 있는 객체 중 참조되고 있는 객체가 있는지 검사 vi) 참조되고 있는 객체를 Survivor2 영역에 복사 vii) Surviver2 영역을 제외한 영역의 객체들을 삭제 viii) 일정시간이상 참조되고 있는 객체들을 Old영역으로 이동 ix) 반복 Major Garbage Collection (Full Garbage Collection) i) Old영역에 있는 모든 객체들을 검사 ii) 참조되지 않은 객체들을 한꺼번에 삭제 iii) Minor Garbage Collection에 비해 시간이 오래 걸리고 실행 중 프로세스가 정지 출처 3. HashMap HashTable concurrentHashMap HashMap : 동기화 지원 안함 HashTable: 동기화 지원 함 concurrentHashMap : Java5 부터 지원하는 동기화 지원, HashTable보다 좋다고한다.참고 4. 접근제어자접근 영역을 제한할때 사용, 생략시 default로 셋팅 public : 제한 x default: 같은 패키지 protect: 상속이면 가능 private: 자신 클래스에서만 사용가능 5. interface, abstract의 차이 interface 다중 상속 가능, class body 있으면 안됨, 일종의 약속 abstract 단일 상속, class body 있어도 됨, 기능 재정의가 목적 6. StringBuilder, StringBuffer StringBuilder 동기화 미 지원, StringBuffer보다 빠르다. StringBuffer 동기화 지원 7. try with resourcesIO 예외시 자원을 자동으로 닫아준다.close()시 만약 예외가 발생할 경우 catch로 보내준다.참고 8. Synchronize동기화 하기 위함 Synchronize 방법 기본적으로는 Collections라는 util 클래스에서 제공되는 static 메소드를 통해 이를 해결할 수 있다.Collections.synchroziedList(), Collections.synchroziedSet(), Collections.synchroziedMap() 등이 존재한다.JDK 1.7 부터는 concurrent package를 통해 ConcurrentHashMap이라는 구현체를 제공한다.Collections util 을 사용하는 것보다 synchronized 키워드가 적용된 범위가 좁아서 보다 좋은 성능을 낼 수 있는 자료구조이다. 9. static은 메모리 어디에 올라가는가JVM의 class 영역 (method area)에 올라간다. 10. 컬렉션 프레임워크란DataStructure 를 직접 구현하지 않고 사용할 수 있는 것이며, 배열과는 다르게 객체를 보관하기 위한 공간을 미리 정하지 않아도 되므로상황에 따라 객체의 수를 동적으로 정할 수 있음으로서 프로그램의 공간적인 효율성 또한 높여준다. List List 인터페이스를 직접 @Override를 통해 사용자가 정의하여 사용할 수도 있으며, 대표적인 구현체로는 ArrayList가 존재하며, 이는 기존에 있었던 Vector를 개선한 것이다. 이외에도 LinkedList 등의 구현체가 존재한다.Map대표적인 구현체로는 HashMap이 존재한다.key-value 의 구조로 이루어져 있으며 Map 에 대한 구체적인 내용은 DataStructure 부분의 hashtable 과 일치한다.key 를 기준으로 중복된 값을 저장하지 않으며 순서를 보장하지 않는다.key 에 대해서 순서를 보장하기 위해서는 LinkedHashMap을 사용한다.Set대표적인 구현체로는 HashSet이 존재한다. value에 대해서 중복된 값을 저장하지 않는다.사실 Set 자료구조는 Map 의 key-value 구조에서 key 대신에 value 가 들어가 value 를 key 로 하는 자료구조일 뿐이다.마찬가지로 순서를 보장하지 않으며 순서를 보장해주기 위해서는 LinkedHashSet을 사용한다. 11. Stack 과 QueueStack 객체는 직접 new 키워드로 사용할 수 있으며,Queue 인터페이스는 JDK 1.5 부터 LinkedList 객체를 통해 new 키워드를 통해 사용할 수 있다.출처 12. 제네릭컴파일과정에서 타입체크, 객체의 타입안정성 높인다. collection에 특정객체만 추가될 수 있도록 한다. 13. Vector와 List 차이에 대해 설명하시오. Vector 연속적인 메모리, 미래에 들어갈 요소 위해 선할당 함, 메모리 재할당 가능 List 비연속적 메모리, 선할당 안함, 추가제거 잦을시 사용 14. Overloading Overriding 차이는? Overriding자식클래스에서 부모클래스 메소드를 재정의한다.super()를 쓰면 부모클래스 메소드를 사용한다.Overloading같은 이름이지만 매개변수의 종류 및 숫자가 다른 메소드같은 기능이지만 다른 인자를 수행하는 메소드 정의시 사용. 15. CheckedException과 UnCheckedException의 차이를 설명하시오. CheckedException 반드시 예외처리 해야함, 컴파일단계에서 에러남 ex) IOException, SQLException UnCheckedException 예외처리 강제안함, 실행단계에서 에러남 ex) NullPointer, ILLegarArgument, Out Of Bound Exception등등 16. OOP란 무엇인가?객체지향, 크게 3가지 특징이있다. 추상화, 캡슐화, 다형성 추상화 굳이 구현할 필요없는 부분을 생략하고 필요한 부분만을 나타내는 것. 다형성 하나의 메소드나 클래스가 다양한 방법으로 동작하게하는 요소 단순한 상속이나 인터페이스가 구현이 된 클래스 계층적으로 다단계 상속을 이루고 있는 클래스 여려개의 인터페이스를 한번에 구현한 클래스 등으로 표현된다. Overriding, Overloading 이 있다. 캡슐화(encapsulation) 메소드의 기능만 알며, 어떻게 동작하는지는 알필요 없이 사용하는 것 외부에서 변경 불가하게 private로 선언하고 setter getter 메소드를 통해서만 접근 가능하다. 무결성을 보장한다. 17. final / finally / finalize 의 차이를 설명하시오. final변경 불가능finally예외처리에서 무조건 실행하는것finalize()gc에 의해 호출되는 메소드, 이거 잘 못하면 OOME(Out of memory Exceprion) 발생하니까 건들지 말 것 final class : 상속x, final method : overriding x, final var : 상수 18. new String()과 “”의 차이에 대해 설명해주세요.new String()은 heap내의 spring pool에 객체 생성 뒤 그 객체의 주소를 가지게 되는 것“”는 문자열 자체를 저장 후 그 배열의 인덱스 번호를 가리킴추가 : 상수풀 19. 스프링 IOC가 무엇인가요? (보충)) IOC란 제어의 역전으로, 제어권을 스프링에게 위임하여 스프링이 만들어둔 객체를 주입한다스프링이 모든 의존성 객체를 스프링이 실행될 때 만들어두고 필요한곳에 주입시켜준다.그래서 bean 들은 싱글턴 패턴의 특징을 가진다.그렇게 제어의 흐름을 사용자가 컨트롤하는게 아니고 스프링에게 맡겨 작업을 처리한다.IOC를 구현하는 방법중 DI 가 있다. 내가 new로 객체만드는게 아니고 스프링이 필요할때 지가 알아서 만든다.출처 20. OOP와 AOP에 대한 차이를 설명해주세요.OOP : 모든 데이터를 오브젝트로 취급하여 프로그래밍 하는 방법,독립적으로 사용하거나 부품으로 사용하므로 재사용성 및 결합 가능특징 1) 캡슐화 (Encapsulation) 사용하고자하는 자료,로직,동작을 하나의 단위(함수)로 묶는 것이다.2) 은닉화 (Data Hiding) 외부에 필요한 정보만 공개하고 나머지의 정보는 숨긴다.3) 다형성 (Polymorphism) 호출하는 객체에 따라 다른 동작을 하는 기능이다. (가상함수 재정의)4) 상속성 (Inheritance) 이미 만들어진 클래스를 파생시켜 새로운 클래스를 만들수 있는 기법이다.5) 재사용성 (Reusability) 기존에 만들어진 객체를 다른 프로젝트나 필요한 부분에 그대로 가져다 재사용하는 것이다.출처: http://godkyu.tistory.com/11 AOP : 관점지향, 코드 밖에서 설정 된다, ex)logger 21. POJO가 무엇인가요?setter, getter로 이루어진 Java bean 별도의 API가 필요하지 않은 일반적인 자바코드를 이용해서 개발 가능하다. 22. Annotation이란?주석처럼 코드에 단다. 그러나 클래스에 의미를 부여하거나 기능을 주입 할 수 있다.build-in annotation, meta annotation, custom annotation이 있다. JS 클로저에 대해 설명해주세요. Closure(클로저)는 두 개의 함수로 만들어진 환경 으로 이루어진 특별한 객체의 한 종류 함수 내부에 작성된 함수 사이드 이펙트(무언가를 행할때 발생) 제어하기, private 변수 생성하기 목적으로 사용 참고링크 변수스코프체인에 대해 아시나요? 스코프란 유효범위, 전역과 지역이 있다. 참고링크 전역변수를 함수 내부에서 사용하면 성능상 이슈가 발생하는데 그 이유와 해결책에 대해 설명해주세요. 지역변수에 먼저 접근 후 없으면 전역변수에 접근하기때문에 지역변수보다 느리다. 또한 가비지 컬렉터가 제대로 스윕을 못해서 메모리 누수가 발생할 수 있다. 해결책 : 지역변수를 쓴다. 자바스크립트에서 클래스는 어떻게 사용하나요? function을 class로서 사용한다. 리터럴방식, 함수방식, 프로토타입 방식이 있다. 클래스 인스턴스를 생성해야만 클래스에 들어있는 함수들의 내부기능을 사용할 수 있다. 호이스팅이란? 변수 선언문을 끌어올린다 라는 뜻 함수 선언문 방식만 호이스팅 가능 자바스크립트 OOP Network 데드락에 대해서 설명하시오. 데드락 4대요소에 대해 설명하시오. 상호배제(Mutual exclusion) : 프로세스들이 필요로 하는 자원에 대해 배타적인 통제권을 요구한다. 점유대기(Hold and wait) : 프로세스가 할당된 자원을 가진 상태에서 다른 자원을 기다린다. 비선점(No preemption) : 프로세스가 어떤 자원의 사용을 끝낼 때까지 그 자원을 뺏을 수 없다. 순환대기(Circular wait) : 각 프로세스는 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다. 출처링크 멀티 스레드 환경에서의 주의사항을 설명해주세요. 공유 자원 관리 동기화 작업 필요 그러나 데드락 주의 사용자 수준 스레드와 커널 수준 스레드의 차이를 설명해주세요. DB 디비 풀은 왜 쓰나요? 빠른 할당을 위해 커넥션풀 : DB와 연결된 커넥션을 미리 만들어서 풀(pool)속에 저장해두고있다가 필요할 때 쓰는 것 디비 실시간 통신과 디비풀 이용시의 차이가 무엇인가요? 실시간 통신은 요청을 할 때마다 매번 드라이버 로드하고 커넥션 객체 생성 후 연결 종료한다 커넥션풀은 동시접속자 수가 가질 수 있는 커넥션을 하나로 모아두고 관리한다. 커넥션 생성하고 닫는 시간이 소모되지 않기 때문에 어플리케이션 속도 빨라지며, 한번에 생성될 수 있는 커넥션 수를 제어하기 때문에 동시 접속자 수가 몰려도 쉽게 웹이 다운되지 않는다. 풀 이상으로 접속자가 많아지면 해당 클라는 대기가 되고 대기하고 있는 순서대로 커넥션이 제공된다. SQL에서 left join에 대해 설명하시오. RDBMS와 NoSQL의 차이는? RDBMS : 유연한 쿼리 가능하지만 쿼리비용 높으며 트래픽 많은 상황에선 확장성 떨어진다. NoSQL : 최초 테이블 생성시 데이터간의 관계를 정의하지 않는다. 대용량 가능, 분산형 구조, 데이터를 저장만 하므로 key, value 만 있고 put, get 만 지원한다. index에 대한 설명과 장/단점으로 무엇이 있나요. index란 : RDBMS에서 검색속도를 높이기 위해 사용하는 기술, 일종의 색인 장단점 : https://lalwr.blogspot.com/2016/02/db-index.html (보충) 몽고DB의 특성에 대해 설명해주세요. SQL Injection은 무엇인가요? ACID에 대해 설명해주세요. (Atomic, Consistency, Isolation, Durability) 1차 정규화, 2차 정규화, 3차 정규화, BCNF에 대해 설명해주세요. 정규화 : 논리적 데이터베이스 설계에 있어서 테이블들을 구조화하는 기법 중 하나 자료의 손실이나 불필요한 정보의 도입 없이 데이터의 일관성 및 데이터 중복을 최소화하고 최대의 데이터 안정성 확보를 위한 안정적 자료구조로 변환하기 위해서 하나의 테이블을 둘 이상으로 분리하는 작업 제1정규형(1NF) : 테이블의 각 셀의 값은 단일값을 가진다. 제2정규형(2NF) : 주키가 합성키며 부분종속이 존재할 경우 2차 정규형의 대상이 된다. 제3정규형(3NF) : 비주키 속성 간에 발생하는 함수적 종속(이전종속)이 발생하면 3차 정규형의 대상이 된다. 출처 DB Nomalization(정규화)의 목적은? 저장 공간 최소화 데이터 무결성 유지 자료구조의 안정성 최대화 ETC url에 www.naver.com을 입력했다. 일어나는 현상에 대해 아는대로 설명하라. 브라우저에서 주소창에 url 입력시 어떤일이 일어나는가 브라우저의 주소창에 url 입력 브라우저 캐시에서 DNS 레코드를 확인하여 IP주소를 찾음 (없다면 DNS resolver를 통해 IP주소를 알아냄) 브라우저가 서버와 TCP 연결을 시작함 브라우저가 웹 서버에 HTTP 요청을 보냄 서버가 요청을 처리하고 응담을 되돌려보냄 브라우저는 서버가 보낸 HTML 내용을 표시 출처 Serialize와 json의 상관관계에 대해 설명하시오. 직렬화(Serialize) 자바 시스템 내부에서 사용되는 Object 또는 Data를 외부의 자바 시스템에서도 사용할 수 있도록 byte 형태로 데이터를 변환하는 기술. JVM(Java Virtual Machine 이하 JVM)의 메모리에 상주(힙 또는 스택)되어 있는 객체 데이터를 바이트 형태로 변환하는 기술 스레드풀에 대해 설명. 왜 쓰는지. 무엇인지. 스레드를 사용할 때 마다 하나씩 만들기보다 미리 먼저 많이 만들어두는 것 프로그램 성능저하 방지 및 다수의 사용자 요청 처리를 위해 사용 추가 Serialize로 데이터를 통신할 때 문제점에 대해 설명하시오. call by value와 call by reference의 차이에 대해 설명하시오. 개방폐쇄 원칙에 대해 구체적으로 설명해보시오. 해시함수 sha-1에 대해 설명하시오. DI (Dependency Injection)에 대해 설명하시오. 객체간의 의존관계를 개발자가 설정하는게 아니고 스프링컨테이너가 주입시켜준다. (의존관계란 Animal()은 Cat()에 의존한다 뭐 그런것) B가 바뀌면 A도 바뀌는걸 의존관계라고 한다. DAO DTO에 대해 설명하시오. MVC 패턴에 대해 설명하시오. 디자인 패턴 중 Factory패턴과 Templete패턴에 대해 구체적 예를 들어 설명하시오. 프레임워크와 라이브러리의 차이는 무엇인가요? 프레임워크 : 뼈대, 틀, 내가 맞추는 것 라이브러리 : 도구, 내가 사용하는것 자바와 자바스크립트 차이를 설명해주세요. 깊은 카피와 얕은 카피에 대해 설명해주세요. 컴파일러와 인터프리터의 차이는 무엇인가요? HashTable의 충돌 해결 방법을 설명해주세요. 대칭키/비대칭키 암호화 차이 대칭키 : 암복호화 해제 키가 같다 비대칭키 : 암복호화 해제 키 다름 분산락이란 무엇인가요? Etc2 Typescript 특징 MS 에서 만든 javascript로 컴파일되는 언어, 클래스, 모듈 및 인터페이스를 제공한다. 대규모 응용 프로그램 적용이 가능하다. React Redux란? 어플리케이션 클라이언트 쪽 state를 관리하기위한 거대한 이벤트 루프 액션 = 이벤트, 리듀서 = 이벤트에 대한 반응 출처를 적었지만 혹시 문제가 될 경우 삭제하겠습니다🙇","categories":[{"name":"Java","slug":"Java","permalink":"https://sehajyang.github.io/categories/Java/"}],"tags":[{"name":"studylog","slug":"studylog","permalink":"https://sehajyang.github.io/tags/studylog/"},{"name":"daily","slug":"daily","permalink":"https://sehajyang.github.io/tags/daily/"}]},{"title":"181015-181021 주간회고","slug":"2018-10-21-181015~181021","date":"2018-10-20T15:00:00.000Z","updated":"2019-07-15T14:11:55.571Z","comments":true,"path":"2018/10/21/2018-10-21-181015~181021/","link":"","permalink":"https://sehajyang.github.io/2018/10/21/2018-10-21-181015~181021/","excerpt":"","text":"이번주는 리액트+노드 개인 토이 프로젝트를 했고, 일일 1알고리즘을 했다. 리액트를 다루는 기술이란 책을 참고하면서 했는데 책 예제를 할땐 할 만 하다고 생각했지만 막상 프로젝트를 만들고 기능을 추가하려다 보니 굉장히 어려웠다. 개인적으로 스프링보다 훨씬 어려웠다ㅜㅜ 게다가 NoSQL인 MongoDB 를 사용해서 프로젝트를 해보긴 처음이라 헤매기도 했다. 개인공부-지인과 일일 1 알고리즘 풀기를 시작했다. 나름 거의 빼먹지 않고 성실하게 커밋하고 있어서 뿌듯하다. 초반이라 쉬운 패턴 찾기 문제+ 자료구조 기본 문제를 풀었다. 프로젝트에 올인하느라 좀 소흘해져서 다음날 넘어가기 직전에 커밋한적이 많았는데 내일부턴 좀 더 시간을 할애해야겠다. -리액트는 정말 어려운 것 같다. 재미는 있는데 어렵다. 프론트 작업을 거의 다 끝냈다. 다 좋은데 어떤 값을 백엔드로 넘겨줘야되는데 뭘 잘못한건지 모르겠지만 값을 못 넘겨주고 있어서 하루째 골머리를 앓고있다. 이번 프로젝트에서 마주친 거의 첫 문제라고 할 수 있겠다. 생각했던 모든 기능을 구현하는데에 일주일정도 걸릴것으로 생각했는데 이 부분에서 문제가 생길줄은 몰랐기 때문에 완성까진 더 걸릴 것 같다. 일단 다시 책이나 강의를 보면서 이해를 하고 해결해봐야겠다. 모르는게 많아서 단시간에 해결되진 않을 것 같다. -노드로 짠 백엔드 단은 문제가 없다. 몽고디비를 처음 써봐서 쿼리짜는데에 에러사항이 있었지만 다행히 금방 해결할 수 있었다. 쿼리를 짜주는 사이트도 있었다 RDBMS 쿼리를 입력하면 몽고디비 쿼리로 바꿔주는 사이트인데 앞으로 요긴하게 쓸 것 같다. 프론트부분의 문제가 해결되면 기능을 더 늘릴 예정이다. 다음주 목표 프론트 문제 해결하기 일일 1 알고리즘 빼먹지않기 노드 프로젝트 뼈대 잡기 총평오랜만에 하루종일 코딩할 수 있었다. 그리고 리액트는 정말 어려웠다. 개인적으론 스프링보다 훨씬 어렵다. 문제가 발생한 원인을 꼬박 생각해봤는데 어떻게 해야할지 아직 잘 모르겠다. 이렇게까지 막힌적은 처음인 것 같다. 흐름을 좀 그려보면서 정리해봐야겠다. 노드도 모르는 것 투성이고 새삼 스프링이 참 무언가를 빠르게 만들기 쉬웠구나 하고 생각하게된다. 그래도 스프링보다 재미있는 것 같다.","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"181001-181007 주간회고","slug":"2018-10-07-181001~181007","date":"2018-10-06T15:00:00.000Z","updated":"2019-07-15T14:11:55.571Z","comments":true,"path":"2018/10/07/2018-10-07-181001~181007/","link":"","permalink":"https://sehajyang.github.io/2018/10/07/2018-10-07-181001~181007/","excerpt":"","text":"이번주엔 노드공부와 리액트를 했고 Dev Django 세미나에 갔다왔다! 지인과 알고리즘 스터디를 시작했다 요즘 별로 한 것도 없는거 같은데 슬럼프가 온 것 같다ㅜㅜ 개인공부-Dev Django Korea 2018 세미나에 갔다왔다. 나는 Spring과 Node를 하기때문에 장고에 대해선 잘 몰랐지만 구직사이트를 보면 종종 사용하는 기술에 장고가 있던것이 기억나기도 하고 궁금해서 갔다왔다 한번 시험삼아 장고걸스의 장고 get started를 보며 따라해 본 적이 있었는데 중간에 오류가 나기도 하고 당시에 바빴어서 금방 그만둔 기억이 났다. 아무것도 모르는 상태로 갔는데 초보자가 들을 수 있는 세션도 있었다. 장고의 장단점에 대해서도 알 수 있었다. 장점 : 데이터 분석이 용이(python), 빠른 개발가능, 복잡하고 무결성이 보장되어야하는 트랜잭션이 있을때 사용하면 좋다 단점 : 구조 복잡, 학습이 어려움(한국어로 된 자료가 별로 없음), 커스텀 힘듬 특히 단점은 학습이 어렵다는게 와 닿았다. 에러가 나도 자료가 많지 않았고 시작하려고 해도 한국어로 된 강의나 책 등이 적었던 기억이 났다. -혼자 하는 것 보다 의무감을 가질 수 있을 것 같아서 지인과 일일 1 알고리즘 풀기를 시작했다. 자바 버전과 파이썬 버전으로 풀고있는데 파이썬 버전을 미루고 있다.. 그래도 쌓여가는 알고리즘 푼걸 보니 뿌듯하다. 이렇게 3년하면 알고리즘 고수가 될수 있겠지…? -리액트는 하면 할 수록 어려워서 만들던걸 중단하고 모르는거 하나하나 찾아보고 있다ㅜㅜ 다음주 목표 리액트 공부 일일 1 알고리즘 빼먹지않기 노드 프로젝트 뼈대 잡기 총평슬럼프가 좀 길어지고 있는 것 같은데 최근에 슬럼프가 끝날 기미가 보이는 것 같다. 알고리즘 어떤 한문제를 못풀어서 하루를 꼬박 보낸 일이 있었는데 역시 알고리즘은 아직 갈길이 굉장히 먼 것 같다. 중간에 좀 느려도 멈춰도 포기하지 말자는 생각으로 해야겠다.","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"180917-180923 주간회고","slug":"2018-09-23-180917~180923","date":"2018-09-22T15:00:00.000Z","updated":"2019-07-15T14:11:55.569Z","comments":true,"path":"2018/09/23/2018-09-23-180917~180923/","link":"","permalink":"https://sehajyang.github.io/2018/09/23/2018-09-23-180917~180923/","excerpt":"","text":"이번주엔 스프링부트 세미나와 서버리스 핸즈온 랩 세미나를 갔다왔다. 그 외에도 진행중인 노드 프로젝트의 CI를 급하게 구축하거나 알고리즘 공부를 하는 등 꽤 바쁜 한주였다. 개인공부스프링부트 세미나)를 갔다왔다! T Academy 에서 한거였는데, 경쟁률이 쌘 것 같아 떨어질까 조마조마 했지만 다행히 붙어서 잘 갔다왔다. 그곳에서 실습한 내용은 혼자 공부한 내용과 많이 비슷했지만 개인 질문시간에 궁금했던 것을 전부 물어볼 수 있어서 굉장히 유익했다. 스프링부트에 관한 내용이 아직 인터넷에 많진 않기 때문에 궁금한 부분이 꽤 많았는데 직접 굉장한 분께 들을 수 있어서 좋았다. 그 분이 RESTful API도 잘하셔서 RESTful에 대해서 궁금했던 것도 물어 볼 수 있었다. 스프링 부트 개념과 활용 강좌를 아직 다 보지 못했는데 봐야겠다.스프링 부트에 대해서 좀 더 잘 알고싶다. 근데 이거 말고도 할게많네.. -서버리스 세미나 를 갔다왔다! ASUG에서 한 거였는데, 노드도 조금 AWS도 조금 해봐서 따라가는데엔 무리가 없었지만 초보자 대상은 아니었던 것 같다. 그래도 직접 실습해보고 구축해본다는게 즐거웠다. 그렇게 서버리스에 뭔지에 대해서 조금 알 수 있게 되어서 너무 좋았다. 세미나를 들으며 몇개월 전 수동으로 하나하나 빌드 배포하고 서버돌렸던게 생각났다. 서버리스는 굉장한데 어렵긴했다. 그래도 잘 하면(?) 사용할 수 있을 것 같(은기분이 든)다. -알고리즘 문제를 풀 일이 있었는데. 나는 정말 아직 엄청 멀었구나 싶다ㅠㅠ 그런 전산적인 뇌가 되려면 어떻게 해야하는걸까…. 일단 하고있는 알고리즘 책 마저 끝내고 다시 백준 문제 풀면서 알고리즘 문제해결전략을 봐야겠다.. -추석이 끼면서 프로젝트 오프가 애매해졌다. 일단 노드부터 해야겠다! 익숙치 않은 기술을 잔뜩 쓰기 때문에 공부할게 엄청 많다. CI 구축에 문제가 있어 일단 이슈로 올려뒀다. 이것도 저것도 다 하려면 어떻게 해야하는걸까 아직은 선택과 집중을 잘 모르겠다. 다음주 목표 알고리즘 스터디 프로젝트 개발 및 공부 (Node.js) 총평요즘들어 회의가 든다. 전산능력(?)이 탄탄하면 웹 개발에 던져놓아도 금새 고수가 된다고 한다. 하지만 할 줄 아는게 많아도 그런 기본기가 없으면별 의미가 없다고 한다. 그래서 요즘 기업에선 알고리즘 테스트를 하나보다. 새로운 기술같은거 하지 말고 아키텍쳐나, 알고리즘, 네트워크 등에 집중해야 되나 라는 생각이 든다. 나는 웹 만드는게 재밌는데 그게 아무나 할 수 있는거고 내가 전산 베이스가 탄탄하게 안되어있으면 실력에 한계가 온다는게,그래서 요즘 내가 새로운 많은 기술을 배우는게 과연 잘하는 것 인가 하는 의문에 빠졌다. 최근에 자신있던 스프링 구조도 설명을 못한 일이 있었다. 내가 알고있던게 틀리면 어떡하지 싶어서 말을 못했는데, 그런걸 자신있게 말할 수 있는 사람이 되고싶다.","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"180910-180916 주간회고","slug":"2018-09-16-180910~180916","date":"2018-09-15T15:00:00.000Z","updated":"2019-07-15T14:11:55.568Z","comments":true,"path":"2018/09/16/2018-09-16-180910~180916/","link":"","permalink":"https://sehajyang.github.io/2018/09/16/2018-09-16-180910~180916/","excerpt":"","text":"이번주는 기초 공부를 하게 된 주 였다. 그 과정에서 내가 얼마나 먼지같은 존재인지 다시금 느낄 수 있었다.. 더불어 오래간만에 프로젝트를 시작하게 되었다. 개인공부자바, 디자인패턴, 자바스크립트, 알고리즘, DB 등 많은 내가 그간 배웠던 지식에 대해 다시 복습 할 수 있었다. 아키텍쳐는 볼때마다 새롭고 어렵다. 아직 잘하는 개발자가 되려면 멀은 것 같다. 그래도 예전에 비해선 발전 한 것 같아서 다행이다. -배울때 그렇게 배웠기 때문에 한번도 생각해보지 않고 그냥 쓰던 것에 대해 그걸 왜 그렇게 쓰냐는 질문을 봤다. 약간 충격을 받았다. 컴퓨터 공부는 늘 이제 좀 알겠다 싶으면 그건 사실 먼지만한 지식이었고 실제로 배워야할 건 어마어마한 것임을 깨닫게된다. 신 기술을 배우기에만 급급했던 건 아닐까 반성을 하게된다. -지인들과 새로운 토이프로젝트를 하게 되었다 신난다! 내가 개인적으로 만들면 늘 규모가 아쉬웠는데 이것도 해보고 저것도 해보고 할 수 있어서 즐겁다 무엇보다 같이 하면 의무감이 생기고 지치지 않는 것 같아서 좋다. -JetBrains Day 2018 신청을 했다. 요즘 코틀린이 핫하다. 카카오 개발자 컨퍼런스에서 카카오택시 서버사이드를 코틀린으로 바꿨다는 세션이 있었다고한다. 코틀린이 어떤건지 궁금해서 신청했다. 다음주엔 스프링부트 세미나가 있다. 신청은 했는데 신청자가 몰릴거같은 주제라 될지 안될지 모르겠다.. 2018 F/W 초보자를 위한 AWS 뿌시기 를 간다! AWS는 독학했기 때문에 초보자 수준이고 모르는 것도 많아서 AWS meetup을 가는게 좋을 것 같아서 신청했다. 다음주엔 쿠버네티스 차근차근 다지기 도 있는데 이건 시간이 없어서 신청을 못했다 진짜.. 너무 가고싶었는데 슬프다. 왜 늘 바쁜시기에 꼭 가고싶은 세미나가 있는걸까..? 다행히 세미나 라이브 방송을 해서 집에서 들을 수 있을거같다. 다음주 목표 기초 정리 알고리즘 스터디 정해진 분량 하기 (Python, Java) 프로젝트 개발 환경 및 협업 베이스 구축 Node.js 공부 총평기초 공부도 갈 길이 멀다는 생각을 했다. 나는 이런것도 모르고 개발한다고 했나 싶은 것도 많았다 굉장히 부끄러웠다. 대규모 웹 서비스를 해보고 싶어서 관련 자료를 이것저것 찾아보고 있다. 언젠간 대규모 웹 서비스를 개발해 안정적으로 서비스하는 슈퍼 개발자가 될 수 있겠지..? 최근들어 깨달았는데 개발공부를 할때 처음부터 기술 하나 차곡차곡 쌓고 마스터! 그건 좀 이상적인 것 같다. 개인적으로 개발공부는 거대한 퍼즐조각이라고 생각한다. 이 그림 저 그림 다 섞여있는 퍼즐조각 이라서 한개만 마스터 할 순 없고(골라내기엔 너무 방대한 조각이다) 손에 집히는 대로 이거 맞추다 저거 맞추다 하다보면 어느새 하나 둘 씩 완성되는 그런게 아닐까 생각한다..","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"180903-180909 주간회고","slug":"2018-09-09-180903~180909","date":"2018-09-08T15:00:00.000Z","updated":"2019-07-15T14:11:55.567Z","comments":true,"path":"2018/09/09/2018-09-09-180903~180909/","link":"","permalink":"https://sehajyang.github.io/2018/09/09/2018-09-09-180903~180909/","excerpt":"","text":"이번주는 파이썬 공부에 집중한 주 였다. 장고를 하며 파이썬을 배울 생각이었지만, 장고를 조금 해보니 그냥 파이썬을 먼저 하는게 좋을 것 같다. 그래서 거의 파이썬만 주구장창 했다. 개인공부파이썬은 꽤 오래전 부터 공부하려 했었는데, 어쩌다보니 미루고 미루다 이제 시작하게 되었다. 카카오 코딩테스트 해설에서 가장 짧은 라인수를 자랑하는 언어라고 하는걸 본 적이 있다. 그땐 그렇구나 역시 인기많은 이유가 있구나 하고 넘어갔는데, 배워보니 왜 그런지 알 것 같다. 더불어 왜 배우기 쉬운 언어라는지도 어렷품히 알 것 같다. 배우면 배울수록 앞으로 알고리즘 문제는 파이썬으로 풀어야겠다는 생각이 강해진다. -Django 공부를 겁도없이 시작했다.. 아직은 아무것도 모르겠다ㅜㅜ 문법도 모르겠고 아무것도 모르겠고.. 일단 엎고 파이썬부터 하고있다.. -운영체제 공부는 그냥 대학다닐때 강의 듣는 느낌이다. 까먹어가던거 다시 복습하는 느낌이다.. 다음주 목표 파이썬 지금 보고있는 책 끝내기 알고리즘 문제 파이썬으로 깔짝거리기 운영체제 강의 나머지 수강 Django 공부시작 총평이번주는 좀 나태했던 것 같은데, 연이은 개인 프로젝트 탓으로 치부하기엔 너무 놀았던 것 같다.. 반성.. 새로운거 배울 땐 질질 끌면 안되는데 왜 파이썬만 하려고 하면 질질 끌게 되는지 알 수 없다. 자바랑은 비슷하면서도 다른점이 굉장히 많아서 배울땐 신기하게 적용할땐 쉽게 해보고있다. 몇개월 전에 만들으려다 미뤄뒀던게 있었는데 이번에 파이썬으로 두세줄만으로 만들 수 있었다 그게 굉장히 기억에 남는다. 노력을 하지만 눈에 보이지 않으면 불안해지는데 이렇게 가끔가다 발전을 확인하게 되면 다행인 것 같다. 배우는 만큼 만들 수 있는 범위가 넓어지는 것 같아 기쁘다. 다다음주엔 스프링부트 세미나가 있는데 됐으면 좋겠다. 저번에 날림으로 프로젝트 만드느라 삽질했던게 한두개가 아니라서 가서 배울 수 있으면 좋겠다… 최근들어 핫한 4차 산업혁명 기술들을 배워야 하는 생각이 든다. 내 주변에선 점점 머신러닝, 빅데이터등을 배우고 있다. 나는 아직 웹도 배워야할게 산더미인데 초보 개발자가 그러한 어려운 기술을 배워야 하는건가 하는 생각이 든다. 그래도 구인공고에서 종종 눈에 띄고 점점 모집하는 곳도 늘어나는 것 같고, 세미나도 늘 4차 산업혁명 관련 기술이고 정말 핫한건 맞는데 안 배우며 버티고 있는건 내 아집인가 싶기도 하다. 누가 초보 개발자는 4차 산업혁명 기술 안해도 된다고 해줬으면 좋겠다.. 그도 그럴게 웹 공부도 할게 너무 많고 아직도 모르겠다 엉엉..","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"180827-180902 주간회고","slug":"2018-09-02-180827~180902","date":"2018-09-01T15:00:00.000Z","updated":"2019-07-15T14:11:55.566Z","comments":true,"path":"2018/09/02/2018-09-02-180827~180902/","link":"","permalink":"https://sehajyang.github.io/2018/09/02/2018-09-02-180827~180902/","excerpt":"","text":"이번주는 어쩌다보니(?) 여러 기술들을 많이 써보고 프로젝트도 해보는 주 였다. 당초 계획은 알고리즘과 컴퓨터 구조(운영체제 등) 공부에 집중하자! 였지만 어쩌다 보니 노드 웹 크롤링과 스프링부트 프로젝트를 하게 되었다. 생소하고 어려워서 삽질도 많이 했지만, 하다보니 하나씩 되는게 즐거웠던 것 같다. 하지만 결과물은 처참했기 때문에 아직 멀은 것 같다. 개인공부이번주는 알고리즘 문제와 웹 크롤러, 스프링부트 프로젝트를 했다. 이번 기회로 스프링과 스프링부트의 차이점을 알게되었고, 왜 많은 사람들이 스프링 부트를 찬양하는지도 알게되었다. 스프링보다 설정잡을게 적고 에러도 적게 나고 편리한 어노테이션도 있어서 굉장히 스프링 할때보다 스트레스 덜 받으며 재밌게 만들었다. 웹 크롤링은 처음 해 봤는데 간단한 홈페이지 하나 만들 수 있을 것 같아서 생각 해 두고 있다. 이번에 만든건 굉장히 초보자의 크롤러였지만, 하다보면 늘지 않을까.. 학교 다닐때 C 언어 포인터가 굉장히 어려웠었고 다 까먹었기 때문에 주말에 남궁성님의 C 언어 세미나를 갔다왔다. 확실히 옛날보단 이해가 됐지만 아직 어려워서 조금 더 공부해봐야겠다. -RESTFul 방식으로 스프링부트 웹을 만들었는데, RESTFul에 대해 대략적으로만 알고있어서 내가 이해한 대로 구현했더니 이건 아닌 것 같았다. 이건 좀 더 공부해보고 이번에 만든 스프링부트 프로젝트를 뜯어 고쳐야겠다. -드디어 운영체제 공부를 할 수 있다! 다음주는 운영체제 공부 및 알고리즘에 집중 할 예정이다. -요 일주일 내내 프로젝트를 달리면서 아직 갈 길이 멀다는걸 느꼈다. 그리고 설계의 중요성을 통감했다. 기간이 정해지면 마음이 급해져서 설계에 오랜시간이 걸리게되면 초조해진다.그렇게 설계를 날림으로 하고 나중에 뜯어고치느라 고생하는데, 좋은 방법이 없을까..? -최근들어 파이썬 공부가 필요하다고 느끼고 있다. Django로 작은 웹사이트 만들어보면 좋을 것 같은데 아직은 당장 해야할 게 많기 때문에 조금 미뤄둬야겠다.. 다음주 목표 알고리즘 문제 스터디 운영체제 강의 수강 총평어쩌다보니 이번주는 굉장히 새로운 걸 적용해서 뭔가 만들어야 했기 때문에 어느정도 스트레스 받기도 했지만, 하나씩 기능이 만들어지고 동작해서 즐겁게 할 수 있었다. RESTFul, TDD등 평소에 궁금했던걸 경험해 볼 수 있었고, 스프링부트 웹 크롤링 등 들어봤던 기술들을 사용해 뭔가 만들었기 때문에 어쩌다보니 다양한 경험과 시도를 한 주였다. 다음주엔 우분투 서울지역 세미나가 있는데 내가 컴퓨터공부를 시작하게 된 계기가 리눅스 우분투인 것 만큼 굉장히 기대된다.","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"180820-180826 주간 회고","slug":"2018-08-26-180820~180826","date":"2018-08-25T15:00:00.000Z","updated":"2019-07-15T14:11:55.566Z","comments":true,"path":"2018/08/26/2018-08-26-180820~180826/","link":"","permalink":"https://sehajyang.github.io/2018/08/26/2018-08-26-180820~180826/","excerpt":"","text":"이번주는 저번주에 결심했다시피 기초 및 기본을 좀 더 다지려는 주였다. 미뤄왔던 알고리즘 공부도 시작했다! 그리고 웹 개발에 있어 방향을 좀 더 잡은 주였다. 스프링 프레임워크와 자바를 사용해서 웹을 만드는 것 보다 Nodejs로 구현하는 것에 크게 매력을 느끼고 있어 Node.js로 방향을 틀었다. 사실 내가 할수 있는 것과 하고 싶은 것의 고민은 있었지만 아직 시작일때 하고싶은걸 하자 라고 생각했다. 개인공부구현하고 싶은건 잔뜩 있지만 기본이 다지지 않은 상태에서 무리하게 기술을 쌓고있던게 아니였나 싶어 다시 기초를 다지고 있다. 알고리즘 문제를 풀며 좀 더 효율적으로 짤 수 없을까 고민도 많이 하게 됐다. 그 과정에서 설계를 잘못해서 다 엎거나 며칠동안 한게 헛수고가 되거나 하는 일도 있었다. 알고리즘 문제가 꿈에 나올 정도가 됐다 근데 왜 꿈에서도 못푸니… 나는 답지를 빨리 보는 스타일이라 알고리즘 문제는 나와 상극이라고 생각했었다. 하지만 막상 시작해보면 생각했던 것 만큼 거대한건 아니라는 생각이 든다. 역시 뭔가에 도전하는건 책임이 따를 경우 어렵고 무섭지만 막상 시작해보면 그렇게 무서운 게 아니였던 것 같다. -Node.js 기초를 계속 다질 예정이다. 웹 크롤링을 해서 작은 홈페이지도 하나 만들어 볼 예정이다. -최근은 바빠서 통 하지 못했지만, 다음 주 부터는 하고싶었던 운영체제 공부를 드디어 시작할 수 있을 것 같다. 학교다닐 때도 느꼈지만 나에게 있어 컴퓨터 구조라던지 그런 기초 공부는 코딩과도 같은 것 같다. 로직을 분석해서 흐름을 보고 결과를 예측하고 테스트하고 그런 모든 과정이 굉장히 유사하기 때문이다. 다음주 목표 알고리즘 문제 스터디 프로그래머스 운영체제 강의 수강 Nodejs 프로젝트 총평돋보이려 하면 조급해진다는 말이 있는데 그 말을 계기로 기초 공부를 하게 됐다. 그래서 이번주는 그간 신기술을 배우느라 못했던 기반, 기초 공부를 할 수 있어서 너무 좋았다. 늘 마음 한켠이 걸렸었는데 이번 기회에 제대로 할 수 있을 것 같아서 좋다. 기초 공부의 복습은 화려하지 않지만 꼭 필요하기 때문에 급하지 않게 하고 싶다.","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"Study logs","slug":"2018-08-22-study-log","date":"2018-08-21T15:00:00.000Z","updated":"2019-07-15T14:11:55.564Z","comments":false,"path":"2018/08/22/2018-08-22-study-log/","link":"","permalink":"https://sehajyang.github.io/2018/08/22/2018-08-22-study-log/","excerpt":"","text":"형식: 공부내용 / 사용한 컨텐츠(ex: 책, 강의 등) [18.06.26] Host scanning Study [18.06.27] Reversing Study [18.06.27] Spring Web Project ‘Devlink’ front home,network 등 구현 [18.06.27] Docker 및 OpenStack Study [18.06.28] OpenInfraDay day1 2018 &amp; SmartTech day2 2018 attendance로 참가 [18.06.28] Docker 설치 및 테스트 / 강의, 웹 [18.06.29] Spring Web Project ‘Devlink’ Spring Security Login 개발중 [18.06.29] OpenInfraDay 2018 에서 들은 내용 정리 / OneNote [18.06.29] Reversing Study [18.06.30] Cloud computing Service Types: Saas, IaaS, PaaS 공부 및 정리/ 책, OneNote [18.06.30] Reversing Study [18.07.01] AWS 계정생성, 암호화 학습 / 강의 [18.07.02] Docker network, Linux Oracle 설치 및 세팅 삽질 [18.07.02] Spring Web Project ‘Devlink’ 개발중 [18.07.04] Spring Web Project ‘Devlink’ 개발중 [18.07.05] Spring Web Project ‘Devlink’ 개발중 [18.07.05] Port Scanning, Vulnerability scanner Study/ 강의, OneNote [18.07.06] Spring Web Project ‘Devlink’ 개발중 [18.07.08] 개발자의 생존전략 세미나 참석 [18.07.11] Spring Web Project ‘Devlink’ AWS 배포 테스트 [18.07.13] Spring Web Project ‘Devlink’ 개발완료 [18.07.14] Node.js + Web 공부 시작 [18.07.15] 웹 취약점분석 세미나 참석 [18.07.16] Kitware, devlink Web project vulnerability analysis [18.07.17] Node.js, Express.js Study, Spring Toy Project Board Create [18.07.18] BaekJoon Algorithm Quiz 풀이, Data Structure, Algorithm /강의 [18.07.19] Node.js, Express.js Study, Spring MVC Study /강의, 책 [18.07.20] Node.js, MongoDB, WAS(Tomcat) Structure Study [18.07.22] WAS structure Study [18.07.23] Node.js, MongoDB Study (Test Web Project Start) [18.07.23] Spring MVC Study [18.07.24] Node.js Study /강의 [18.07.26] Node.js, Spring, gitLab Study [18.07.27] Seoul.js Lightning Talk 참석, Algorithm Quiz 풀이 [18.07.28] Algorithm Quiz 풀이, Java Study 및 포스팅 [18.07.29] Toy Project 기능 추가, Node.js Study, Blog comment Add &amp; Custom [18.07.31] Node.js Study /Head First 책 [18.08.01] Node.js, Java Study, Algorithm Quiz 풀이 /Head First 책, 알고리즘 문제해결전략 [18.08.01] Node.js, React.js, Java Study /강의, 책 [18.08.02] Java Study Complete /Head First 책 [18.08.03] Node.js Study /강의 [18.08.04] React Movie Project /Nomad coders [18.08.05] Design Pattern Study / HeadFiest 책 [18.08.06] React Movie Project, Node.js Express.js Router Study /Nomad coders, 강의 [18.08.07] Node.js Study /강의 [18.08.08] React-Native DEV ENV Setting &amp; TODO App Project Start /Nodam coder [18.08.09] Okky 오픈소스 세미나 참석 [18.08.10] React-Native ToDo App Project, Node.js passport Study [18.08.12] React.js , Node.js Study [18.08.13] React-Native Project [18.08.14] Node.js Study [18.08.15] Spring ToyProject Start, RESTful Study, 챗봇 만들기 시작(AWS Rambda, Travis CI, telegram) [18.08.16] Spring ToyProject, 챗봇 전체발송 기능 삽질 [18.08.17] Docker로 CI 구축 연습 (Gradle + Docker + Jenkins + Slack), 챗봇 삽질 [18.08.18] Docker, Jenkins 삽질 [18.08.19] Design pattern Study, Node.js 기초 Study /책 [18.08.20] Spring Toy Project, Node.js Study [18.08.21] Spring Toy Project, Node.js Study 및 정리 [18.08.22] 알고리즘 및 웹 크롤링 공부 /책 [18.08.23] 웹 크롤링 공부 /책 [18.08.24] AWS 삽질, 웹 크롤링 공부 [18.08.26] 알고리즘 공부 [18.08.27 ~ 18.08.28] Node.js Study [18.08.29] Node.js Study, SpringBoot Study Start [18.08.30] Springboot Setting Study [18.08.31] Springboot Study [18.09.01] Springboot Project, C 포인터 세미나 참석 [18.09.02] Springboot Project [18.09.04] 운영체제 공부, Python Study /강의 [18.09.05] 운영체제 공부, Python Django Study /강의 [18.09.06] 운영체제 공부, Python Study /강의 [18.09.07 ~ 18.09.12] Python Study /책 [18.09.13] Springboot Study [18.09.14 ~ 18.09.15] Java, JS, Typescript Study [18.09.16] Node Crawling Project Start [18.09.17] Java, DB Study [18.09.19] [AUSG Seminar Series] 2018 F/W 초보자를 위한 AWS 뿌시기 [18.09.20] [T academy]스프링부트를 이용한 웹 서비스 개발하기 [18.09.21] Algorithm Study, Node project CI(travis CI, Jenkins+Slack) 구축 [18.09.23 ~ 18.09.26] Algotithm Study (Python) [18.09.29~18.10.01] Algotithm Study, Springboot Study [18.10.02] Springboot 강의, Node.js project [18.10.04] Node.js project [18.10.05] Node.js project, React Study /책 [18.10.06] Node.js project, React Study, Daily Algorithm [18.10.07] Dev Django 세미나 참석 12월 이후 로그 기록 [18.12.11] springboot 수강 후 TIL 기록 [18.12.12] springboot 수강 후 TIL 기록","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"studylog","slug":"studylog","permalink":"https://sehajyang.github.io/tags/studylog/"},{"name":"daily","slug":"daily","permalink":"https://sehajyang.github.io/tags/daily/"}]},{"title":"180813-180819 주간 회고","slug":"2018-08-19-180813~180819","date":"2018-08-18T15:00:00.000Z","updated":"2019-07-15T14:11:55.563Z","comments":true,"path":"2018/08/19/2018-08-19-180813~180819/","link":"","permalink":"https://sehajyang.github.io/2018/08/19/2018-08-19-180813~180819/","excerpt":"","text":"이번주는 궁금했었던 Jenkin와 Sonarqube를 경험해봤고 AWS Lambda나 API Gateway등을 써보는 등 새로운 경험을 많이 한 주였다. 기존의 복잡하고 귀찮은 절차를 쉽고 빠르게 개선시킨 새로운 기술들을 써보니 정말 신세계였다. 몇개월 전에 Docker 나 AWS를 처음 들었었던게 생각난다. 그땐 처음 들어보는 생소한 단어들이 너무 많아서 언젠간 하게되겠지 라고 생각했는데, 이렇게 써보기도 하고 과거에 비해 나름대로 발전하고 있는 것 같아 기쁘다. 많은 기술들을 다 경험 해봐야 한다는 생각을 하고있었는데, 최근에 나 뿐만이 아니라 다른 사람들 역시 같은 고민을 하고 있다는걸 알게됐다. 그게 스트레스가 되면 오히려 독이라는 조언도 볼 수 있었는데, 그 말에 내가 지금 껏 해왔던 공부를 돌아보게 됐다. 사람마다 다르겠지만 나에게 있어 새 기술을 배우는건 익숙한 것을 하는 것 보다 즐겁다. 그렇게 신나서 최근 많은 기술들을 경험해보고 있었는데, 어느샌가 모든 유명한 기술을 다 경험해봐야 한다로 바뀌어서 스트레스를 받고 있지 않았나 생각했다. 그만큼, 익숙한 기술을 등한시하게 되는 부분도 분명히 있었다. 그래서 다음주는 새로운걸 배우기 보단 익숙한 기술과 새로운 기술의 기초를 복습하고 정리해야겠다. 개인공부세미나 알림봇이 있으면 좋겠다고 생각했다! 나는 주위사람들에게 세미나 정보를 매일같이 알려주고 있었는데, 다들 좋아했기 때문에 다른 사람들도 이러한 알림 서비스(?)를 필요로 하지 않을까 생각해서 만들고자 결심하게 됐다. 창천향로님의 챗봇 만들기를 보며 다양한 AWS의 서비스들을 사용해 볼 수 있었다. EC2 와 RDS 만 써봤었는데, Rambda, S3, API Gateway, IAM, DynamoDB등을 써볼 수 있었다. 깃허브와 TravisCI, AWS를 연동했는데 깃허브에 push하면 자동으로 빌드해서 서비스를 한다는게 충격이였다. /seminar를 입력하면 내가 깃허브에 push한 JSON 형태의 세미나 정보를 보여주기까진 됐지만, /subscribe기능을 추가할때 내가 뭔가 잘못한건지 반응하지 않았다. 뭔가 빠트린게 있나보다.. 며칠을 삽질하다 그냥 처음부터 다시하고있다(본격 삽질시작) -Spring 토이 프로젝트로 디X인사이드같은 그런 커뮤니티 웹을 만들어 서비스까지 할 생각을 하고있는데, 그러다보니 점점 신경쓸게 많아진다. 나름대로 많은사람이 이용할걸 염두에 두고 있는데, 그런 프로젝트를 해본적이 없어서 아직 길을 못잡겠다. 그래서 일단 하던대로 만들기 시작했는데 만들면서 내가 초보라는 사실을 뼈저리게 느끼고있다.. 흑흑…… -Head First Design Pattern책을 다 읽었다. 정리 세상은 넓고 디자인패턴은 많구나.. 들어본 패턴부터 처음듣는 패턴까지 굉장히 많은 디자인 패턴이 있었고 다 이해하진 못했지만 조금은 감이 온것 같은 느낌이 들었다. 디자인 패턴 어렵지만 나도 언젠간 적재적소에 디자인패턴을 잘 사용 할 수 있는 개발자가 됐으면 좋겠다.. 모든 디자인 패턴을 마스터한다는건 언젠간 가능할지 몰라도 지금은 절대 아닌것 같고 그냥 내가 사용해본거나 유명한거 몇개 정도는 어느정도 익히고싶다. 그래도 들어봤던 몇가지 패턴에 대해 조금이나마 알 수 있어서 되게 좋았다. -깃허브와 Jenkins와 Slack을 연동했다 창천향로님 게시글을 보고 따라해봤는데 설명이 너무 친절하셔서 성공적으로 구축할 수 있었다ㅠㅠ 물론 삽질도 좀 했지만 그래도 비교적 쉽게 구축할 수 있었다. 정말 Github에 푸쉬하자마자 빌드가 되고 로그가 딱 뜨고 알림이 슬랙으로 딱 오고 이게 정말 예술인것같다. Jenkins는 정말 예술이다 팀프로젝트때에 AWS와 연동해서 써볼걸.. 그때는 코드 한줄이라도 수정하면 war 파일만들어서 그 파일을 AWS EC2 서버로 옮기고.. webapps아래에 배포하고 그랬는데 와 에러라도 나면 다시 반복하고 그랬다. 이 좋은 Jenkins 를 진작알았더라면 그런 구석기 시대의! 빌드 작업을 하지 않았을 텐데 아쉽다.. -Sonarqube를 사용해봤다!! 저번주에 엄청 삽질하다 실패했는데, 이번엔 성공했다ㅠㅠ 버그랑 중복코드 퍼센테이지랑 다 나오는데 정말 굉장한 오픈소스다. 항상 보기만 하던걸 실제로 해보니 너무 감동이었다ㅠㅠ Jenkins와 연동하는건, window에 Docker를 설치하다 설정을 잘못만져 문제가 생겨버렸기 때문에 점점 복잡해져서 일단은 미뤄뒀다. 나는 분명 get started문서를 보고 하라는 대로 했는데 늘 어째서 오류가 나는지 알 수 없다.. 예전에 docker 설치할때 뭔가 잘못한 것 같은데 짚이는게 너무 많다. 차라리 멀티부트 해둔 리눅스로 받아서 할까 생각해봤지만 그쪽은 개발환경 셋팅을 안해놨다.. 윈도우 불편한데 리눅스도 불편하고 차라리 vmware에 예전에 해킹공부용으로 파둔 리눅스에 개발환경 셋팅해둘까 생각도 하는데 칼리 리눅스니까.. 아무튼 kitematic은 되니까 도커오류는 나중에 잡아봐야겠다. 참 괴상하게도 kitematic은 되는데 콘솔모드 도커는 에러가 난다ㅎㅎ 정말이지 알수없다.. 다음주 목표 Spring, Node.js, Javascript 기초 복습 및 공부 운영체제 강의 수강 시간이 되면 kubernetes 알아보기 총평이번주는 다양한 CI 툴을 경험해봤는데 그야말로 신세계였다. 나는 자동화가 정말 좋고, 나도 무언가를 자동화하는 걸 개발하고싶다. 나름대로 이번주 목표였던 React.js 도 Node.js도 수강을 완료했다. 학(学)을 했으니 습(習)을 할 차례라고 생각한다.","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"Design Pattern 정리","slug":"2018-08-19-design-pattern","date":"2018-08-18T15:00:00.000Z","updated":"2019-08-02T14:41:53.797Z","comments":true,"path":"2018/08/19/2018-08-19-design-pattern/","link":"","permalink":"https://sehajyang.github.io/2018/08/19/2018-08-19-design-pattern/","excerpt":"","text":"디자인 원칙(SOLID) Open-Closed-Principle(개방 폐쇄 원칙) 클래스는 확장에 대해서는 열려있어야하지만, 코드변경에 대해서는 닫혀있어야한다. Dependency-Inversion-Principle(의존성 뒤집기 원칙) 추상화된것에 의존하게 만들어야한다. 구상클래스에 의존하도록 만들지 않도록 한다. 어떤 변수에도 구상클래스에 대한 레퍼런스를 저장하지않는다. 구상 클래스에서 유도된 클래스를 만들지 않는다. 베이스 클레스에 이미 구현되어있던 메소드를 오버라이드 하지 않는다. Single Responsiblity Principle(단일 책임 원칙) Liskov Subsitution Principle(리스코브 치환 원칙) Interface Segregation Principle(인터페이스 분리 원칙) Singleton Pattern특정클래스에 대해 객체 인스턴스 한개만 만들어 사용하기 위한 패턴 필요할 때만 객체를 만들기 위함 해당 클래스의 인스턴스가 하나만 만들어지고, 어디서든지 그 인스턴스에 접근할 수 있도록 하기 위한 패턴 1234public MyClass &#123; public static MyClass getInstance()&#123; &#125;&#125; MyClass에 정적메소드가 있고 그 정적 메소드는 이렇게 호출할 수 있다. MyClass.getInstance(); 정적 메소드를 지칭할 때는 클래스 이름을 써야한다.(MyClass) new 를 사용할 수 없도록 생성자에 private를 지정하고 정적메소드를 지원해야하며 참조변수가 필요하다 동시에 접근할 경우 인스턴스 두개가 생성되게된다 따라서 synchronized 로 동기화시킨다. 인스턴스 사용하지 않는 경우에도 메모리에 있으며 그것을 방지하기위해 Volatile를 사용한다 모든 스레드에 대한 최신의 값을 읽어올 수 있게 해준다. Strategy Pattern알고리즘군을 정의하고 캡슐화해, 교환해서 사용할 수 있도록 만든다. 알고리즘을 사용하는 클라이언트와는 독립적으로 알고리즘을 변경할 수 있다. Observer PatternSubject 인터페이스와 Observer 인터페이스가 들어있는 클래스 디자인을 바탕으로 구현한다. 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고, 자동으로 내용이 갱신되는 방식이다. 일대다 의존성을 정의. Loose Coupling 이다. Loose Coupling(느슨한 결합)의 장점 =&gt; 객체 사이의 상호의존성을 최소화 했기에, 변경사항이 생겨도 무난히 처리할 수 있는 유연한 객체지향 시스템을 구축할 수 있다. Subject 인터페이스가 옵저버에 대해 아는것은 옵저버가 인터페이스를 구현한다는 것 뿐이다. 옵저버는 언제든지 새로 추가/제거 할 수 있으며 Subject를 변경하지 않아도 된다. Subject 인터페이스와 옵저버는 서로 독립적으로 재사용 할 수 있으며 서로 바뀌더라도 서로에게 영향을 주지 않는다. Decorator Pattern객체에 추가적인 요건을 동적으로 첨가한다. 서브클래스를 만드는 것 을 통해서 기능을 유연 하게 확장할 수 있는 방법 을 제공 한다. 데코레이터의 super class는 자신이 장식 하고 있는 객체의 super class와 같다. 한 객체를 여러 개의 데코레이터로 감쌀 수 있다. 데코레이터는 자신이 감싸고 있는 객체와 같은 super class를 갖고 있기 때문에, 원래 객체가 들어갈 자리에 데코레이터 객체를 집어넣어도 상관없다. 데코레이터는 자신이 장식하고 있는 객체에게 어떤행동을 위임하는 것 외에 원하는 추가적인 작업을 수행할 수 있다. 객체를 언제든지 감쌀 수 있기 때문에 실행중에 필요한 데코레이터를 마음 대로 적용할 수 있다. Factory Method Pattern객체를 생성하기위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정하게 만든다. 즉, 클래스의 인스턴스 만드는 일을 서브클래스에게 맡긴다. **아래부터 보충 필요 Command Pattern메소드 호출을 캡슐화하는 패턴 커맨드 패턴을 이용하면 요구사항을 객체로 캡슐화 할 수 있으며, 매개변수를 써서 여러 가지 다른 요구사항을 집어넣을 수 있다. 요청 내역을 큐에 저장하거나 로그로 기록할 수 있으며, 작업취소 기능도 지원 가능하다. Adapter Pattern한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환한다. 어댑터를 이용하면 인터페이스 호환성 문제때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수 있다. Facade Pattern어떤 서브시스템의 일련의 인터페이스에 대한 통합된 인터페이스를 제공한다. 퍼사드에서 고수준 인터페이스를 정의하기 때문에 서브시스템을 더 쉽게 사용할 수 있다. Template Method Pattern알고리즘을 캡슐화 해서 서브클래스에서 필요할 때마다 쓸 수 있게 한다. 메소드에서 알고리즘의 골격을 정의한다. 알고리즘의 여러단계 중 일부는 서브클래스에서 구현 할 수 있다. 템플릿 메소드를 이요하면 알고리즘의 구조는 그대로 유지하면서 서브클래스에서 특정 단계를 재정의할 수 있다. Iterator Pattern내부적인 구현방법을(반복작업을 별도의 객체로 캡슐화 함으로써) 외부에 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 접근할 수 있게 해주는 방법을 제공한다. composite Pattern객체들을 트리 구조로 구성하여 부분과 전체를 나타내는 계층구조로 만들 수 있다. 이 패턴을 이요하면 클라이언트에서 개별 객체와 다른 객체들로 구성된 복합 객체(composite)를 똑같은 방법으로 다룰 수 있다. 복합 구조(composite structure)를 사용하면 복합객체와 개별객체에 대해 똑같은 작업을 적용할 수 있다. State Pattern객체의 내부 상태가 바뀜에 따라서 객체의 행동을 바꿀 수 있다. 마치 객체의 클래스가 바뀌는 것과 같은 결과를 얻을 수 있다. Proxy Pattern어떤 객체에 대한 접근을 제어하기 위한 용도로, 대리인이나 대변인에 해당하는 객체를 제공하는 패턴 원격객체라던가 생성하기 힘든 객체, 보안이 중요한 객체와 같은 다른 객체에 대한 접근을 제어하는 대변자 객체를 만들 수 있다. Compound Pattern두개이상의 패턴을 결합해서 사용하는 것 Bridge Pattern구현뿐만 아니라 추상화된 부분까지 변경시켜야 하는 경우에 사용 브리지 패턴을 이용하면 추상화된 부분과 추상클래스/인터페이스를 구현한 클래스를 서로 다른 클래스 계층구조에 집어넣음으로써 그 둘을 모두 변경시킬 수 있다. Builder Pattern제품 생산 단계들을 캡슐화하고싶다면 사용 복합객체가 생성되는 과정을 캡슐화한다. 여러단계와 다양한 절차를 통해 객체를 만들 수 있다. (팩토리패턴에선 한단계에서 모든걸 다 처리한다) Chain of responsibility Pattern역할사슬 패턴 주어진 요청을 검토하기 위한 객체사슬을 생성한다. 그 사슬에 속해있는 각 객체에서는 자기가 받은 요청을 검사해 직접 처리하거나 사슬에 들어있는 다른 객체에게 넘기게 된다. Flyweight Pattern어떤 클래스 인스턴스 한 개만 가지고 여러개의 가상인스턴스를 제공하고 싶을 때 사용 인스턴스는 한개만 만들어 여러 가상 객체의 상태를 한곳에 집중시켜놓을 수 있다. Interpreter Pattern어떤 언어에 대한 인터프리터를 만들 때는 인터프리터 패턴을 사용 각 문법 규칙을 클래스로 표현하기 때문에 언어를 쉽게 구현할 수 있다. 문법이 클래스에 의해 표현되기 때문에 언어를 쉽게 변경하거나 확장할 수 있다. Mediator Pattern서로 관련된 객체 사이의 복잡한 통신과 제어를 한 곳으로 집중시키고자 하는 경우에 사용 시스템하고 각 객체를 분리시킴으로써 재사용성을 향상시킬 수 있다. 제어로직을 한군데에 모아두었기 때문에 관리하기가 수월하다. Memonto Pattern객체를 이전의 상태로 복구시켜야 하는 경우에 사용 Prototype Pattern어떤 클래스의 인스턴스를 만드는것이 자원/시간을 많이 잡아먹거나 복잡한 경우에 사용 기존 인스턴스를 복사하기만 하면 새로운 인스턴스를 만들 수 있다. 클라이언트 코드에서 어떤 클래스의 인스턴스를 만드는지 모르는 상태에서도 새로운 인스턴스를 만들 수 있다. Vititor Pattern다양한 객체에 새로운 기능을 추가해야하는데 캡슐화가 별로 중요하지 않을 경우 사용 구조 자체를 변경시키지 않으면서도 복합 객체 구조에 비교적 손쉽게 새로운 기능을 추가할 수 있다. 참고 : HeadFirst Design Pattern","categories":[{"name":"Etc","slug":"Etc","permalink":"https://sehajyang.github.io/categories/Etc/"}],"tags":[{"name":"study","slug":"study","permalink":"https://sehajyang.github.io/tags/study/"}]},{"title":"180806-180812 주간 회고","slug":"2018-08-12-180806~180812","date":"2018-08-11T15:00:00.000Z","updated":"2019-07-15T14:11:55.563Z","comments":true,"path":"2018/08/12/2018-08-12-180806~180812/","link":"","permalink":"https://sehajyang.github.io/2018/08/12/2018-08-12-180806~180812/","excerpt":"","text":"이번주는 React의 주 였다고 봐도 무방할정도로 React만 한 주였다. 수많은 React.js Study의 향연 처음엔 그저 궁금해서 호기심에, 그냥 발만 살짝담궈보려고 했는데 하다보니 신기하고 재밌어서 계속하고있다. 개인공부React.js 와 함께 ReactNative도 하고있다. 간단한 ToDo앱을 만들고 있는데, 역시 새로운 걸 배울땐 일단 시작해서 작은 프로젝트 하나 만들어 보는게 좋은 것 같다. 그게, 흥미를 잃지 않고 즐겁게 계속 배울 수 있는 방법 중 하나인 것 같다. 그래서인지, 학교 다닐 땐 앱 개발은 영 재미가 없었는데 요즘은 너무 재밌다. 그냥 아직 지식도 경험도 많이 부족하기 때문에, 뭘 하든 새롭고 재밌는 것 같다.. TypeScript도 하고싶은데 일단 최근에 공부한 js들(Node.js ,React.js 등..)을 복습하는게 먼저인듯.. -운영체제 강의를 듣고 정리할 예정이다. 학교에서 배웠던 내용 다 까먹은 듯 싶어서.. 그래도 가장 좋아했던 과목이었던 만큼 기억엔 아직 조금이나마(..) 남아있는 것 같다.(아닐지도) 일단 강의는 KOCW의 운영체제를 수강 할 예정이다. 정리도 할겸 포스팅 연재하는 방식으로 할 건데, 아직 글쓰기도 정리하는 기술도 미숙해서 내 포스팅을 볼 때마다 부족한게 많구나 라는 생각이 든다.. -목요일에 오키 오픈소스 세미나를 갔다. 후기 오키 창시자이신 허광남님이 재직중이신 회사에 오픈소스 도입한 그런 내용이었는데, Jenkins 에 대해서 막연하게 알았던걸 구체적으로 써봐야겠다 고 마음먹게 되는 계기가 됐다. Jenkins + Sonarqube를 써보고 싶어서 오늘 반나절 Sonarqube 삽질만 했다.. 그러다 Gradle 삽질하고.. 나는 뭔가 새로운 걸 배울 때 일단 써보고, 에러나고, 삽질하면서 그제서야 문서를 보고 차근차근 해보는데, 이게 바로 머리가나쁘면 몸이 고생한다는건가 싶다. 그렇다고 문서부터 보면 눈에 잘 들어오지도 않아서 그냥 계속 몸이 고생하고있다. 흑흑.. 다음주 목표 React.js, React-Native 미니 프로젝트 완료 Node.js 강좌 완료(얼마 안남았다!) SonarQube 및 Jenkins 삽질기 기록 운영체제 강의 수강 총평이번주는 주말에 아파서 주말을 거의 날려버렸다.. 건강관리는 역시 중요하다.. js가 가득한 주 였던 것 같다. Node.js는 지금 껏 해오던 spring와 많이 달라서 배울때마다 놀라고있다. React 역시 마찬가지.. 지금은 지식이 얕아 새로운 기술을 즐겁게 놀라며 배울 수 있다고 긍정적으로 생각하고 있다. 대체 어느 세월에 슈퍼 개발자가 될까 싶지만… 어디서 들은건진 기억이 안나는데, 개발은 물 속에 벽돌을 쌓는 것과도 같아서 처음엔 아무리 쌓아도 눈에 보이지 않지만 어느순간이 되면 쌓아오던 벽돌이 수면 밖으로 나와, 그때부터 쑥쑥 크는게 보인다고 한다. 언젠간 그렇게 될 수 있겠지 라고 막연하게 생각한다. 요즘 구조 공부 하는것 도 개발도 배포하는 일도 테스팅도 모니터링도 다 재밌다. 많은걸 배우고 경험해서 내가 원하는걸 간결한 코드로 만들어서 배포하고대용량 트래픽을 처리하고, 안정적인 서비스를 할 수 있는 그런 개발자가 되고싶다!!","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"오픈소스, 줘도 못 먹나 후기","slug":"2018-08-09-okky-opensource-seminar","date":"2018-08-08T15:00:00.000Z","updated":"2019-07-15T14:11:55.561Z","comments":true,"path":"2018/08/09/2018-08-09-okky-opensource-seminar/","link":"","permalink":"https://sehajyang.github.io/2018/08/09/2018-08-09-okky-opensource-seminar/","excerpt":"","text":"Okky 창시자이신 허광남(kenu)님이 오픈소스 세미나를 하신다는 글을 Okky에서 보게됐다. 세미나 소개에 내가 사용하고 있거나, 궁금했던 오픈소스들이 많이 보였다. 이번기회에 내가 사용하고있는 오픈소스에 대해서 좀 더 알고 싶었고, 허광남님이 현업에서 어떤 오픈소스를 사용하고, 어떻게 도입하셨는지 궁금해서 참석하게 되었다! [OKKY 세미나] 오픈소스, 줘도 못 먹나 - 오픈소스로 팀의 개발 생산성 높이기 by kenu Kenu님의 발표자료 창천향로님의 후기 Intro기록을 잘 남기고, 관리하는게 좋다. 테스트 자동화하면 코드의 품질이 높아진다. 어플리케이션 기능이 추가될 때마다 테스트케이스로 만들어놓으면 어디서 사이드 이펙트가 나는지 쉽게 알 수 있다. 단위테스트(TDD) (function기준)으로 만들어놓는게 좋다. 단계별 오픈 소스 오픈소스 시작하기오픈소스 경험 = 시간 + 시행착오 + 성공실패 그러니 일단 사용부터 (Getting started) 해라! default setting 문서를 보고 시작하는게 좋다. 책/블로그 보고 시작할땐 버젼 맞추기 오픈소스 함부로 수정하면 안된다! =&gt; 오픈소스 커뮤니티를 추천 버전업 주기가 빠르기 때문 버전 팁 최신보다 1, 2 낮은 버전 사용을 권장(서비스 시) LTS 권장 LTS는 우분투에서 시작된 말 =&gt; Long Term Support (2년동안은 버전을 올리지 않는다) =&gt; 최소 2년은 안심하고 써도 됨 최신 버전은 Blood Edge = &gt; 유혈이 낭자하는(?) 최전선, 온갖 에러를 만날 수 있다. 팀에 오픈소스를 도입하고 싶을 때12341. 명분, 근거자료2. 도입 전과 후 장점 어필(적은 노력으로 많은 효과 강조)3. 영향이 적은 곳 부터 적용(실적이 잘 안나오는 부서부터 공략..)4. 메인 비즈니스에는 경험이 쌓인 후 도입 오픈소스 기여방법1234561. 일단 사용2. 블로깅 (3년을 관련 오픈소스에 대한 포스팅을 하면 주변에서 전문가라 칭한다고 한다)3. 설정 튜닝(configuration 튜닝)4. 이슈 등록(contribution)5. 문서 번역6. fork&amp;pull request 경험했거나 현재 사용하는 오픈소스 제품들12345678910* 2000년 톰캣을 시작으로* Ant* Eclipse :에릭감마* Junit :에릭감마&amp;캔트 백이 만듬 =&gt; 부하테스트 할때 좋음 =&gt; Java Swing UI 로 만들어져있다.* Jmeter* Yona, Git, VSCode* Jenkins, CentOS, VirtualBox* Nginx, Node.js, Express.js* MariaDB, ELK, Uptime* Mocha, SonarQube, ZAP title 을 누르면 해당 오픈소스 홈페이지로 이동합니다 Yona프로젝트 관리도구 Yona는 Git을 서버로 관리해준다. 네이버 오픈소스 였었다(지금은 나옴) 이슈트래커 + Gix(SVN) 무료 (Git private는 돈을 내야하지만 이건 무료) Email 설정을 하면 보다 깊게 사용할 수 있다. Email 설정시 imap.folder = “Inbox”로 설정되어있는지 확인할 것(꼭 “Inbox”여야한다. 소문자면 안됨) GIT분산 버전 관리 시스템 리눅스 토발즈가 만들었고 홈페이지도 운영한다. 유용하게 사용한 상황별 커맨드를 정리 https://okdevtv.com/mib/git VSCodeelectron js 기반으로 만들어진 오픈소스 편집기가 브래킷, 아톰, vscode VSCode 안의 git 기능을 강추(특히 누가 선택한 라인을 작성했는지 (git blame 기능) 볼수 있다) GitLens Plugin과 Quokka Plugin(유료)가 좋다. Quokka Plugin은 변수값 수정시 다른 곳 해당 변수명의 변수 값도 같이 수정해주는 기능이있다. https://okdevtv.com/mib/vsc https://github.com/Microsoft/vscode-tips-and-tricks &lt;&lt;어마어마한 vscode 팁과 트릭이있다. Jenkins허드슨 만든 개발자가 Oracle에서 나와서 Jenkins를 만들었다. 지속적인 통합(Conituous Integration) =&gt; Git과 Jeckins를 잘 사용하면 완료 한달전 파트 합칠때의 유혈 사태(?)를 방지할 수 있다. 빌드 &amp; 모니터 자동화 Java로 만들어짐 에러 로그를 다 확인할 수 있어 좋다. https://okdevtv.com/mib/jenkins Virtualbox테스트용도 (많은 이미지가 있지만 Mac OS는 지원하지 않는다) https://okdevtv.com/mib/virtualbox Nginx아파치보다 가벼움, 설정도 가벼움 로드밸런싱 지원 https://okdevtv.com/mib/nginx MariaDBMySQL 만든 개발자가 오라클의 삽질로 오라클에서 나와서 만든 DB 둘째 딸 이름이 Maria 라 MariaDB MySQL과 굉장히 흡사하다(MySQL과 동일한 API) 심지어 프로세스 명이 mysql.exe이다 (MySQL은 mysqld.exe…) https://okdevtv.com/mib/mariadb ELK Stackelestic회사에서 만든 오픈소스 Elesticsearch(검색엔진) java 로 되어있다. ElasticSreach + Logstash + Kibana + Beats =&gt; 엑세스 로그를 모니터링(차트로 볼 수 있게 되어있다) https://okdevtv.com/mib/elk/elk6 Uptime=&gt; 1분마다 서버를 체크해준다. 메일설정하면 서버상태 보내준다 (서버가 죽었다거나..) 굉장히 편리 MochaJunit 대신 자바 유닛테스트 하기위함 SonarQube소스 정적 분석 도구 코드의 품질을 높일 수 있다 중복 코드 퍼센테이지와 취약한 코드를 볼 수 있다. 프로젝트 root에 sonar-project.prop 두면 결과가 reporting 된다. https://okdevtv.com/mib/sonar ZAP취약점 분석 자동 툴 반드시 본인 사이트에만 할 것 (다른 사이트에 하면 큰일남) XSS, SQL Inejction등 OWASP 취약점으로 있는건 다 테스트 한다. https://www.owasp.org/index.php/OWASP_Zed_Attack_Proxy_Project https://okdevtv.com/mib/zap 추가노드 + 크롬 디버깅은 NiM inspect manager 플러그인이 좋다!","categories":[{"name":"Seminar","slug":"Seminar","permalink":"https://sehajyang.github.io/categories/Seminar/"}],"tags":[{"name":"seminar","slug":"seminar","permalink":"https://sehajyang.github.io/tags/seminar/"}]},{"title":"180730-180805 주간 회고","slug":"2018-08-05-180730~180805","date":"2018-08-04T15:00:00.000Z","updated":"2019-07-15T14:11:55.560Z","comments":true,"path":"2018/08/05/2018-08-05-180730~180805/","link":"","permalink":"https://sehajyang.github.io/2018/08/05/2018-08-05-180730~180805/","excerpt":"","text":"최근에 프론트엔드에 관심이 생겨 React, Angular, Vue를 조금씩 공부해볼 생각이다. 아! TypeScript도 개인 공부자바 복습의 필요성을 느껴서 HeadFirst Java편 을 봤다. 대화식이고, 그림이 많아서 굉장히 술술 읽을 수 있었다. 처음 기술서적을 읽을때 어느정도 내용을 이해해야만 한다는 부담을 갖는 편인데, 이 책은 그러한 부담을 많이 덜도록 되어있는 것 같다는 느낌을 받았다. Java 편 다보고 Design Pattern(정리는 이쪽)을 읽기 시작했다. 객체지향에 대해서 예전엔 흐릿하게 알았지만 이젠 조금은 알게 된 느낌이 들었다. -OKKY Kenu 님의 오픈소스 세미나를 신청했다. 평소에 알고싶었던 유명한 오픈소소의 역사에 대해서 알 수 있을 것 같아서 신청했는데, 굉장히 기대된다. 세미나에 한번 갔다 오면, 몰랐거나 어렴풋이 알고 있었던 것에 대해 관심 갖게 되는 계기가 되는 것 같아 알고 싶었던 것에 대한 세미나를 참석하는게 즐겁다. -리액트 공부를 시작했다. 원래 프론트 앤드 엔 크게 관심이 없었는데, Seoul.js 에 갔다 오고 나니 관심이 많이 생겨서 이것저것 찾아보다 시작했다. 강의는 벨로퍼트님 의초심자를 위한 리액트 핵심 강좌를 보고있다. 프론트단에선 Javascript만 조금 해 왔는데, react는 비슷하면서도 달라서 굉장히 즐겁게 배우고있다. 간단한 Movie App을 만드는 리액트 클론코딩을 하고있는데, 이번주 내로 완료하고 리액트네이티브 서울밋업에 참석할 예정이다! -Node.js 공부는 매일 두강씩 듣는데, 아직 갈길이 멀다. 하지만 재밌어서 열심히 하고있다. Node.js 웹개발로 알아보는 백엔드 자바스크립트의 이해는 절반정도 봤다. 다 들으면 Node.js 교과서 이 책 으로 간단한 웹 어플리케이션을 만들어볼 생각을 하고있다. 총평이번 주 는 이것도 해보고 저것도 해보고 그러면서 Spring 공부도 틈틈히 하느라 정신이 없었다. 회사일도 충실히 하면서 하고싶은걸 하려면 몇 배로 노력해야 하는 건 어쩔 수 없다고 생각한다. 알고리즘 공부도 꾸준히 해야하는데 어렵다.. 그래서 알고리즘 스터디를 찾아볼까 하는 생각도 하고있지만, 일단은! Spring부터 해야할 것 같다.","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"Error logs","slug":"2018-07-30-error-log","date":"2018-07-29T15:00:00.000Z","updated":"2019-07-15T14:11:55.559Z","comments":true,"path":"2018/07/30/2018-07-30-error-log/","link":"","permalink":"https://sehajyang.github.io/2018/07/30/2018-07-30-error-log/","excerpt":"","text":"에러 로그 및 해결방법 기록 [18.07.23~24] 발생한 문제) Maven build가 되지 않아서 svn 으로 받은 프로젝트를 실행할 수 없었다(애당초 컴파일부터 안됨). 시도한 방법 jdk 1.7, jre 1.7, tomcat7 로 맞춤(그 환경에선 돌아갔으므로) jdk, jre, tomcat, eclipse 전부 재설치 플러그인 오류가 뜨길래 pom.xml의 dependency 추가 후 maven install &gt; update m2 의 repository 폴더를 날린 후(중요) maven clean &gt; maven install 오류를 잡고 프로젝트 clean , build 함 build path 에서 jre를 jdk로 잡고 실행 해결) build path 에서 jre를 jdk로 잡고 실행 =&gt; 구글링 해보니 jre가 자잘한 오류가 많으니 jdk로 잡으면 잘 된다고 한다. [18.07.24] 발생한 문제) java.lang.NoSuchMethodException 해결) default 생성자 없어서 남 [18.07.30] 발생한 문제)java.lang.IllegalArgumentException: Mapped Statements collection does not contain value~ 원인은 mapper id가 틀린 경우 Parameter와 bean의 field명이 틀린 경우 sql.xml에서 정의된 namespace와 DAO에서 호출하는 namespace가 다를 경우 mapper가 정의가 되어 있지 않거나 Spelling이 틀린 경우 mapper에 정의된 namespace 명칭이 같은 Application 내에 중복 될 경우 라고한다. 해결) mapper 이름의 오타였다..","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"error","slug":"error","permalink":"https://sehajyang.github.io/tags/error/"},{"name":"logs","slug":"logs","permalink":"https://sehajyang.github.io/tags/logs/"}]},{"title":"180723-180729 주간 회고","slug":"2018-07-30-180723~180729","date":"2018-07-29T15:00:00.000Z","updated":"2019-07-15T14:11:55.559Z","comments":true,"path":"2018/07/30/2018-07-30-180723~180729/","link":"","permalink":"https://sehajyang.github.io/2018/07/30/2018-07-30-180723~180729/","excerpt":"","text":"개인 공부최근들어 자바 기초를 많이 잊은게 아닌가 하는 생각을 했다. 그래서 이번주 중반부턴 자바 기초공부를 예전에 OneNote 에 기록해뒀던 자바 문법들을 다시 보는식으로 복습 하고있다. -생각보다 코딩하는 시간이 적다는걸 깨달았다. 무언가 부족한 느낌이 들어 백준 알고리즘 풀이를 다시 시작했다. 알고리즘 문제해결 전략 을 주문했다. -개인 공부로 Node.js + MongoBD 공부를 하고있는데, 쉽지가 않다. 게다가 NoSQL인 BD를 사용해본적이 없어서 굉장히 애먹고있다. Node.js도 시작부터 너무 어려운 강좌부터 봤다가 고생한 후 할만한(?) 난이도부터 다시 하고있다. 인프런의 Node.js 웹개발로 알아보는 백엔드 자바스크립트의 이해 를 보고있는데 이전에 삽질을 너무 오래해서, 최대한 빨리 들어야겠다. -미뤄뒀던 github 블로그에 카테고리랑 댓글기능을 추가했는데 생소해서 삽질을 꽤 했다. 테마는 조금 마음에 들지 않은데 일단 여기까지.. 다음에 시간이 날때 바꿔봐야겠다. 손볼게 너무많다! 깃랩도 시작했는데 생소해서 아직 뭐가 뭔지 잘 모르겠다. -출퇴근길에 읽을 책을 두 권 빌렸다. 프로그래머의 길 멘토에게 묻다 클린 코드 유명한 책들이라 내용이 기대된다. 다 읽은 후엔 깃허브 블로그에 리뷰를 올릴예정인데 클린코드가 굉장히 두꺼워서 이번주 안에 다 볼수있을지 어떨지.. -Seoul.js Lightning Talk 세미나에 참석자로 참가했다. 굉장한 고수분들이 많으셨다! 그 분들이 하는 발표내용을 신입 백엔드 개발자인 내가 이해하긴 어려웠지만 굉장히 자극이 되었다. 신입인 내가 가도 되는걸까 고민을 많이 했지만, 막상 가니 다양한 JavaScript 프레임워크에 대해서 알 수 있어서 너무 좋았다. 게다가 취업준비할때 어떤 개발자님의 자료들에 많은 도움을 받았었는데, 그 개발자님을 실제로 만나게 돼서 굉장히 감동이었다.. 갔다오고 나니 TypeScript에 관심이 생겨 다음주부터 관련 강좌를 가볍게 조금씩 볼 예정이다. 볼 강좌는 타입스크립트 코리아 : 기초 세미나","categories":[{"name":"Logs","slug":"Logs","permalink":"https://sehajyang.github.io/categories/Logs/"}],"tags":[{"name":"weekly","slug":"weekly","permalink":"https://sehajyang.github.io/tags/weekly/"}]},{"title":"빠르고 쉽게 AWS에 웹 어플리케이션 배포하기","slug":"2018-07-17-deploying-java-applications-on-aws","date":"2018-07-16T15:00:00.000Z","updated":"2019-07-15T14:11:55.557Z","comments":true,"path":"2018/07/17/2018-07-17-deploying-java-applications-on-aws/","link":"","permalink":"https://sehajyang.github.io/2018/07/17/2018-07-17-deploying-java-applications-on-aws/","excerpt":"","text":"목차 RDS 생성 및 세팅 sqldeveloper에 RDS 계정 연결 및 테이블 구성 EC2 생성 및 세팅 java 및 tomcat 설치 war 파일 배포 사용하는 프로그램Sql Developer, Putty, Eclipse, FileZila 시작하기 전 AWS 계정이 있고, 사용하는 프로그램이 미리 설치 되어 있다고 가정합니다. EC2 생성 및 세팅EC2 생성 서비스 항목에 들어가면 위와 같은 화면을 볼 수 있는데우리가 이 중 사용할건 컴퓨팅의 EC2 와 RDS 입니다EC2에는 Tomcat8을 설치할 것이고, RDS에는 oracle를 구성할 것 입니다. EC2를 클릭 후 인스턴스 시작을 누르게 되면 위와같은 화면이 나옵니다 ubuntu를 선택후 프리티어 사용가능 표시가 있는 인스턴스 유형을 선택한 후 검토및 시작을 누릅니다. 7단계로 건너뛰게 됩니다. 새 키 페어 생성을 선택후 이름을 정합니다.그 뒤 키페어 다운로드를 하게 됩니다 ~.pem 이며 분실시 재발급이 되지 않으므로 잘 보관하도록 합시다. 1~2분정도 기다리면 EC2 인스턴스를 사용할 수 있게됩니다. EC2 셋팅만들어진 EC2 인스턴스에 java나 tomcat등을 설치해줘야합니다. puttygen을 실행합니다. Load를 선택후 All file로 탐색해 아까 생성한 새로운 키 페어.pem 파일을 선택합니다. 그 후 Save private key를 선택하고 key.ppk를 저장할 위치 및 이름을 지정합니다. putty 를 실행합니다. HostName에 ubuntu@퍼블릭DNS 를 넣어줍시다. 퍼블릭DNS 는 인스턴스에서 볼 수 있습니다 Port 는 SSH, 22입니다. 왼쪽사이드바 중 Connection &gt; SSH &gt; Auth 를 들어갑니다. Private key file for …의 Browse 에서 아까 생성한 ppk 파일을 넣어줍니다. 초기화면으로 돌아와서 Seved Sessions을 해 접속하기 편하게 저장해두고 Open을 선택합니다. 위와 같은 화면이 뜬다면 성공입니다. Java 및 Tomcat 설치Java 설치계속해서 java와 tomcat을 설치해보도록 하겠습니다. 일단 root 권한으로 접속하겠습니다 1sudo passwd root 패스워드 설정을 합니다 1su 설정한 패스워드를 입력하고 root 권한으로 실행을 합니다. 만약을 대비해 root 권한으로 실행하기보다 sudo를 사용하는 방법이 있는데, 저는 root권한으로 진행하도록 하겠습니다. 1apt-get update 업데이트를 시켜줍니다. EC2 ubuntu 엔 java가 설치되어있지 않기 때문에 java를 설치하겠습니다. 1apt-get install openjdk-8-jre-headless 설치 후 1java -version 으로 설치가 잘 되었는지 확인해봅니다. Tomcat 설치 및 EC2 포트추가1apt-get install tomcat8 톰캣을 설치합니다. 기본 설치 path는 /var/lib/tomcat8 입니다. 8080 포트를 열어주기 위해 네트워크 및 보안&gt; 보안그룹으로 갑니다. 보안그룹 생성을 합니다. 이름 및 설명은 자유입니다. 하는김에 80번과 1521포트도 추가합니다. 보안그룹 변경을 눌러 방금 추가한 보안그룹을 체크 후 보안그룹 할당을 눌러 추가시켜 줍니다. 그 후, 인스턴스를 재시작 후 인스턴스 IPv4 퍼블릭 IP로 접속합니다. 1http://IPv4퍼블릭IP:8080 위와같은 화면이 보인다면 성공입니다.","categories":[{"name":"DevOps","slug":"DevOps","permalink":"https://sehajyang.github.io/categories/DevOps/"}],"tags":[{"name":"AWS","slug":"AWS","permalink":"https://sehajyang.github.io/tags/AWS/"}]},{"title":"Java 정리","slug":"2018-06-20-java","date":"2018-06-19T15:00:00.000Z","updated":"2019-08-02T14:41:53.796Z","comments":true,"path":"2018/06/20/2018-06-20-java/","link":"","permalink":"https://sehajyang.github.io/2018/06/20/2018-06-20-java/","excerpt":"","text":"1. Java 란객체지향(OPP) 프로그래밍 언어 JVM 을 이용(운영체제에 독립적). 자바에서 컴파일 시 바이트코드(.class)로 출력되며 그 바이트코드는 기계코드로 변경되어 실행된다. 자동으로 메모리 관리(Garbage collector)를 해준다. 다중 쓰레드를 제공한다. C언어와의 차이점 C 하드웨어를 직접 제어가능하다. 절차지향 구조화된 프로그램 개발이 가능하다. java 중간코드(바이트코드)를 생성해 어느 플랫폼이나 사용 가능하다. 객체지향 C언어에 비해 메모리와 속도가 느리다(JVM을 사용하기 때문). 2. 객체지향 프로그래밍(Object Oriented Programming)실 생활의 특징을 모델링 해 소프트웨어로 옮겨오는것 객체란 실 생활의 사물에 대한 추상화 한 것이며, 그에 필요한 멤버변수와 메소드를 정의한다. 추상화, 캡슐화,다형성등의 특징이 있다. 이미 작성한 코드에대한 재사용성이 높다( 로직을 라이브러리로 만든다던지). 라이브러리 생성시 버그를 잡기 때문에 버그가 발생할 확률이 낮아진다.(디버깅이 쉽고 유지보수가 용이) 또한 라이브러리가 제공하는 기능을 사용하게되면 생산성 또한 높아진다. 추상화란?굳이 구현할 필요없는 부분을 생략하고 필요한 부분만을 나타내는 것. 다형성이란?하나의 메소드나 클래스가 다양한 방법으로 동작하게하는 요소 단순한 상속이나 인터페이스가 구현이 된 클래스 계층적으로 다단계 상속을 이루고 있는 클래스 여려개의 인터페이스를 한번에 구현한 클래스 등으로 표현된다. Overriding, Overloading 이 있다. Overriding 자식클래스에서 부모클래스 메소드를 재정의한다. super()를 쓰면 부모클래스 메소드를 사용한다. Overloading 같은 이름이지만 매개변수의 종류 및 숫자가 다른 메소드 같은 기능이지만 다른 인자를 수행하는 메소드 정의시 사용. 캡슐화(encapsulation)란?메소드의 기능만 알며, 어떻게 동작하는지는 알필요 없이 사용하는 것 외부에서 변경 불가하게 private로 선언하고 setter getter 메소드를 통해서만 접근 가능하다. =&gt; 무결성을 보장한다. 상속이란?부모클래스의 속성과 메소드를 자식클래스가 물려받아 사용할 수 있는 것. 부모클래스에서 private로 선언시 자식클래스는 상속받아도 사용하지 못한다. 다중상속(extends)이 불가능하므로 interface를 사용해 다중상속을 한다. 3. 자료형(Data type)기본 자료형사용전 선언되어야한다. 생성한 변수에는 하나의 값을 저장한다. call-by-value에 의해 메소드의 인자값을 전달한다. 종류 byte, char, short, int, double, long, float, boolean WrapperClass 기본 데이터타입을 참조자료형으로 만든것(Class 화 한 것) 참조 자료형을 매개변수로 받거나, 객체자료형으로 저장해야하거나 객체간 비교가 필요할 경우 사용 참조 자료형(Reference Data Type)주소값을 저장한다. call-by-reference에 의해 메소드의 인자값을 전달한다. 종류 class, interface, array, enum 명명 규칙 알파벳 대소문자, 숫자, 한글가능. 특수문자 사용 X (예외 : _ $ 가능) 숫자로 시작 불가능하다. 클래스는 대문자로, 메소드와 변수는 소문자로 시작. 합성어의 경우 첫 문자는 대문자로 예약어는 사용 불가능하다. 4. 접근제어자(Access modifire)접근 영역을 제한시 사용한다 선언 생략시 default로 setting 종류 public : 제한없이 사용 가능 default : private + 같은 패키지 내에서 사용가능 protected : default + 상속이면 사용가능 private : 자신의 클래서 내 에서만 사용 가능 5. FrameWork소프트웨어 설계와 구현을 재사용 가능하도록 해주는 뼈대 구체적, 확장 가능한 기반코드를 가지고 설계자의 의도에 따르는 여러 디자인 패턴 집합으로 구성되어있다. 완성된 도구가 아니라는 점에서 라이브러리와 다르다. 6. Collection 종류 List 계열 : AbstractList, ArrayList, LinkedList, Vector Set계열 : AbstractSet, HashSet, LinkedHashSet, TreeSet Map 계열 : AbstractMap, Attributes, HashMap, Hashtable, IdentityHashMap,RenderingHints, TreeMap, WeakHashMap , Properties List 순서가 있다(순차적 데이터 저장). 동일 데이터 중복 가능 데이터 순차 검색시 용이하다. Vector 동기화(Synchronized) ArrayList 동기화 안함 Set 순서 없음. 중복 불가능 순차 접근을 위해 Iterator을 사용한다. Map Key와 Value 형태로 입력 순서 없음, Key값 중복 안됨 특정 데이터 검색시 용이하다. HashMap 데이터 입출력 동기화 안됨, 처리속도 빠름 HashTable 모든 입출력이 동기화(토큰을 부여받아 순차접근)되나 처리속도는 떨어진다. 6. 추상 클래스(Abstract Class)와 인터페이스(Interface)- 추상클래스(abstract)extends이용해 상속을 진행한다. 단일 상속 형태만 정의(미완성 메소드)함으로 자식클래스에선 미완성 메소드를 재정의 해야한다. - 인터페이스(interface)implements 를 이용해 상속을 진행한다. 다중 상속 추상클래스보다 추상화 정도가 높다. 기능의 재정의에 큰 의미를 둔다 상수와 추상 메소드만 선언 가능하다. 자식클래스에서 반드시 메소드를 재정의(overriding) 해야한다 7. 쓰레드(Thread)프로세스내에서 동시에 실행되는 독립적인 실행 단위 쓰레드는 각자의 스택 메모리영역을 갖고있으며 다른 쓰레드들과 전역 메모리를 공유한다. 특징자원을 많이 사용하지않고 구현이 쉬우며 범용성이 높다. 구현방법(2가지) Thread 클래스를 상속받는다. Runnable interface를 상속받아 run 메소드 재정의 Thread의 동기화(synchronized)와 데드락(deadlock) synchronized 2개이상 쓰래드가 공유자원에 접근해 값 변경하려 할 수가 있으므로 공유변수에 synchronized를 사용해야한다. synchronized를 사용하면 하나의 쓰레드가 공유자원 점유시 타 쓰레드가 대기상태에 머문다. deadlock 두 쓰레드가 서로 공유변수에 lock걸고 작업중 서로의 것에 필요한 코드가 있으나 각자 선점중이므로 둘다 대기상태에 계속 머무르게 되는 현상 망에선 사용 가능한 버퍼가 없어 노드들이 패킷을 전송할 수 없는 상태이다. process와의 차이점쓰레드와 달리 프로세스는 자기자신의 메모리 영역을 가진다. 자원쓰기시 복사(copy on write) 방식으로 자식프로레스에게 복사하여 사용하는 방식이다. thread에 비해 느린 수행능력을 보여준다. Thread 사용여부지나친 다중화는 각 스레드를 스케줄링하는데에 대부분의 CPU 타임을 소모하며 Thrashing과 같은 문제가 생길 수 있다. 각 스레드는 다른 스레드가 끝날 때까지 대기상태에 있기 때문에 병행적이지 않은 프로그램은 더 느려지고 복잡해질 수 있다. 사용해야하는 예병렬적으로 다수의 작업을 수행하며 다중프로세서 하드웨어등에서 동작하는 프로그램 중복될 수 있는 많은 입출력을 수행하는 프로그램 8. JVM 메모리 구조class, stack, heap, native 메소드, PC 레지스터로 구성되어있다. Class 영역프레임(호출된 메소드를 위한 공간)이 생성되어 각종 값이 임시로 저장된다 메소드 실행 종료시 프레임삭제가 진행된다. heap 영역new 로 생성된 객체와 배열이 저장된다. permanent geration, new, old 영역으로 나뉜다. permanent geration = 객체의 주소값 저장 new eden = 객체 최초 생성영역 survivor = 참조되는 객체 저장 영역 old = new영역에서 참조되고있는 객체 저장공간 native 메소드 영역자바 외 타 언어에서 제공되는 메소드가 저장 PC 레지스터 영역쓰레드 생성시 생성되는 영역 쓰레드의 현재 실행되는 부분의 명령 및 주소를 실행할지 저장 9. Garbage Colloetiongarbage를 회수해 사용할 수 있는 메모리공간을 늘리는 것 garbage collector가 수행 JVM이 자동 실행해주지만 System.gc() 로 수동으로도 가비지 컬랙션을 요청할 수 있다. 10. NIO(new input-output)자바 IO(input-output)의 단점을 보완한 새로운 IO 패키지 기존의 모든 IO에 대해 쓰레드를 생성하는 방식이 아닌 채널관리자(selector)를 사용해 실제 IO가 발생한 채널만 쓰레드를 생성해 관리. 하지만 기존의 다중쓰레드 이용한 방식보다 구현하기 어렵다. 참고JongMin Kim님 repository HanjaeYeop님 reposiroty","categories":[{"name":"Java","slug":"Java","permalink":"https://sehajyang.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://sehajyang.github.io/tags/Java/"}]}]}