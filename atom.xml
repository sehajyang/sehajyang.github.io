<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Seha&#39;s Devlog</title>
    <link>https://sehajyang.github.io/</link>
    <atom:link href="/atom.xml" rel="self" type="application/rss+xml"/>
    
    <description>Junior Developer</description>
    <pubDate>Mon, 03 Feb 2020 12:04:36 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>2020년 1월 중순 회고</title>
      <link>https://sehajyang.github.io/2020/01/22/200101-200112/</link>
      <guid>https://sehajyang.github.io/2020/01/22/200101-200112/</guid>
      <pubDate>Wed, 22 Jan 2020 05:36:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;2019년 연간회고 이후 올해의 첫 회고를 작성하게 되었다.&lt;br&gt;이번달은 설 연휴가 껴서 그냥 1월 중순 회고를 작성하기로 했다.&lt;br&gt;3주간 주로 알고리즘 스터디를 중점적으로 했다. 알고리즘은 시간 있을때 틈틈히 해두는게 재밌고 좋은 것 같다.&lt;br&gt;그 밖엔 AWS re:invent 컨퍼런스에 갔다왔다.&lt;/p&gt;
&lt;h2 id=&quot;3주간-한-학습-및-개발&quot;&gt;&lt;a href=&quot;#3주간-한-학습-및-개발&quot; class=&quot;headerlink&quot; title=&quot;3주간 한 학습 및 개발&quot;&gt;&lt;/a&gt;3주간 한 학습 및 개발&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;알고리즘 스터디&lt;/li&gt;
&lt;li&gt;7가지 동시성모델&lt;/li&gt;
&lt;li&gt;AWS korea
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>2019년 연간회고 이후 올해의 첫 회고를 작성하게 되었다.<br>이번달은 설 연휴가 껴서 그냥 1월 중순 회고를 작성하기로 했다.<br>3주간 주로 알고리즘 스터디를 중점적으로 했다. 알고리즘은 시간 있을때 틈틈히 해두는게 재밌고 좋은 것 같다.<br>그 밖엔 AWS re:invent 컨퍼런스에 갔다왔다.</p><h2 id="3주간-한-학습-및-개발"><a href="#3주간-한-학습-및-개발" class="headerlink" title="3주간 한 학습 및 개발"></a>3주간 한 학습 및 개발</h2><ul><li>알고리즘 스터디</li><li>7가지 동시성모델</li><li>AWS korea community day re:invent 컨퍼런스 참석</li></ul><h3 id="알고리즘-스터디"><a href="#알고리즘-스터디" class="headerlink" title="알고리즘 스터디"></a>알고리즘 스터디</h3><p>요즘 친한 동료분들과 알고리즘 스터디를 하고 있고 시작한지는 2주 조금 넘었다.<br>강의는 저번에 완강하지 못한 <a href="https://code.plus/course/32" target="_blank" rel="noopener">SW 역량 테스트 준비 - 기초</a> 로 하고 있다.<br>과거에 여러가지 스터디를 만들어도 보고 참여도 해봤는데 가장 효율이 좋았고 참여율이 높았던건 매 주 과제 + 발표 였다.<br>그래서 알고리즘 스터디는 다음과 같이 진행하고 있다.</p><ol><li>저번주에 선정한 문제(5개, 백준 실버 중위 ~ 골드 상위) 코드리뷰 및 문제 해결방법 설명</li><li>이번주 강의 수강</li><li>다음주에 풀 문제 선정</li><li><a href="https://github.com/herren-algorithm-study/algorithm-basic" target="_blank" rel="noopener">알고리즘 레포</a>에 다음주 스터디 전 까지 푼 문제에 대한 소스코드 푸쉬 </li></ol><p>문제 난이도가 점점 올라가고 있어 평일에도 성실히 풀어야 모든 문제를 다 풀 수 있다(더 이상은 몰아서 푸는게 안된다..)<br>1주차 문제중 <a href="https://www.acmicpc.net/problem/6588" target="_blank" rel="noopener">골드바흐의 추측</a> 문제의 시간초과 때문에 조금 고생하고 있었는데, 같이 스터디하시는분이 알고리즘 문제는 보통 시간 제한은 빡빡한데 공간제약은 굉장히 널널하다는 얘길 해주셨고 그말에 힌트를 얻어 쉽게 해결할 수 있었다. 앞으로 이 꿀팁을 자주 써먹어야겠다.<br>2주차 문제중엔 <a href="https://www.acmicpc.net/problem/1072" target="_blank" rel="noopener">게임</a> 이라는 문제가 있었는데, 후에 할 게임을 모두 이겼다고 가정했을시, 몇판을 이겨야 승률이 변하는지를 출력하면 되는 문제였다.<br>문제를 처음봤을땐 쉬울 것 같고, 제한이 10억이라 바이너리 서치로 풀어야겠다 라고 생각했는데 내가 뭘 잘못했는지 모르겠지만 잘 되지 않았다(지금 생각해보면 아마 부동소수점 오차 문제 떄문이었을 것이라 생각된다)<br>당황해서 수학으로 풀어야지 하면서 식을 세웠는데 식을 잘못 세워서 고생을 좀 했다.<br>3주차는 2주차에 못푼 문제와 3주차에 선정한 문제들을 설 연휴동안 풀 예정이다. 알고리즘 혼자할땐 힘들고 어려웠는데, 다같이 하니까 너무 재밌다. 특히 서로서로 어떻게 짰고 어떻게 접근했나를 얘기하며 코드를 보는게 재밌었다.<br>다들 너무 잘하시고, 나한텐 난이도가 조금 높은 것 같지만 그래도 지금 이정도 난이도가 딱 좋은 것 같다. </p><h3 id="7가지-동시성모델"><a href="#7가지-동시성모델" class="headerlink" title="7가지 동시성모델"></a>7가지 동시성모델</h3><p>과거에 보다 만 책을 다시 폈다. 그때는 그냥 보기만 하고 예제를 직접 쳐보진 않았었는데 역시 이런 책은 직접 코드를 쳐봐야 하는 것 같다.<br>저번 akka 프로젝트는 너무 별로였던지라 제대로 akka로 토이프로젝트 하나 만들고 싶어서 액터모델부터 다시 보려고 폈다가 그냥 처음부터 보고 있다.<br>옛날에 나온 책이지만 정말 내용이 괜찮다. 중간에 알고리즘 문제 때문에 일시중지 되었지만 연휴에 바짝 볼 생각을 하고있다.</p><h3 id="AWS-re-invent-컨퍼런스-참석"><a href="#AWS-re-invent-컨퍼런스-참석" class="headerlink" title="AWS re:invent 컨퍼런스 참석"></a>AWS re:invent 컨퍼런스 참석</h3><p>가장 처음 세션 C 트랙 beNX에서 발표한 <code>전 세계 팬들이 모일 수 있는 플랫폼 만들기</code> 라는 세션이 정말 좋았다.<br>평소에 분당 2.7만회 정도의 요청이 들어오다 특정 아티스트가 글을 쓰는 순간 분당 270만회로 요청이 뛰어버리는데, 아티스트가 글을 쓰는 시간이 정해져 있지 않다보니 이 이벤트는 불규칙하게 낮에도 새벽에도 발생할 수 있었다.<br>그러한 과정에서 어떻게 하면 효율적이고 빠르고 안정적으로 트래픽을 핸들링할 수 있는지, 그렇게 하려면 어떻게 아키텍쳐를 설계해야 하는지, 서버최적화 설정은 어떻게 해야하는지 등의 아키텍쳐 설계 및 서버 튜닝에 대한 내용이었다. 정말 굉장하고, 유익했다.<br>나는 그간 계속 beNX의 해당 서비스를 사용해왔고 트래픽이 한꺼번에 몰릴때에도 거의 안정적으로 서버가 살아있는 것을 보며 감탄했었다.<br>급격한 트래픽을 대비하는 scalable 아키텍쳐를 어떻게 설계했을지 궁금했었는데 이번에 속 시원히 알 수 있었다. 이 세션에 대해서는 후기 포스팅을 따로 작성할 생각이다.</p><h2 id="다음달에-할-학습"><a href="#다음달에-할-학습" class="headerlink" title="다음달에 할 학습"></a>다음달에 할 학습</h2><ul><li>알고리즘 스터디 계속</li><li>7가지 동시성 모델 </li><li><a href="https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-JPA-API%EA%B0%9C%EB%B0%9C-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94" target="_blank" rel="noopener">스프링 부트와 JPA 활용2 - API 개발과 성능 최적화</a> 수강</li></ul><h2 id="총평"><a href="#총평" class="headerlink" title="총평"></a>총평</h2><p>알고리즘을 즐겁게 할 수 있어서 알고리즘을 푸는데에 집중한 주 였다.<br>확실히 작년보다 알고리즘을 더 잘 풀수 있게 되었다. 아직 많이 부족하지만 이렇게 일주일에 5문제씩 꾸준히 풀면 연말 즈음에는 정말 알고리즘을 잘 풀수 있게 되지 않을까 싶다.<br>AWS 컨퍼런스는 정말 좋았다. 발표자분들이 준비를 많이 한 티가 많이 났던 것 같다 그만큼 내용도 정말 좋아서 새롭게 알게된것도 많았다.<br>그리고 나는 1년 2개월간의 즐거웠던 헤렌에서의 회사생활을 마치고 다른 회사로 가게 되었다. 그간 또래분들이 많아 즐겁게 게임모임도 하고 개발 얘기도 할 수 있었는데 이젠 못 하게 되어 아쉽다..<br>이직을 결정하게 된 이유는 더 깊게 배울 수 있는 기회가 왔다고 생각했기 때문이었다. 이직하는 곳은 지금까지와 마찬가지로 JAVA 및 스프링부트 스택이라, 올해안엔 토비의 스프링을 볼 생각을 하고있다. 하지만 파이썬도 포기할 수 없으니 fluent python도 볼 것이다.</p>]]></content:encoded>
      
      <comments>https://sehajyang.github.io/2020/01/22/200101-200112/#disqus_thread</comments>
    </item>
    
    <item>
      <title>2019년 연간회고</title>
      <link>https://sehajyang.github.io/2019/12/31/2019-review/</link>
      <guid>https://sehajyang.github.io/2019/12/31/2019-review/</guid>
      <pubDate>Tue, 31 Dec 2019 02:48:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;&lt;a href=&quot;https://sehajyang.github.io/2018/12/31/2018-12-31-2018-review/&quot;&gt;2018 연간회고&lt;/a&gt;를 쓴지가 엊그제 같은데 벌써 2019가 끝나가면서 연간회고를 쓰게 되었다.&lt;br&gt;올해 뭐 했지 싶다가도 2018년부터 지금까지 작성해온 회고들을 보니 저때 저런것도 했었지 싶어 꾸준히 회고쓰기 참 잘했다는 생각이 들었다.&lt;br&gt;1년간 중단하지 않고 느리게나마 꾸준히 주간 회고를 작성해왔는데 올해 잘한일 중 하나이다.&lt;br&gt;이번 연간 회고는 2018년에 비해 얼마나 성장했는지, 2019년엔 어떤 기술을 배웠으며 어떤 토이프로젝트를 만들었는지를
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="https://sehajyang.github.io/2018/12/31/2018-12-31-2018-review/">2018 연간회고</a>를 쓴지가 엊그제 같은데 벌써 2019가 끝나가면서 연간회고를 쓰게 되었다.<br>올해 뭐 했지 싶다가도 2018년부터 지금까지 작성해온 회고들을 보니 저때 저런것도 했었지 싶어 꾸준히 회고쓰기 참 잘했다는 생각이 들었다.<br>1년간 중단하지 않고 느리게나마 꾸준히 주간 회고를 작성해왔는데 올해 잘한일 중 하나이다.<br>이번 연간 회고는 2018년에 비해 얼마나 성장했는지, 2019년엔 어떤 기술을 배웠으며 어떤 토이프로젝트를 만들었는지를 작성하려한다.</p><h2 id="2018년에-배운-기술과-지금을-비교해보자"><a href="#2018년에-배운-기술과-지금을-비교해보자" class="headerlink" title="2018년에 배운 기술과 지금을 비교해보자"></a>2018년에 배운 기술과 지금을 비교해보자</h2><ul><li><p>Git, GitHub</p><ul><li>작년엔 Git, Github를 처음 접했었다.</li><li>작년엔 토이프로젝트에서 revert 사고도 치고, conflict도 잘 해결하지 못해 끙끙댔는데 이젠 능숙하게 깃을 다룰 줄 알게되었다.</li><li>이젠 동료분들에게 깃 관련 문제가 생길때 마다 용병(?)갈 정도로 능숙해져 뿌듯하다. </li></ul></li><li><p>GitHub Blog</p><ul><li>작년엔 jekyll을 이용해 깃허브 블로그를 처음 만들었었고 그로인한 많은 시행착오와 삽질이 있었다. 특히 jekyll theme를 포크떠서 시작하는경우 기존의 디자인을 깨트리지 않으면서 원하는 기능(사이드 바 등)을 넣기가 어려웠다.<br>그러던 차에 <a href="https://sehajyang.github.io/2019/06/25/190529-190625/">우연히 hexo를 발견하게 되었다</a>. 지금은 hexo로 갈아탔다.</li><li>지금 블로그는 마음에 들며, 앞으로 딱히 바꾸지 않을 것 같다.</li><li>올해 <a href="https://herrenofficial.github.io/" target="_blank" rel="noopener">회사 기술블로그</a>를 만들었다. jekyll로 깃허브 블로그를 만들었는데 오픈까지 대략 하루~이틀정도 걸렸던 것 같다.<br>과거에 해뒀던 삽질들 덕분에 이번엔 빠르고 쉽게 구축할 수 있었다.</li></ul></li><li><p>React</p><ul><li>난 더이상 리액트 공부를 하지 않는다. 프론트에 별 관심이 없어졌기 때문이다. </li><li>프론트가 나와 맞는지 아닌지 알아내기 위해 조금이나마 Vue도 해보고 리액트도 해보고 심지어 리액트 네이티브도 하는 등 조금씩 공부해봤지만 나와는 별로 맞지 않았던 것 같다. 나는 백엔드가 재밌다. 그래서 리액트는 더이상 하지 않는다.</li></ul></li><li><p>CI/CD</p><ul><li>작년엔 jenkins로 처음으로 CI/CD를 구축했었다. 자동배포라니!</li><li>올해는 회사에 Jenkins로 자동배포환경을 만들었다. 작년의 경험이 있어 올해는 회사에서 쉽게 구축할 수 있었다.</li><li>또한 TravisCI, Gitlab CI, AWS CI/CD(aws code commit부터 deploy까지)를 이용한 자동배포 구축등 이제 왠만한 CI/CD 구축 및 설정을 무리없이 할수있게 되었다.</li></ul></li></ul><p>2018년에 배웠던 기술들은 올해 더욱 능숙해졌다. 1년뒤 2020년 회고를 쓸때 2019년에 배운 기술에 비해 더 많이 발전했다고 쓸 수 있으면 좋겠다.</p><h2 id="2019년에-배운-기술"><a href="#2019년에-배운-기술" class="headerlink" title="2019년에 배운 기술"></a>2019년에 배운 기술</h2><h3 id="클린코드"><a href="#클린코드" class="headerlink" title="클린코드"></a>클린코드</h3><p>클린코드를 읽었다. 그간 구현에 급급했는데. 이 책을 읽고 더 나은 네이밍, 아키텍쳐, 가독성을 고려하게 되었으며 테스트코드를 작성하기 시작했다.<br>이 책은 내 코딩스타일을 완전히 바꿔놓았다. 그 이후로 나는 주위 동료 개발자들에게 이 책을 추천하고 다녔다.<br>약간 책 홍보같은데.. 그정도로 나한텐 좋은 책이었다. 이 주제로 사내 스터디에서 발표도 했다 <a href="https://www.slideshare.net/herrenstudy/tdd-142039199" target="_blank" rel="noopener">[클린코드와 TDD]</a>  </p><h3 id="TDD와-테스트코드"><a href="#TDD와-테스트코드" class="headerlink" title="TDD와 테스트코드"></a>TDD와 테스트코드</h3><p>막연하게나마 느껴졌던 TDD를 클린코드를 읽고 시작하게 되었었다.<br>처음엔 자료가 적어 구글링을 하거나 책을 보며 서툴게나마 시작했는데 지금은 능숙 까진 아니여도 무리없이 테스트코드를 짤수 있게 되었다.<br>그 과정에서 groovy의 테스트 프레임워크인 spock로 BDD를 해보기도 하고 테스트코드 작성에 관한 포스팅을 작성하기도 했다.<br>처음엔 어떻게 짜야할지 몰라서 무작정 작성했다. 애초에 테스트를 하려면 테스트대상을 리팩토링해야 하는데 그래야하는 줄 몰라서 엄청 고생했었다.<br>레거시를 리팩토링해 나가면서 기능별로 테스트코드를 작성하다보니 지금은 어떤 기능을 어떻게 테스트할건지, 이 기능을 테스트하려면 어느부분을 mocking하고 어느부분을 assert 해야되는지를 조금 알게 되었다. 그렇게 프로덕션에 테스트코드 통합 커버리지 80퍼센트를 달성하게 되었다.<br>우아한형제들에서 진행한 DDD교육에선 기능 구현을 위해 무조건 테스트코드를 짜야 했는데 다른 사람이 짠 테스트코드를 보면서 많이 배울수 있었다.  </p><h3 id="서버리스"><a href="#서버리스" class="headerlink" title="서버리스"></a>서버리스</h3><p>사내 레거시 문자시스템을 서버리스로 분리 및 구축했다. 어떻게 하면 정확한시간에 병목없이 대량 문자를 발송할수 있는지에 대한 고민을 많이 했는데, 그 과정에서 고려한게 MQ, SQS와 람다였다.<br>그 당시에 나는 MQ를 이용한 개발도, 서버리스 환경도 경험이 많지 않았는데 설상가상으로 구글링해봐도 관련 자료가 많지 않았다.<br>그래서 구축할때 굉장히 힘들었었다. <a href="https://sehajyang.github.io/2019/10/10/190903-191006/">[그때 당시의 포스팅1]</a> <a href="https://sehajyang.github.io/2019/10/28/191007-191027/">[포스팅2]</a><br>그 뒤에도 운영단계에서 몇번 터졌지만 지금은 안정적으로 처리할 수 있도록 구축해뒀다.<br>구축하느라 정말 힘들었지만 안정화가 되면서 터지지도 병목이 생기지도 않아서 지금은 서버리스로 바꾸길 잘했다는 생각을 하고있다.<br>이후에 이 구축기를 get started 격의 포스팅으로 만들었다 <a href="https://sehajyang.github.io/2019/09/25/sqs-lambda-python/#more">[SQS, Lambda를 이용해 문자전송하기(1부)]</a></p><h3 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h3><p>스칼라를 배웠다. 그냥 함수형 해보고싶어서 언어를 고르는데 스칼라가 좋았다. 그 과정에서 <a href="https://sehajyang.github.io/2019/07/02/scala-vs-kotlin/">Scala vs Kotlin</a> 같은 포스팅을 작성하기도 했다.<br>학습은 마틴오더스키-Programming in Scala 책과 코세라 강의 그리고 scala-exercise 사이트로 했다. scala-exercise 의 튜토리얼은 마틴오더스키님의 강의자료인데 번역이 되어있지 않아 겸사겸사 번역을 했다.<a href="https://sehajyang.github.io/tags/scala-exercises/">[번역 리스트]</a><br>총 15개의 챕터중 8개를 번역해뒀으며 나머지는 내년 상반기안에 끝낼 생각을 하고있다.<br>스칼라는 듣던대로 어려웠다. 문법익히는 것 부터 어려워서 code wars등을 풀거나 자바코드를 스칼라 코드로 포팅하는 식으로 문법을 익혔다.<br>사내에서 쓸 환경변수를 관리하는 S3 파일 서빙 서버도 만들었는데 그땐 akka-http로 만들었다(그리고 어려웠다) 아직 미숙하지만 2020년엔 좀 더 능숙해졌으면 좋겠다.</p><h3 id="비동기"><a href="#비동기" class="headerlink" title="비동기"></a>비동기</h3><p>올해초에 비동기를 접하게 됐다. <a href="https://sehajyang.github.io/2019/04/17/2019-04-17-basic-of-asynchronous/">비동기 기초 정리</a><br>파이썬 asyncio등의 공식문서를 보며 공부했는데 도움이 많이 됐다. 특히 <a href="http://www.hanbit.co.kr/store/books/look.php?p_code=B3745244799" target="_blank" rel="noopener">7가지 동시성 모델</a> 이란 책이 좋았다.<br>그렇게 회사에서 오래걸리는 작업들을 처리하던 파이썬 스크립트들을 asyncio로 리팩토링하면서 소요시간을 대폭 줄일 수 있었다.<br>비동기 프레임워크를 사용해 <a href="https://github.com/sehajyang/sanic-chatting-project" target="_blank" rel="noopener">[sanic-chatting-project]</a><a href="https://github.com/sehajyang/real-time-ws-pubsub-baas-api" target="_blank" rel="noopener">[real-time-ws-pubsub-baas-api]</a> 등의 토이프로젝트를 하기도 했다.  </p><h3 id="오픈소스-컨트리뷰트"><a href="#오픈소스-컨트리뷰트" class="headerlink" title="오픈소스 컨트리뷰트"></a>오픈소스 컨트리뷰트</h3><p>hexo 프레임워크의 rss 관련해 첫 컨트리뷰트를 했다 <a href="https://github.com/hexojs/hexo-generator-feed/pull/102" target="_blank" rel="noopener">[fix : add feed icon to rss2.xml #102]</a><br>그냥 rss에 이미지를 넣고싶어서 해당 파일 수정 후 풀리퀘를 날렸는데 해당 부분을 수정하면서 발생하는 문제들이 있어 생각보다 신경써야할 부분이 많았다. 그러나 엄격한(?) 스택오버플로우와는 달리 깃허브는 조금 더 친절한 분위기였다. 나는 JS를 잘 못하지만 친절한 hexo 컨트리뷰터 및 오거나이져분들의 도움으로 무사히 작성 후 merge 될 수 있었다.  </p><h3 id="크롤링"><a href="#크롤링" class="headerlink" title="크롤링"></a>크롤링</h3><p>크롤링 고수이신 지인분께 크롤링 과외를 받았다. 특히 패킷까보면서 하니 신세계였다. 그렇게 크롤링을 할 수 있게 됨에 따라 회사에서도 크롤링을 참 많이 하게되었다.. 직접적으로 일상생활에(나에게) 도움이 되는 것들을 많이 만들었는데, 대략 세미나나 콘서트 자리나면 알려줌 이라던가 무료게임이나 날씨정보를 주기적으로 보내준다거나 비행기등의 최저가가 뜨면 알려준다거나하는 것들을 만들었다. 내년에도 이것저것 크롤링해서 소소하게 도움이되는 것들을 만들 것 같다.</p><h2 id="2019년에-진행한-토이프로젝트"><a href="#2019년에-진행한-토이프로젝트" class="headerlink" title="2019년에 진행한 토이프로젝트"></a>2019년에 진행한 토이프로젝트</h2><h3 id="sanic-chatting-project"><a href="#sanic-chatting-project" class="headerlink" title="sanic chatting project"></a><a href="https://github.com/sehajyang/sanic-chatting-project" target="_blank" rel="noopener">sanic chatting project</a></h3><p><code>python</code>의 sanic 프레임워크로 만든 채팅 서버이다. 비동기 학습 후 처음 만든 비동기 채팅서버인데 채팅서버다 보니 DB부터 신중하게 찾아보며 골랐다.<br><code>asyncio-redis</code> 라이브러리의 문서가 빈약해 고생하긴 했지만 여차저차 구축할 수 있었다.<br>api document도 만들고.. 여러모로 신경을 좀 쓴 프로젝트였다. </p><h3 id="real-time-ws-pubsub-baas-api"><a href="#real-time-ws-pubsub-baas-api" class="headerlink" title="real time ws pubsub baas api"></a><a href="https://github.com/sehajyang/real-time-ws-pubsub-baas-api" target="_blank" rel="noopener">real time ws pubsub baas api</a></h3><p>Amazon에서 주최한 Amathon에서 <code>python</code>으로 만들었던 프로젝트이다. <a href="https://sehajyang.github.io/2019/09/02/190805-190902/#more">Amathon 참가 포스팅</a><br>우리조 주제는 websocket 기반의 스케일아웃 고려한 real time Pub/Sub Baas였고 python asyncio + sanic + redis + zeroMQ 등을 썼었다.<br><img src="https://i.imgur.com/RmU89wV.png" alt><br>구조는 이러했다. 내 생각엔 beanstalk 같은 scalable 한 서비스를 만들어 beanstalk을 대체했어야 할 것 같았는데 시간이 촉박해 그러진 못했다(그리고 그부분이 가장 어렵다) 다른 조 주제도 재미있는게 많았고 내년에 또 열린다면 참가할 것 같다.</p><h3 id="racoon-man"><a href="#racoon-man" class="headerlink" title="racoon man"></a><a href="https://github.com/sehajyang/racoon-man" target="_blank" rel="noopener">racoon man</a></h3><p>너굴맨 이라는 슬랙봇 이다. <code>python</code> 으로 만들었으며 심심할때마다 기능을 조금씩 붙여 지금은 굉장히 거대해졌다.<br>9XD의 <a href="https://github.com/item4/yui" target="_blank" rel="noopener">유이</a> 라는 슬랙봇에서 아이디어를 얻었으며 회사 개발자들의 소소한 유희(?)을 위해 만들었다.<br>지금은 동료분들의 많은 사랑을 받고 있다.<br><img src="https://i.imgur.com/Y039CX1.png" alt></p><p>너굴맨에는 다음과 같은 기능이 있다.  </p><ul><li>날씨 및 미세먼지, 한강수온, 현재 비 오는지 여부 알림</li><li>랜덤 골라줌, 로또 번호 골라줌, 점심 및 저녁추천</li><li>한영 번역 기능</li><li>festa 세미나, 오늘의 운세 알림 기능</li><li>일정 기억 기능</li><li>소라고동 기능</li><li><a href="https://pingpong.us/" target="_blank" rel="noopener">pingpong 챗봇</a> api를 붙여 사람같이 대답하는 기능</li><li>기타등등 등록해둔 대답 셋</li></ul><h3 id="simple-anonymous-board"><a href="#simple-anonymous-board" class="headerlink" title="simple anonymous board"></a><a href="https://github.com/sehajyang/simple-anonymous-board" target="_blank" rel="noopener">simple anonymous board</a></h3><p>java의 springboot로 사내 익명게시판을 만들었었다.<br>github project로 일정관리부터 문서까지 만들었으며, 사용하고 싶은 기술을 많이 사용해서 재밌었다.<br>특히 프론트는 handlebars 를 사용했는데, 어려웠지만 커스텀 함수를 쉽게 만들 수 있어 개인적으로 thymeleaf 보다 좋았다.</p><h3 id="angelcell-admin"><a href="#angelcell-admin" class="headerlink" title="angelcell admin"></a><a href="https://github.com/sehajyang/angelcell-admin" target="_blank" rel="noopener">angelcell admin</a></h3><p>이 프로젝트는 <a href="https://www.hackathon.io/connectus3" target="_blank" rel="noopener">AngelHack 2019 Seoul</a> 해커톤 에서 만든 커넥터스라는 서비스의 모니터링 서버인데, springboot로 만들었다.<br><a href="https://sehajyang.github.io/2019/06/13/2019-06-13-angelhack-2019-seoul-win-review/">후기 포스팅</a>을 작성했었다.<br>해커톤에서 스프링부트로 개발하는건 좀 아닌것 같다는 생각이 들었었다. 설정잡는데에 꽤 시간이 걸렸으며 자바 자체도 보일러플레이트가 많은 언어라 짧은 시간에 많은 코드를 작성하느라 많이 힘들었었다.  </p><h2 id="역시-해커톤은-파이썬인-것-같다"><a href="#역시-해커톤은-파이썬인-것-같다" class="headerlink" title="역시 해커톤은 파이썬인 것 같다.  "></a>역시 해커톤은 파이썬인 것 같다.  </h2><p>올해는 토이프로젝트를 하기보단 그냥 자잘한 스크립트나 학습위주로 해서 만든 토이프로젝트가 적을 줄 알았는데, 모아보니 생각보다 많은 것 같다.<br>내년엔 보안관련 C 오픈소스 프로젝트를 만들 생각을 하고 있다. 아마 내가 여지껏 한 프로젝트중 가장 어렵고 가장 괜찮은 프로젝트가 될 것이다. </p><h2 id="2019년에-참석한-세미나-및-해커톤"><a href="#2019년에-참석한-세미나-및-해커톤" class="headerlink" title="2019년에 참석한 세미나 및 해커톤"></a>2019년에 참석한 세미나 및 해커톤</h2><p>다음은 2019년도에 참석한 세미나 및 해커톤 리스트이다.  </p><ul><li>191127 <a href="https://edu.nextstep.camp/c/GwN2MSqv/" target="_blank" rel="noopener">우아한 테크 러닝 - DDD 세레나데 교육</a></li><li>191028 <a href="https://festa.io/events/621" target="_blank" rel="noopener">스포카 크리에이터 컨퍼런스: Hello World!</a></li><li>190926 <a href="https://jojoldu.tistory.com/451?category=635883" target="_blank" rel="noopener">우아한 테크 세미나 - 우아한 스프링배치 참가</a></li><li>190901 <a href="https://amathon.ga/" target="_blank" rel="noopener">Amathon 2019 참가</a></li><li>190824 <a href="https://festa.io/events/413" target="_blank" rel="noopener">뱅크샐러드 컨퍼런스 Con-Salad 05</a></li><li>190817 <a href="https://www.pycon.kr/" target="_blank" rel="noopener">Pycon Korea 2019 양일 참석</a></li><li>190807 <a href="https://www.meetup.com/ko-KR/awskrug/events/263382980/" target="_blank" rel="noopener">AWSKRUG GraphQL모임</a></li><li>190630 <a href="https://festa.io/events/299" target="_blank" rel="noopener">I/O Extended 2019 Seoul</a></li><li>190602 <a href="https://event-us.kr/angelhackseoul/event/7465" target="_blank" rel="noopener">AngelHackaton Seoul 2019</a></li><li>190427 <a href="https://www.springcamp.io/2019" target="_blank" rel="noopener">Spring camp 2019</a></li><li>190316 <a href="https://festa.io/events/212" target="_blank" rel="noopener">코무-프론트엔드와 무관합니다만,</a></li><li>190223 <a href="https://kcd2019.festa.io/" target="_blank" rel="noopener">KCD(Korea Community Day) 2019</a></li></ul><p>하나하나 정리를 하려 했지만 내용이 너무 많아지며, 주간회고에서 한차례 정리를 했었기 때문에 연간회고에서 따로 정리하진 않으려 한다.<br>주로 페스타나 밋업 혹은 동료분들의 영업 으로 종종 세미나나 밋업에 참석하는데 올해 가장 기억에 남는 세미나는 KCD와 파이콘이었다.<br>KCD는 스칼라를 시작하게되는 계기가 되었으며 파이콘은 즐거웠어서 기억에 남는다.   </p><h2 id="2019-총평"><a href="#2019-총평" class="headerlink" title="2019 총평"></a>2019 총평</h2><p>올해는 꾸준히 주간회고를 쓰며 많은 학습을 한 해였다 포스팅은 올해 45개를 작성했다. 이 부분이 가장 뿌듯하다.<br>퇴근 후 나태해지거나 슬럼프가 오기도 했는데, 그럼에도 불구하고 모아보니 한게 꽤 돼서 놀랐다.<br>내년엔 좀더 C, 리버싱 등의 로우레벨을 공부할 것이고 파이썬으로 비동기로 짜는것에 좀 더 익숙해질 생각이다.<br>스칼라는 계속 할 것이고 프로덕션의 몇몇 서비스들을 계속 서버리스로 분리해나갈 생각을 하고 있다.<br>실무 기간만 보자면 1년 좀 넘었고 그냥 개발 한 기간은 2년정도 됐는데, 아직까지도 개발은 재밌고 직업 잘 선택한 것 같다는 생각이 든다.<br>내년은 올해보다 더 부지런한 한해가 됐으면 좋겠다.  </p>]]></content:encoded>
      
      <comments>https://sehajyang.github.io/2019/12/31/2019-review/#disqus_thread</comments>
    </item>
    
    <item>
      <title>11~12월 회고</title>
      <link>https://sehajyang.github.io/2019/12/16/191125-191215/</link>
      <guid>https://sehajyang.github.io/2019/12/16/191125-191215/</guid>
      <pubDate>Mon, 16 Dec 2019 01:11:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;11월 24일부터 12월15일까지의 3주간 회고가 됐다.&lt;br&gt;3주간 많은 변화가 있었는데 그 중 가장 큰 이슈는 C를 다시 시작하게 된 것이다.&lt;/p&gt;
&lt;h2 id=&quot;3주간-한-학습-및-개발&quot;&gt;&lt;a href=&quot;#3주간-한-학습-및-개발&quot; class=&quot;headerlink&quot; title=&quot;3주간 한 학습 및 개발&quot;&gt;&lt;/a&gt;3주간 한 학습 및 개발&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://aws.amazon.com/ko/codeguru/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Amazon CodeGuru&lt;/a&gt; 삽질&lt;/li&gt;
&lt;li&gt;C 공부 다시시작&lt;/li&gt;
&lt;li&gt;&lt;a
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>11월 24일부터 12월15일까지의 3주간 회고가 됐다.<br>3주간 많은 변화가 있었는데 그 중 가장 큰 이슈는 C를 다시 시작하게 된 것이다.</p><h2 id="3주간-한-학습-및-개발"><a href="#3주간-한-학습-및-개발" class="headerlink" title="3주간 한 학습 및 개발"></a>3주간 한 학습 및 개발</h2><ul><li><a href="https://aws.amazon.com/ko/codeguru/" target="_blank" rel="noopener">Amazon CodeGuru</a> 삽질</li><li>C 공부 다시시작</li><li><a href="https://edu.nextstep.camp/c/GwN2MSqv/" target="_blank" rel="noopener">우아한 테크 러닝 - DDD 세레나데 교육</a></li><li><a href="http://www.yes24.com/Product/Goods/18249021?Acode=101" target="_blank" rel="noopener">객체지향의 사실과 오해</a></li><li><a href="https://www.onoffmix.com/event/201406" target="_blank" rel="noopener">2019 공개SW 컨트리뷰션 페스티벌</a></li></ul><h2 id="저번-회고때-설정한-목표-달성을-얼마나-했나"><a href="#저번-회고때-설정한-목표-달성을-얼마나-했나" class="headerlink" title="저번 회고때 설정한 목표 달성을 얼마나 했나"></a>저번 회고때 설정한 목표 달성을 얼마나 했나</h2><ul><li><a href="https://edu.nextstep.camp/c/GwN2MSqv/" target="_blank" rel="noopener">우아한 테크 러닝 - DDD 세레나데 교육</a> 계속<ul><li>바빠서 한번 빠졌었지만 계속 하고 있다. 종강은 12월 17일 이다.</li></ul></li><li><a href="http://www.yes24.com/Product/Goods/18249021?Acode=101" target="_blank" rel="noopener">객체지향의 사실과 오해</a> 책 읽기<ul><li>다 읽었다. 객체지향을 처음 배우는 사람이 보면 좋을 책인 것 같다.</li></ul></li><li><a href="http://www.yes24.com/Product/Goods/19040233?scode=032&OzSrank=1" target="_blank" rel="noopener">자바 ORM 표준 JPA 프로그래밍</a><ul><li>이건 읽다가 직접 해보는게 좋을 것 같다고 생각했다.</li></ul></li></ul><h2 id="Amazon-CodeGuru-적용"><a href="#Amazon-CodeGuru-적용" class="headerlink" title="Amazon CodeGuru 적용"></a><a href="https://aws.amazon.com/ko/codeguru/" target="_blank" rel="noopener">Amazon CodeGuru</a> 적용</h2><p><a href="https://aws.amazon.com/ko/codeguru/" target="_blank" rel="noopener">[Amazon CodeGuru]</a>는 이번 2019 AWS re:invent에서 처음 공개된 AI 코드리뷰 서비스이다. 지금은 자바만 가능하다.<br>AWS 내부에선 이걸 주욱 사용하고 있었던 것 같다. 우리 프로젝트에 한번 붙여보라는 팀장님의 말에 붙이려는 시도를 했지만 실패했다.<br>코드그루를 프로젝트에 붙이는 방법은 총 세가지가 있다.  </p><ul><li>깃허브에 공개된 프로젝트를 코드그루에 추가해 풀리퀘 후 해당 쓰레드에서 간편하게 리뷰를 받는다<ul><li>코드가 분석됐다고 콘솔에선 뜨는데 아무런 액션이 발생하지 않았다.  </li></ul></li><li>EC2에 올라간 프로젝트를 코드그루와 연결해 코드그루 콘솔내에서 리뷰를 받아본다<ul><li>IAM에 관련 권한 다 추가했음에도 불구하고 EC2에서 해당 프로젝트를 실행하면, 권한 및 인증이 계속 실패했다는 오류가 발생했다.</li></ul></li><li>aws code commit, code deploy등과 연동해 코드그루 리뷰를 받는다<ul><li>권한 설정하고 쓰레기 코드 추가해서 풀리퀘 보내봤으나 코드그루가 라인 분석만 하고 리뷰를 하진 않았다.</li></ul></li></ul><p>awskrug의 다른 분들도 코드그루가 분석은 하나 리뷰를 달아주지 않는 문제를 겪고계신 것 같다.<br>아직 해외 블로그에도 적용한 사례가 없고 오직 aws 문서밖에 없는 상황인데 여러가지 방법을 시도해봐도 코드리뷰가 달리진 않아서 일단 코드그루를 붙이는 작업은 보류해야할 것 같다.</p><h2 id="C-공부-다시시작"><a href="#C-공부-다시시작" class="headerlink" title="C 공부 다시시작"></a>C 공부 다시시작</h2><p>나는 고등학생때부터 보안에 관심이 있어서 이것저것 했었다<del>(그렇다고 잘하진 못했다)</del> 어쨌든 C를 못하고, 프로그래밍을 못하는 상태로 계속하기엔 한계가 있었다. 학부생 시절엔 <del>전필이라</del> C강의를 들었지만 지금은 좀 까먹었다. 그래서 C 공부를 다시 하기로 했다.<br>레딧에선 C언어 창시자인 데니스리치가 쓴 The C Programming Language(K&amp;R 라고 부른다)를 바이블로 여기지만 추천은 <a href="https://www.amazon.com/C-Programming-Modern-Approach-2nd/dp/0393979504" target="_blank" rel="noopener">K.N. King’s C Programming: A Modern Approach</a>을 한다. 평을 보니 K&amp;R은 꼭 한번 읽어봐야 하지만 초심자에겐 추천하지 않는다. 초심자에겐 C Programming: A Modern Approach 와 Head First in C 를 추천하는 것 같다. 나는 프로그래밍을 처음하는게 아니니 Head First보단 K.N. King’s book이 좋을 것 같았다. 그래서 책은 C Programming: A Modern Approach 을 보려고 했으나 우리나라엔 번역서가 없으며 위키독스에 일부 번역된 번역본이 있었다.<a href="https://wikidocs.net/book/2494" target="_blank" rel="noopener">[링크]</a><br>결론적으로  K.N. King’s C 책을 봐야하는데 번역본이 없어 원서로 볼 바에는 K&amp;R책이 나을 거 같아서 K&amp;R책을 주문해뒀다.<br>리버싱 책도 추천받았다. <a href="http://acornpub.co.kr/book/ida-pro" target="_blank" rel="noopener">The IDA Pro Book</a></p><h2 id="우아한-테크-러닝-DDD-세레나데-교육"><a href="#우아한-테크-러닝-DDD-세레나데-교육" class="headerlink" title="우아한 테크 러닝 - DDD 세레나데 교육"></a><a href="https://edu.nextstep.camp/c/GwN2MSqv/" target="_blank" rel="noopener">우아한 테크 러닝 - DDD 세레나데 교육</a></h2><p>DDD 교육은 어느덧 4주차가 됐다. 그리고 며칠뒤엔 종강이다.<br>개인적으로 가장 큰 수확은 코드리뷰와 같은 요구사항에 대해 다른사람들은 어떻게 구현했나 볼 수 있었던거 였다.<br>그리고 다른사람은 TDD를 어떻게 하는지에 대해 궁금한게 많았는데 이번에 많이 해소되어서 좋았다.</p><h2 id="2019-공개SW-컨트리뷰션-페스티벌"><a href="#2019-공개SW-컨트리뷰션-페스티벌" class="headerlink" title="2019 공개SW 컨트리뷰션 페스티벌"></a><a href="https://www.onoffmix.com/event/201406" target="_blank" rel="noopener">2019 공개SW 컨트리뷰션 페스티벌</a></h2><p>평일에 회사분들과 가게되었다. 레디스 세션의 내용이 굉장히 좋았으며 이 세션 관련해서는 정리해서 포스팅해뒀다.<br><a href="https://sehajyang.github.io/2019/12/11/how-to-operate-redis/#more">[레디스 운영 잘하는 법]</a></p><h2 id="총평"><a href="#총평" class="headerlink" title="총평"></a>총평</h2><p>3주간 새로운 공부도 하고, 세미나도 가는둥 여러가지 시도를 많이 한 주였던 것 같다.<br>이제 슬슬 연말이 다가오고 있어 1년간 무엇을 했나 적어보고 있는데 생각보다 한게 많았다.<br>아무쪼록 내년에는 딥하게 좀더 로우레벨을 공부할 생각을 하고있다.</p>]]></content:encoded>
      
      <comments>https://sehajyang.github.io/2019/12/16/191125-191215/#disqus_thread</comments>
    </item>
    
    <item>
      <title>레디스 운영 잘하는 법</title>
      <link>https://sehajyang.github.io/2019/12/11/how-to-operate-redis/</link>
      <guid>https://sehajyang.github.io/2019/12/11/how-to-operate-redis/</guid>
      <pubDate>Wed, 11 Dec 2019 04:36:48 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;이 포스팅은 지난 12.4일에 있었던&lt;a href=&quot;https://www.onoffmix.com/event/201406&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;KOSSCON&lt;/a&gt;의 &lt;code&gt;강대명님의 레디스 운영 잘하는 법&lt;/code&gt; 을 듣고 발표자료와 발표내용을 종합하여 작성한 포스팅으로 대부분 발표자료에 있는 내용입니다. 글로 보고싶으신 분들 및 세션 내용 정리를 위해 겸사겸사 정리했습니다.  &lt;/p&gt;
&lt;h1 id=&quot;Redis-운영잘하는-법-정리&quot;&gt;&lt;a href=&quot;#Redis-운영잘하는-법-정리&quot; class=&quot;headerlink&quot; title=&quot;Redis 운영잘하는 법
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>이 포스팅은 지난 12.4일에 있었던<a href="https://www.onoffmix.com/event/201406" target="_blank" rel="noopener">KOSSCON</a>의 <code>강대명님의 레디스 운영 잘하는 법</code> 을 듣고 발표자료와 발표내용을 종합하여 작성한 포스팅으로 대부분 발표자료에 있는 내용입니다. 글로 보고싶으신 분들 및 세션 내용 정리를 위해 겸사겸사 정리했습니다.  </p><h1 id="Redis-운영잘하는-법-정리"><a href="#Redis-운영잘하는-법-정리" class="headerlink" title="Redis 운영잘하는 법 정리"></a>Redis 운영잘하는 법 정리</h1><p>발표자료 : <a href="https://www.oss.kr/storage/app/public/festival/track2/2-1.pdf" target="_blank" rel="noopener">PPT링크</a><br>발표자 : 강대명님</p><h2 id="Redis-소개"><a href="#Redis-소개" class="headerlink" title="Redis 소개"></a>Redis 소개</h2><ul><li><code>In Memory</code> data structure store</li><li>오픈소스 </li><li><code>data structure</code> 지원<ul><li>Strings, set, hash, list</li><li>sorted-set(랭킹시스템 할때 좋음)<ul><li>그러나 데이터 100만건 넘어가면 느려짐(초당 백만건 순회)</li></ul></li><li>Hyperlog, bitmap, geospatial index</li><li>Stream</li></ul></li></ul><h2 id="Redis-운영"><a href="#Redis-운영" class="headerlink" title="Redis 운영"></a>Redis 운영</h2><ul><li><p><strong>메모리 관리를 잘하자!</strong> 99.999퍼 중요!</p><ul><li><strong>physical memory 이상을 사용하면 swap 메모리를 사용</strong>하게됨</li><li>swap 사용하면 메모리 page 접근시마다 읽고 쓰기 때문에 엄청 느려짐</li><li>보통 레디스 <strong>갑자기 느려졌다</strong> 하면 이 이유임</li><li>max 메모리를 설정하더라도 이보다 더 사용하게됨(다른 프로세스들도 메모리를 사용하기 때문)</li><li>RSS 값을 모니터링 해야함</li><li><strong>적은 메모리 사용하는 instance 여러개가 안전</strong><ul><li>redis 는 싱글 쓰레드이기 때문</li><li>따라서 여러개의 인스턴스가 좋다</li><li>큰 메모리일시 elastic cache 쓰면 상관없음(걔가 알아서 관리해줌)</li></ul></li><li>메모리 파편화<ul><li>실제로 <strong>메모리 파편화가 많이 발생함</strong></li><li>jemlloc 버전에 따라서 다르게 파편화가 발생<ul><li>jemlloc 4.x 대 부터 메모리 파편화 줄이기 위한 jemalloc에 힌트를 주는 기능이 들어감</li><li>jemlloc 3.x 버전은 used memory 2GB라고 나오지만 실제론 11GB RSS를 사용하는 경우가 자주 발생함</li></ul></li><li>다양한 사이즈를 가지는 데이터보단 유사크기의 데이터를 가지는 경우가 유리함</li></ul></li><li>메모리 부족시?<ul><li>장비 마이그레이션<ul><li>메모리 빡빡하면 마이그레이션중 문제생길수도 있다 넉넉하게 하자</li></ul></li><li>있는 데이터 줄이기<ul><li>특정 데이터를 줄일때 <code>이미 swap 사용중이라면 프로세스 재시작</code> 해야됨 </li></ul></li><li>메모리를 줄이기위한 설정<ul><li>Collection<ul><li>Hash -&gt; HashTable 하나 더 사용</li><li>Sorted Set -&gt; Skiplist와 HashTable 이용</li><li>Set -&gt; HashTable 사용</li><li>위의 자료구조들은 메모리 많이 사용함</li></ul></li><li><strong>Ziplist 이용</strong>  <ul><li>인메모리 특성상 적은 개수(100만개 이하)라면 선형탐색이 정말 빠름</li><li>게다가 ziplist는 기존 자료구조보다 메모리를 적게 먹음!</li><li>그러니 List, hash, sorted set 등을 ziplist로 대체하자<ul><li>hash-max-ziplist-entries, hash-max-ziplist-value</li><li>list-max-ziplist-size, list-max-ziplist-value</li><li>zset-max-ziplist-entries, zset-max-ziplist-value</li></ul></li><li>만약 설정갯수 오버하면 원래 설정 구조로 바뀌게됨(n개 이상이면 원래 hash로 돌아감.. 이런식)</li></ul></li></ul></li></ul></li></ul></li><li><p><strong>O(n) 관련 명령어 조심하자!</strong></p><ul><li>레디스는 싱글 쓰레드<ul><li>레디스는 동시에 여러개의 명령을 처리할 수 <strong>없음</strong> 그러니 오래걸리는 일 시키면 안됨</li><li>단순한 get/set의 경우 초당 10만 TPS 이상 가능</li><li><img src="https://i.imgur.com/EUKUoS4.png" alt></li></ul></li><li>오래걸리는 대표적인 O(N) 명령들<ul><li>KEYS</li><li>FLUSHALL, FLUSHDB</li><li>Delete Collections</li><li>Get All Collections</li></ul></li><li>대표적인 실수 사례<ul><li>Key가 백만개 이상인데 Key 명령을 사용하는 경우</li><li>아이템이 몇만개 든 hash, sorted set, set에서 모든 데이터를 가져오는 경우</li><li>spring security oauth redis tokenStore 문제</li></ul></li><li>대안<ul><li>KEYS -&gt; Scan<ul><li>scan 명령으로 하나의 긴 명령을 짧은 여러번의 명령으로 바꿈</li><li><img src="https://i.imgur.com/fQwo0Fc.png" alt></li></ul></li><li>Collection의 모든 아이템을 가져와야 할때<ul><li>Collection 일부만 가져오거나</li><li>큰 Collection을 작은 여러개의 Collection으로 나눠서 저장</li><li>Userranks -&gt; Userrank1, Userrank2, Userrank3</li><li><strong>개당 몇천개 안쪽으로 저장하는게 좋음</strong> </li></ul></li><li>Spring security oauth RedisTokenStore 이슈<ul><li>스프링 시큐리티 레디스 토큰조회를 O(N) 으로 하고있었음</li><li>100만개 넘어가면 검색/삭제 한번 하는데에 1초씩 걸렸음</li><li>O(N) -&gt; O(1) 로 고쳐짐, 따라서 지금은 괜찮음</li></ul></li></ul></li></ul></li></ul><h2 id="Redis-Replication"><a href="#Redis-Replication" class="headerlink" title="Redis Replication"></a>Redis Replication</h2><ul><li>Async Replication<ul><li>Replication Lag 이 발생할 수 있다.</li></ul></li><li>“Replicaof’(&gt;= 5.0.0) or ‘slaveof’ 명령으로 설정 가능<ul><li>Replicaof hostname port</li></ul></li><li>DBMS로 보면 statement replication가 유사</li><li>Replication 설정 과정<ul><li>Secondary에 replicaof or slaveof 명령을 전달</li><li>Secondary는 Primary에 sync 명령 전달</li><li>Primary는 현재 메모리 상태를 저장하기 위해<ul><li>Fork</li></ul></li><li>Fork 한 프로세서는 현재 메모리 정보를 disk에 dump</li><li>해당 정보를 secondary 에 전달</li><li>Fork 이후의 데이터를 secondary에 계속 전달</li></ul></li><li>Redis Replication 시 주의할 점<ul><li>Replication 과정에서 fork 가 발생하므로 메모리 부족 발생할 수 있다.</li><li>Redis-cli –rdb 명령은 현재 상태의 메모리 스냅샷을 가져오므로 같은 문제를 발생시킴 </li><li>AWS나 클라우드의 Redis는 좀 다르게 구현되어서 좀더 해당 부분이 안정적</li><li>많은 대수의 Redis 서버가 Replica를 두고 있다면<ul><li>네트웍 이슈나, 사람의 작업으로 동시에 replication이 재시도 되도록 하면 문제가 발생할 수 있음.</li><li>ex) 같은 네트웍안에서 30GB를 쓰는 Redis Master 100대 정도가 리플리케이션을 동시에 재시작하면 어떤 일이 벌어질 수 있을까?</li></ul></li></ul></li></ul><h2 id="권장-설정"><a href="#권장-설정" class="headerlink" title="권장 설정"></a>권장 설정</h2><ul><li>redis.conf 권장 설정 Tip<ul><li>Maxclient 설정 50000</li><li>RDB/AOF 설정 off</li><li>특정 commands disable<ul><li>Keys</li><li>AWS의 ElasticCache는 이미 하고 있음.</li></ul></li><li><strong>전체 장애의 90% 이상이 KEYS와 SAVE 설정을 사용해서발생.</strong></li><li>적절한 ziplist 설정</li></ul></li></ul><h2 id="Redis-Cluster"><a href="#Redis-Cluster" class="headerlink" title="Redis Cluster"></a>Redis Cluster</h2><ul><li>Hash 기반으로 Slot 16384 로 구분<ul><li>Hash 알고리즘은 CRC16을 사용</li><li>Slot = crc16(key) % 16384</li><li>Key가 Key{hashkey} 패턴이면 실제 crc16에 hashkey가 사용된다.</li><li>특정 Redis 서버는 이 slot range를 가지고 있고, 데이터 migration은 이 slot 단위의 데이터를 다른 서버로 전달하게 된다.(migrateCommand 이용)</li><li><img src="https://i.imgur.com/qtxegbT.png" alt></li></ul></li><li>Redis Cluster의 장점/단점</li><li>장점<ul><li>자체적인 Primary, Secondary Failover.</li><li>Slot 단위의 데이터 관리.</li></ul></li><li>단점<ul><li>메모리 사용량이 더 많음</li><li>Migration 자체는 관리자가 시점을 결정해야 함.</li><li><strong>Library 구현</strong>이 필요함.</li></ul></li></ul><h2 id="Redis-Failover"><a href="#Redis-Failover" class="headerlink" title="Redis Failover"></a>Redis Failover</h2><ul><li>Coordinator 기반 Failover<ul><li>Zookeeper, etcd, consul 등의 Coordinator 사용</li><li><img src="https://i.imgur.com/D9lXGgY.png" alt></li><li>장점<ul><li>Coordinator 기반으로 설정을 관리한다면 동일한 방식으로 관리가 가능.</li></ul></li><li>단점<ul><li>해당 기능 이용을 위한 개발(라이브러리)이 필요함</li></ul></li></ul></li><li>VIP/DNS 기반 Failover<ul><li>VIP <ul><li><img src="https://i.imgur.com/vNW2yvb.png" alt></li></ul></li><li>DNS<ul><li>아마존은 이 방식을 사용하고 있음 </li><li><img src="https://i.imgur.com/a6RXcWz.png" alt></li></ul></li><li>장점<ul><li>클라이언트에 추가적인 구현이 필요없다.</li><li>VIP 기반은 외부로 서비스를 제공해야 하는 서비스 업자에 유리(예를 들어 클라우드 업체)</li></ul></li><li>단점<ul><li>DNS 기반은 DNS Cache TTL을 관리해야 함.</li><li>사용하는 언어별 DNS 캐싱 정책을 잘 알아야 함</li><li>툴에 따라서 한번 가져온 DNS 정보를 다시 호출 하지 않는 경우도 존재</li></ul></li></ul></li><li>Redis Cluster 의 사용</li></ul><h2 id="모니터링"><a href="#모니터링" class="headerlink" title="모니터링"></a>모니터링</h2><ul><li>Monitoring Factor<ul><li>Redis Info를 통한 정보<ul><li>RSS</li><li>Used Memory</li><li>Connection 수</li><li>초당 처리 요청 수</li></ul></li><li>System<ul><li>CPU</li><li>Disk</li><li>Network rx/tx</li></ul></li></ul></li><li>CPU가 100% 칠 경우<ul><li>처리량이 매우 많다면<ul><li>좀 더 CPU 성능이 좋은 서버로 이전</li><li>실제 CPU 성능에 영향을 받음<ul><li>그러나 단순 get/set은 초당 10만 이상 처리가능</li></ul></li></ul></li><li>O(N) 계열의 특정 명령이 많은 경우.<ul><li>Monitor 명령을 통해 특정 패턴을 파악하는 것이 필요</li><li>Monitor 잘못쓰면 부하로 해당 서버에 더 큰 문제를 일으킬 수도 있음.(짧게 쓰는게 좋음)</li></ul></li></ul></li></ul><h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><ul><li>기본적으로 Redis는 매우 좋은 툴</li><li>그러나 메모리를 빡빡하게 쓸 경우, 관리하기가 어려움<ul><li>32기가 장비라면 24기가 이상 사용하면 장비 증설을 고려하는 것이 좋음.</li></ul></li><li>Write가 Heavy 할 때는 migration도 매우 주의해야함.</li><li>Client-output-buffer-limit 설정이 필요.</li></ul><h2 id="레디스를-캐시로-쓴다면"><a href="#레디스를-캐시로-쓴다면" class="headerlink" title="레디스를 캐시로 쓴다면"></a>레디스를 캐시로 쓴다면</h2><ul><li>Cache 일 경우는 문제가 적게 발생<ul><li>Redis 가 문제가 있을 때 DB등의 부하가 어느정도 증가하는 지 확인 필요.</li><li>Consistent Hashing도 실제 부하를 아주 균등하게 나누지는 않음. Adaptive Consistent Hashing 을 이용해 볼 수도 있음.</li></ul></li></ul><h2 id="레디스를-Persistent-Store로-쓴다면"><a href="#레디스를-Persistent-Store로-쓴다면" class="headerlink" title="레디스를 Persistent Store로 쓴다면"></a>레디스를 Persistent Store로 쓴다면</h2><ul><li>무조건 Primary/Secondary 구조로 구성이 필요함</li><li>메모리를 절대로 빡빡하게 사용하면 안됨.<ul><li>정기적인 migration이 필요.</li><li>가능하면 자동화 툴 을 만들어서 이용</li></ul></li><li>RDB/AOF가 필요하다면 Secondary에서만 구동</li></ul>]]></content:encoded>
      
      <comments>https://sehajyang.github.io/2019/12/11/how-to-operate-redis/#disqus_thread</comments>
    </item>
    
    <item>
      <title>10~11월 중순 월간회고</title>
      <link>https://sehajyang.github.io/2019/11/26/191028-191124/</link>
      <guid>https://sehajyang.github.io/2019/11/26/191028-191124/</guid>
      <pubDate>Tue, 26 Nov 2019 10:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;10월 중순(28일) 부터 11월 중순(24일)까지 한 월간 회고가 되었다.&lt;br&gt;월간회고가 되니 한달동안 무엇을 했는지가 기억이 나지 않는다. 역시 월간회고보단 2주 회고가 좋은 것 같다.  &lt;/p&gt;
&lt;h2 id=&quot;한달간-한-학습-및-개발&quot;&gt;&lt;a href=&quot;#한달간-한-학습-및-개발&quot; class=&quot;headerlink&quot; title=&quot;한달간 한 학습 및 개발&quot;&gt;&lt;/a&gt;한달간 한 학습 및 개발&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://festa.io/events/621&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;스포카 크리에이터 컨퍼런스&lt;/a&gt; 참석&lt;/li&gt;
&lt;li&gt;lambda + sqs
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>10월 중순(28일) 부터 11월 중순(24일)까지 한 월간 회고가 되었다.<br>월간회고가 되니 한달동안 무엇을 했는지가 기억이 나지 않는다. 역시 월간회고보단 2주 회고가 좋은 것 같다.  </p><h2 id="한달간-한-학습-및-개발"><a href="#한달간-한-학습-및-개발" class="headerlink" title="한달간 한 학습 및 개발"></a>한달간 한 학습 및 개발</h2><ul><li><a href="https://festa.io/events/621" target="_blank" rel="noopener">스포카 크리에이터 컨퍼런스</a> 참석</li><li>lambda + sqs 사내 스터디 발표</li><li><a href="https://edu.nextstep.camp/c/GwN2MSqv/" target="_blank" rel="noopener">우아한 테크 러닝 - DDD 세레나데 교육</a></li><li><a href="http://www.yes24.com/Product/Goods/18249021?Acode=101" target="_blank" rel="noopener">객체지향의 사실과 오해</a></li><li><a href="http://www.yes24.com/Product/Goods/19040233?scode=032&OzSrank=1" target="_blank" rel="noopener">자바 ORM 표준 JPA 프로그래밍</a></li></ul><h2 id="저번-회고때-설정한-목표-달성을-얼마나-했나"><a href="#저번-회고때-설정한-목표-달성을-얼마나-했나" class="headerlink" title="저번 회고때 설정한 목표 달성을 얼마나 했나"></a>저번 회고때 설정한 목표 달성을 얼마나 했나</h2><p>지난 회고의 목표와 달성은 다음과 같다: </p><ul><li><a href="https://code.plus/course/32" target="_blank" rel="noopener">백준-SW 역량테스트준비</a> 수강<ul><li>SW 역량테스트준비는 차일피일 미루다 다 듣지 못해서 아쉬웠다.  </li></ul></li><li>알고리즘 문제 풀이<ul><li>알고리즘 문제풀이는 중단했었다.</li></ul></li><li>Programming in Scala 공부(시간이 된다면)<ul><li>스칼라 공부를 하기보단 지금 할 줄 아는 언어에 집중해야겠다고 생각했다.</li></ul></li><li><a href="https://festa.io/events/621" target="_blank" rel="noopener">스포카 크리에이터 컨퍼런스</a> 참석<ul><li>스포카 컨퍼런스에 다녀왔다.</li></ul></li></ul><h2 id="스포카-크리에이터-컨퍼런스-참석"><a href="#스포카-크리에이터-컨퍼런스-참석" class="headerlink" title="스포카 크리에이터 컨퍼런스 참석"></a><a href="https://festa.io/events/621" target="_blank" rel="noopener">스포카 크리에이터 컨퍼런스</a> 참석</h2><p>여러가지 세션이 있었지만 나는 예약 문자 발송 최적화를 들으러 참석했다.<br>나 역시 예약 문자 발송 최적화를 하기위해 고민을 했었기 때문이다(그리고 다른회사에선 어떻게 했는지 궁금했다)<br>스포카는 rabbitMQ를 이용해 구현했더라. 나는 예약 문자 발송에 가장 맞는 방법은 MQ + asyncio 라고 생각한다.<br>특히 많은 요청이 발생한다면 더더욱 MQ를 사용해야한다고 생각한다.<br>람다와 SQS로 하기엔 람다 타임아웃 및 SQS에서 호출할수있는 람다수 제한 등의 문제등이 있다.<br>내가 SQS로 구축할 당시에만 해도 FIFO큐에선 람다 트리거를 사용할 수 없었다.<br>단 한번만 보내야하는(중복으로 보내면 안되는) 문자 메세지 특성상 기본 큐 보단 FIFO큐가 좋았지만 람다 트리거를 사용할 수 없어서 기본 큐를 사용했었다.<br>그러나 11월 20일부터 <a href="https://aws.amazon.com/ko/blogs/compute/new-for-aws-lambda-sqs-fifo-as-an-event-source/" target="_blank" rel="noopener">FIFO큐에서 람다 트리거를 사용할 수 있게 됐다!</a><br>어쨌든 기회를 봐서 MQ로 고칠 생각을 하고있다.</p><h2 id="lambda-sqs-사내-스터디-발표"><a href="#lambda-sqs-사내-스터디-발표" class="headerlink" title="lambda + sqs 사내 스터디 발표"></a>lambda + sqs 사내 스터디 발표</h2><p>매주 목요일마다 진행하는 사내 개발 스터디에서 lambda + sqs 이용해 예약문자 서비스를 구축&amp;운영한 내용으로 스터디를 진행했다.<br>슬라이드가 80장정도 나왔는데 그럼에도 불구하고 겉핥기식으로 끝난 것 같아 아쉬웠다.<br>다음주엔 다른 개발자분이 <code>Concurrency in Golang</code> 발표를 한다. 그 유명한(?) 고루틴에 대해 알아볼 기회가 생겼다.<br>go는 어떻게 동시성을 처리할지 궁금하다.</p><h2 id="우아한-테크-러닝-DDD-세레나데-교육"><a href="#우아한-테크-러닝-DDD-세레나데-교육" class="headerlink" title="우아한 테크 러닝 - DDD 세레나데 교육"></a><a href="https://edu.nextstep.camp/c/GwN2MSqv/" target="_blank" rel="noopener">우아한 테크 러닝 - DDD 세레나데 교육</a></h2><p>나는 그간 프로덕션의 코드를 개선하고싶었지만 옳은 방향을 몰라 나름대로 이것저것 해보며 헤매고 있었다.<br>그러던 차에 우아한형제들에서 DDD 교육을 한다는걸 알게되어 신청했는데 운좋게 우아한 테크러닝 DDD 교육에 선발되었다.<br>과정은 총 5주간 매주 화요일에 진행된다. 수강생은 30여명정도고 경쟁률이 쌨다고 들었다. 운이 좋았다.<br>이 과정의 목표는 치킨집 포스 시스템의 레거시 리팩토링이며 매주마다 과제가 나간다.<br>세미나처럼 듣는방식으로 교육이 진행될 줄 알았는데, 과제가 나온다 해서 조금 당황했다.<br>게다가 코드 작성시 주의사항은 9가지 정도 됐는데 꽤 빡빡하고 어려웠다.<br>나름대로 지키려고 노력하니 아직 1주차밖에 안했지만 벌써 코딩 스타일이 달라진게 느껴졌다.<br>과제에 대한 다른사람의 코드를 볼 수도 있다. 같은 기능을 다른 사람은 어떻게 작성했는지 보다보면 재밌고 시간이 금방 가더라.<br>게다가 코드리뷰를 받을 수 있어 좋다. 확실히 코드리뷰를 받으면 실력이 금방 올라가는 것 같다. 이래저래 소중한 경험을 하고있다.<br>아직 내가 제일 못하는 것 같고 배울게 많고 빡세지만 이번 기회에 많이 배워서 꼭 레거시 개선을 하고싶고 좋은 코딩 습관이 들었음 좋겠다.<br>그나저나 나는 내가 나름대로 테스트코드를 잘 짠다고 생각했지만 전혀 아니었다 배울게 많더라..  </p><h2 id="객체지향의-사실과-오해"><a href="#객체지향의-사실과-오해" class="headerlink" title="객체지향의 사실과 오해"></a><a href="http://www.yes24.com/Product/Goods/18249021?Acode=101" target="_blank" rel="noopener">객체지향의 사실과 오해</a></h2><p>이 책은 DDD 교육에서 추천한 도서이다. 이 책은 객체지향이 뭐지? 라고 생각하는 사람이 보면 좋은 도서인 것 같다.<br>아직 초반을 읽고있긴 하지만 두께도 얇고 부담없이 볼 수 있는 내용인 것 같다.  </p><h2 id="자바-ORM-표준-JPA-프로그래밍"><a href="#자바-ORM-표준-JPA-프로그래밍" class="headerlink" title="자바 ORM 표준 JPA 프로그래밍"></a><a href="http://www.yes24.com/Product/Goods/19040233?scode=032&OzSrank=1" target="_blank" rel="noopener">자바 ORM 표준 JPA 프로그래밍</a></h2><p>이 책도 DDD 교육에서 추천한 도서이고 JPA관련 도서중 가장 유명한 도서이다. 알고는 있었지만 보는건 처음이다. 아직 초장을 읽고있다.</p><h2 id="다음주-목표"><a href="#다음주-목표" class="headerlink" title="다음주 목표"></a>다음주 목표</h2><ul><li><a href="https://edu.nextstep.camp/c/GwN2MSqv/" target="_blank" rel="noopener">우아한 테크 러닝 - DDD 세레나데 교육</a> 계속</li><li><a href="http://www.yes24.com/Product/Goods/18249021?Acode=101" target="_blank" rel="noopener">객체지향의 사실과 오해</a> 책 읽기</li><li><a href="http://www.yes24.com/Product/Goods/19040233?scode=032&OzSrank=1" target="_blank" rel="noopener">자바 ORM 표준 JPA 프로그래밍</a></li></ul><h2 id="총평"><a href="#총평" class="headerlink" title="총평"></a>총평</h2><p>초반엔 좀 나태한 한달이었지만 DDD 교육을 듣게되며 다시 빡세졌다. 특히 회사랑 병행하긴 쉽지않더라..<br>교육 난이도는 내가 하기엔 좀 높았다. 그러나 내가 그간 안티패턴의 개발(?) 을 했는지 아닌지, best practice 는 어떤건지 알수있어서 좋았다.  </p>]]></content:encoded>
      
      <comments>https://sehajyang.github.io/2019/11/26/191028-191124/#disqus_thread</comments>
    </item>
    
    <item>
      <title>springboot 2.2 버전으로 업그레이드 하는 방법</title>
      <link>https://sehajyang.github.io/2019/11/12/springboot-migration-1.5to2.0/</link>
      <guid>https://sehajyang.github.io/2019/11/12/springboot-migration-1.5to2.0/</guid>
      <pubDate>Mon, 11 Nov 2019 15:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;안녕하세요, 이 포스팅은 버전 &lt;strong&gt;1.5.9 부터 2.2.1&lt;/strong&gt;(19.11.12 기준 최신 릴리즈)까지의 버전 마이그레이션하는 과정에 대한 내용으로 구성되어있습니다.&lt;br&gt;&lt;a href=&quot;https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;[공식 가이드]&lt;/a&gt;대로 했지만 업그레이드 과정에서 많은 문제를 겪었기 때문에 추후에 삽질을 줄이고자 이 포스팅을 작성하게 되었습니다 😊    &lt;/p&gt;
&lt;p&gt;그리고 한번에 버전을 1.5 -&amp;gt;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>안녕하세요, 이 포스팅은 버전 <strong>1.5.9 부터 2.2.1</strong>(19.11.12 기준 최신 릴리즈)까지의 버전 마이그레이션하는 과정에 대한 내용으로 구성되어있습니다.<br><a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide" target="_blank" rel="noopener">[공식 가이드]</a>대로 했지만 업그레이드 과정에서 많은 문제를 겪었기 때문에 추후에 삽질을 줄이고자 이 포스팅을 작성하게 되었습니다 😊    </p><p>그리고 한번에 버전을 1.5 -&gt; 2.2로 올려버리면 오류를 잡았음에도 불구하고 자꾸 알수 없는 오류가 발생하며 빌드가 되지 않았습니다.<br>혹 이유를 아시는 분은 코멘트 남겨주세요🙇<br>따라서 <code>1.5 -&gt; 2.0 -&gt; 2.2</code> 순서로 버전을 업그레이드 하도록 하겠습니다.</p><h2 id="필수-조건"><a href="#필수-조건" class="headerlink" title="필수 조건"></a>필수 조건</h2><ul><li>JDK 8 이상</li><li>tomcat 8.5 이상(외부 톰캣 사용하는 경우)</li><li>gradle 4.10 이상</li></ul><p>메이져 버전 마이그레이션 시 지원이 중단된 몇가지 서드파티 라이브러리들의 버전을 업그레이드 혹은 대체를 해야할 수도 있습니다.<br><a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.2-Release-Notes" target="_blank" rel="noopener">[springboot 2.2 릴리즈 노트]</a> 에서 변경점을 더 확인할 수 있습니다.</p><h2 id="순서"><a href="#순서" class="headerlink" title="순서"></a>순서</h2><h3 id="1-gradle-버전이-5-0-이-아닐경우-5-0-all-로-변경"><a href="#1-gradle-버전이-5-0-이-아닐경우-5-0-all-로-변경" class="headerlink" title="1. gradle 버전이 5.0 이 아닐경우 5.0-all 로 변경"></a>1. gradle 버전이 5.0 이 아닐경우 5.0-all 로 변경</h3><p>스프링 2.2로의 마이그레이션을 위해선 <code>그래들 버전이 4.10이상</code>이어야 합니다.<br>프레임워크 버전업과 더불어 저는 gradle 버전을 4.10보단 5로 맞췄습니다.<br><code>gradle &gt; wrapper &gt; gradle-wrapper.properties</code> 에서 아래와 같이 gradle 버전을 수정합니다.  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">distributionUrl=https\://services.gradle.org/distributions/gradle-5.0-all.zip</span><br></pre></td></tr></table></figure><p>gradle의 버전을 업그레이드하면 지원이 중단된 플러그인등이 발생할 수 있습니다. deprecated 된 플러그인들을 적절히 대체 및 업그레이드 합니다.<br>(자바 코드상의 변경이 필요할 수도 있습니다)</p><h3 id="2-build-gradle에-dependency-management를-추가"><a href="#2-build-gradle에-dependency-management를-추가" class="headerlink" title="2. build.gradle에 dependency-management를 추가"></a>2. <code>build.gradle</code>에 <code>dependency-management</code>를 추가</h3><p>마이그레이션을 위한 의존성 관리 플러그인을 추가합니다.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'io.spring.dependency-management'</span></span><br><span class="line"><span class="keyword">runtime</span>(<span class="string">"org.springframework.boot:spring-boot-properties-migrator"</span>)</span><br></pre></td></tr></table></figure><h3 id="3-springboot-버전-바꾸기"><a href="#3-springboot-버전-바꾸기" class="headerlink" title="3. springboot 버전 바꾸기"></a>3. springboot 버전 바꾸기</h3><p>build.gradle의 springboot 버전을 변경합니다.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">springBootVersion = <span class="string">'2.2.0.RELEASE'</span></span><br></pre></td></tr></table></figure><h3 id="4-라이브러리-교체와-클래스-변경"><a href="#4-라이브러리-교체와-클래스-변경" class="headerlink" title="4. 라이브러리 교체와 클래스 변경"></a>4. 라이브러리 교체와 클래스 변경</h3><p>컴파일 오류가 난다면 해당되는 오류를 고칩니다.<br>보통은 사용하던 서드파티 라이브러리가 deprecated 되어 대체 후 오류가 나는 경우가 많습니다.<br>(ex:log4j 지원중단으로 log4j2로 고쳤습니다. 따라서 프로젝트에 사용중이던 logger -&gt; log 로 변경되었습니다)<br>버전 업그레이드로 인한 특정 라이브러리 설정의 변화로 발생하는 오류를 해결하는 방법은 다음의 링크에서 확인하실 수 있습니다.</p><ul><li><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/common-application-properties.html" target="_blank" rel="noopener">common-application-properties</a></li><li><a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide#servlet-specific-server-properties" target="_blank" rel="noopener">공식문서 링크</a> </li></ul><blockquote><p>2.1 버전 부턴 mysql 드라이버 명이 변경되었습니다.<br>기존 : com.mysql.jdbc.Driver<br>바뀐것 : com.mysql.cj.jdbc.Driver</p></blockquote><p>또한 몇가지 클래스및 패키지가 변경되었습니다.<br>예를들어:  </p><blockquote><p>WebMvcConfigurerAdapter deprecated로 인한 변경<br>기존 : extends WebMvcConfigurerAdapter<br>변경 : implements WebMvcConfigurer</p></blockquote><blockquote><p>SpringBootServletInitializer 패키지 이름의 변경<br>기존 : import org.springframework.boot.web.support.SpringBootServletInitializer;<br>변경 : import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;</p></blockquote><p>위와 같은 클래스 및 패키지가 변경되었습니다.<br>이러한 변경은 IDE에서 잡아주거나 컴파일시 warn 알림으로 deprecated 되었다는 알림을 주기 때문에<br>그에 맞춰 수정하거나, 2.0 릴리즈 노트에서 확인할 수 있습니다.</p><ul><li><a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Release-Notes" target="_blank" rel="noopener">[Spring Boot 2.0 Release Notes]</a></li></ul><h3 id="5-application-properties-수정"><a href="#5-application-properties-수정" class="headerlink" title="5. application.properties 수정"></a>5. <code>application.properties</code> 수정</h3><p>IDE에서 해당 키워드에 warning 표시를 나타내며 제안에 따라 수정할 수 있습니다.<br>또는 <a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#appendix" target="_blank" rel="noopener">[지원하는 의존성 버전]</a> 문서를 보며 <code>application.properties</code>에서 기존의 키워드를 변경된 키워드로 수정합니다.</p><h3 id="6-bean-overriding"><a href="#6-bean-overriding" class="headerlink" title="6. bean overriding"></a>6. bean overriding</h3><p>해당 변경은 2.1의 릴리즈 노트에서 다음과같이 소개하고 있습니다.<a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes#bean-overriding" target="_blank" rel="noopener">[링크]</a></p><blockquote><p>Bean overriding has been disabled by default to prevent a bean being accidentally overridden. If you are relying on overriding, you will need to set spring.main.allow-bean-definition-overriding to true.</p></blockquote><p>2.1 버전부터 빈의 우연한 재정의를 방지하기위해 default가 false 라고 합니다. 따라서, <strong>been overriding을 사용하려면 true로 명시</strong>해줘야 합니다.<br>명시가 되어있지 않은 경우 다음과 같은 오류가 발생합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.support.Bean Definition Override Exception</span><br></pre></td></tr></table></figure><p>따라서 application.properties에 bean overriding을 허용하는 부분을 추가합니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.main.allow-bean-definition-overriding=<span class="keyword">true</span></span><br></pre></td></tr></table></figure><h3 id="7-‘KST’-is-unrecognized-or-represents-more-than-one-time-zone"><a href="#7-‘KST’-is-unrecognized-or-represents-more-than-one-time-zone" class="headerlink" title="7. ‘KST’ is unrecognized or represents more than one time zone"></a>7. ‘KST’ is unrecognized or represents more than one time zone</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The server time zone value ‘KST’ is unrecognized or represents more than one time zone :   </span><br><span class="line">mysql-connector-java</span><br></pre></td></tr></table></figure><p>위의 오류는 아래와 같이 db name 뒤에 <code>?characterEncoding=UTF-8&amp;serverTimezone=Asia/Seoul</code> 를 추가합니다</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbc:mysql://ip:port/dbname?characterEncoding=UTF-8&amp;serverTimezone=Asia/Seoul</span><br></pre></td></tr></table></figure><h3 id="8-버전-업그레이드-2-0-gt-2-2"><a href="#8-버전-업그레이드-2-0-gt-2-2" class="headerlink" title="8. 버전 업그레이드 2.0 -&gt; 2.2"></a>8. 버전 업그레이드 2.0 -&gt; 2.2</h3><p>빌드 및 run이 성공적으로 되면 <code>build.gradle</code>에서  <code>2.2.1.RELEASE</code> 로 springboot 버전을 변경합니다.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">springBootVersion = <span class="string">'2.2.1.RELEASE'</span></span><br></pre></td></tr></table></figure><p>그 후 4~5번의 작업을 반복하며 오류를 잡습니다.<br>2.0 -&gt; 2.2 로 버전이 올라가며 변경된 점은 springboot 릴리즈 노트에서 확인하며 수정합니다.</p><ul><li><a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.1-Release-Notes" target="_blank" rel="noopener">Spring Boot 2.1 Release Notes</a></li><li><a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.2-Release-Notes" target="_blank" rel="noopener">Spring Boot 2.2 Release Notes</a></li></ul><h3 id="9-properties-migrator-제거"><a href="#9-properties-migrator-제거" class="headerlink" title="9. properties-migrator 제거"></a>9. properties-migrator 제거</h3><p>빌드 및 run이 성공적으로 되면 build.gradle 에서 추가해뒀던 아래 코드를 제거 합니다.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">runtime</span>(<span class="string">"org.springframework.boot:spring-boot-properties-migrator"</span>)</span><br></pre></td></tr></table></figure><h3 id="10-mybatis-configuration-result-maps-0-오류"><a href="#10-mybatis-configuration-result-maps-0-오류" class="headerlink" title="10. mybatis.configuration.result-maps[0] 오류"></a>10. mybatis.configuration.result-maps[0] 오류</h3><p>혹 2.2.0 버전으로의 업그레이드를 한다면 다음과 같은 오류를 만날수도 있습니다.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Caused by: org.springframework.boot.context.properties.bind.BindException: Failed to bind properties under <span class="string">'mybatis.configuration.result-maps[0]'</span> to org.apache.ibatis.mapping.ResultMap</span><br></pre></td></tr></table></figure><p>다음과 같은 오류는 <code>2.2.0.RELEASE (2.2.0.M5 +)</code> 버전에서 발생하고 있는 이슈며 <code>2.2.0.M4</code>와 <code>2.2.1.RELEASE</code> 에선 해결되었습니다.<br>해당 이슈는 스프링부트 깃허브 이슈 <a href="https://github.com/spring-projects/spring-boot/issues/18670" target="_blank" rel="noopener">[Binding fails in presence of a synthetic constructor #18670]</a> 에서 확인할 수 있습니다.</p><p>추가) 만약 swagger를 쓰는데 마이그레이션 시 오류 날 경우 2.9.1로 올려주셔야 됩니다.<br>Lombok, Gradle, JPA 문제등은 <a href="http://honeymon.io/tech/2019/06/17/spring-boot-2-start.html" target="_blank" rel="noopener">[honeymon 님의 스프링 부트 2.x 준비하는 개발자를 위한 안내서]</a> 포스팅에서 자세히 알아보실 수 있습니다.</p><hr><p>이 포스팅은 <a href="https://herrenofficial.github.io/springboot/2019/11/12/springboot-migration-1.5to2.2.html" target="_blank" rel="noopener">헤렌 기술블로그</a>에서도 보실 수 있습니다.<br>혹 내용이 잘못되었거나 보충해야 될 부분이 있다면 코멘트 남겨주세요 🙏<br>읽어주셔서 감사합니다 :)</p><p>참고자료</p><ul><li><a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.2-Release-Notes" target="_blank" rel="noopener">[Spring Boot 2.2 Release Notes]</a></li><li><a href="https://altkomsoftware.pl/en/blog/spring-boot-migration-java/" target="_blank" rel="noopener">spring-boot-migration-java</a></li><li><a href="https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.0-Migration-Guide#servlet-specific-server-properties" target="_blank" rel="noopener">Spring-Boot-2.0-Migration-Guide</a></li><li><a href="http://honeymon.io/tech/2019/06/17/spring-boot-2-start.html" target="_blank" rel="noopener">[honeymon 님의 스프링 부트 2.x 준비하는 개발자를 위한 안내서]</a></li></ul>]]></content:encoded>
      
      <comments>https://sehajyang.github.io/2019/11/12/springboot-migration-1.5to2.0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>191007-191028 3주간 회고</title>
      <link>https://sehajyang.github.io/2019/10/28/191007-191027/</link>
      <guid>https://sehajyang.github.io/2019/10/28/191007-191027/</guid>
      <pubDate>Mon, 28 Oct 2019 09:07:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;회고를 안쓴지 2주가 되었다고 생각했는데 3주가 되었다. 어쩐지 오랫동안 안 쓴 느낌이었다.&lt;br&gt;3주 동안 뭘 했나 생각해봤는데 알고리즘을 문제 풀이를 많이 했던 것 같다.&lt;/p&gt;
&lt;h2 id=&quot;3주간-했던-학습-및-개발&quot;&gt;&lt;a href=&quot;#3주간-했던-학습-및-개발&quot; class=&quot;headerlink&quot; title=&quot;3주간 했던 학습 및 개발&quot;&gt;&lt;/a&gt;3주간 했던 학습 및 개발&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;프로덕션에 도입한 서버리스 문제 해결&lt;/li&gt;
&lt;li&gt;스칼라 번역 포스팅 1개&lt;/li&gt;
&lt;li&gt;알고리즘 문제 풀이&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;프로덕션에-도입한-서버리스-문제-해결&quot;&gt;&lt;a
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>회고를 안쓴지 2주가 되었다고 생각했는데 3주가 되었다. 어쩐지 오랫동안 안 쓴 느낌이었다.<br>3주 동안 뭘 했나 생각해봤는데 알고리즘을 문제 풀이를 많이 했던 것 같다.</p><h2 id="3주간-했던-학습-및-개발"><a href="#3주간-했던-학습-및-개발" class="headerlink" title="3주간 했던 학습 및 개발"></a>3주간 했던 학습 및 개발</h2><ul><li>프로덕션에 도입한 서버리스 문제 해결</li><li>스칼라 번역 포스팅 1개</li><li>알고리즘 문제 풀이</li></ul><h2 id="프로덕션에-도입한-서버리스-문제-해결"><a href="#프로덕션에-도입한-서버리스-문제-해결" class="headerlink" title="프로덕션에 도입한 서버리스 문제 해결"></a>프로덕션에 도입한 서버리스 문제 해결</h2><p>지난 회고때에 언급했던 <a href="https://sehajyang.github.io/2019/10/10/190903-191006/#more">[기존 레거시를 서버리스로 교체]</a>하면서 발생했던 오류를 해결했다.<br><strong>SQS에 DLQ설정을 해둔 상태였는데 해당 큐의 트리거로 설정해둔 Lambda에서도 DLQ 설정을 했기 때문에 문제가 발생했다.</strong><br>처음엔 문제를 해결하기 위해 람다쪽 DLQ를 해제했는데, 해제했음에도 불구하고 DLQ에 붙여둔 람다 트리거 함수가 실행됐다.<br>그때 SQS에 설정해둔 배달 못한 편지 대기열(DLQ) 생각이 났고, SQS측에 설정해둔 DLQ도 해제하자 더이상 알 수 없는 작업실패는 발생하지 않았다.<br>그 이후 lambda에 sentry를 붙여 실패한 작업은 알림을 받으며, 실패한 작업은 배치를 돌려 주기적으로 처리하도록 구성했다.<br>그렇게 구성한 뒤론 아무 오류 없이 잘 동작하고 있는 상태이다.<br>이건 주간회고로 정리하기엔 양이 많은 것 같아 따로 포스팅으로 정리할 생각을 하고있다.<br>서버리스로 개편한 이유는 크게 비용, 처리속도 때문이었는데 한달간 비용이 SQS+Lambda로 만원정도 나온것을 확인했다.<br>EC2 올리는 것보다 훨씬 저렴해서 속도는 물론이고 비용까지 두마리 토끼를 잡을 수 있었다.<br>추후 사용자가 늘어날 것에 대비해 기존 레거시를 고치고 처음부터 설계해보면서 많은 삽질과 에러를 경험하게 되었지만<br>성공적으로 끝나서 굉장히 <del>안심</del>뿌듯했다.<br>SQS에 대한 자료는 구글링해도 별로 없었기 때문에 <code>awskrug</code> 슬랙방에 묻기도 했는데, 많은 고수님들이 있으니 혹 나처럼 도움을 청할 곳이 없는 사람은 awskrug 슬랙방에 질문해 보는것도 좋을 것 같다 :)</p><h2 id="스칼라-번역-포스팅-1개"><a href="#스칼라-번역-포스팅-1개" class="headerlink" title="스칼라 번역 포스팅 1개"></a>스칼라 번역 포스팅 1개</h2><p><a href="https://sehajyang.github.io/2019/10/11/class-vs-case-class/#more">[스칼라 번역 - Class vs Case Classes]</a><br>7월부터 시작한 <a href="https://sehajyang.github.io/tags/scala-exercises/">[스칼라 튜토리얼 번역시리즈]</a> 포스팅은 어느덧 8개가 되었고, 이제 3개만 하면 끝이난다.<br>만약 <a href="https://www.coursera.org/learn/progfun1?action=enroll" target="_blank" rel="noopener">Functional Programming Principles in Scala</a>를 보실분이 있다면 수강하며 이 번역본을 참고하시면 좋을 것 같다.  </p><h2 id="알고리즘-문제풀이"><a href="#알고리즘-문제풀이" class="headerlink" title="알고리즘 문제풀이"></a>알고리즘 문제풀이</h2><p>며칠전부터 <a href="https://code.plus/course/32" target="_blank" rel="noopener">백준-SW 역량테스트준비</a> 수강을 시작했다. 강사는 백준을 만드신 최백준님이다.<br>한달만 들을수 있어 아쉽지만 강의 내용이 좋아서 열심히 수강하고있다.<br>그밖에 3주간 DFS, BFS문제를 풀거나 트리, 힙, 탐색과 관련된 이것저것 문제를 풀었다.<br>특히 DFS문제인 <a href="https://www.acmicpc.net/problem/2667" target="_blank" rel="noopener">[단지번호붙이기]</a> 문제는 DFS 개념 학습뒤 바로 풀기좋은 문제라 조만간 정리해서 포스팅을 올릴생각을 하고있다.<br>예전엔 알고리즘 및 자료구조 개념을 익힐땐 개념학습 후 코드를 본 다음 구현해봤기 때문에 금방 잊기 일쑤였고 내 지식이 되지 않았었다.<br>그러다 최근에 개념만 학습한 뒤 직접 구현해보는 작업을 했는데, 이렇게 학습하니 응용해서 문제를 풀 수도 있었고 확실하게 내 지식이 되어서 좋았다.   </p><h2 id="2주간-목표"><a href="#2주간-목표" class="headerlink" title="2주간 목표"></a>2주간 목표</h2><ul><li><a href="https://code.plus/course/32" target="_blank" rel="noopener">백준-SW 역량테스트준비</a> 수강</li><li>알고리즘 문제 풀이</li><li>Programming in Scala 공부(시간이 된다면)</li><li><a href="https://festa.io/events/621" target="_blank" rel="noopener">스포카 크리에이터 컨퍼런스</a> 참석<ul><li>스포카 컨퍼런스에서 <code>문자 메시지 전송 최적화하기</code> 를 듣기위해 신청했다.<br>나는 이 기능을 SQS+Lambda로 구축했는데, 스포카는 어떻게 했을지 굉장히 궁금하다.</li></ul></li></ul><h2 id="총평"><a href="#총평" class="headerlink" title="총평"></a>총평</h2><p><code>Programming in Scala</code> 공부를 안했는데, 지금 중요한게 이게 아니라는 생각이 들었다.<br>좋아하는 학습보다 지금 나한테 필요한 학습을 하는게 더 좋을 것 같단 판단때문이었다.<br>몇달 아니 몇주 전 까지만 해도 알고리즘은 어렵고 힘든것이었다. 그러나 몇주동안 알고리즘을 풀며 조금은 재밌어진 것 같기도 하다.<br>여전히 어렵고 못하지만 내 힘으로 어찌저찌 풀게 되었다는게 감개무량했다. 어떻게든 돌아가게 짠 뒤 리팩토링 하는 작업도 좋다.<br>저번달엔 슬럼프때문에 쳐저있었는데 이번달엔 조금씩 문제를 풀며 기운을 얻었던 것 같다.<br>무엇보다 과거의 내가 못풀었던 문제를 지금은 풀 수 있었는데 그러한 경험이 슬럼프에서 벗어나는데에 도움이 된 것 같다.    </p>]]></content:encoded>
      
      <comments>https://sehajyang.github.io/2019/10/28/191007-191027/#disqus_thread</comments>
    </item>
    
    <item>
      <title>스칼라 번역 - Class vs Case Classes</title>
      <link>https://sehajyang.github.io/2019/10/11/class-vs-case-class/</link>
      <guid>https://sehajyang.github.io/2019/10/11/class-vs-case-class/</guid>
      <pubDate>Fri, 11 Oct 2019 03:00:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;이 포스팅은 &lt;a href=&quot;https://sehajyang.github.io/tags/scala-exercises/&quot;&gt;[scala-exercises 번역 시리즈]&lt;/a&gt;로 &lt;code&gt;scala-exercises&lt;/code&gt; 사이트의 스칼라 튜토리얼을 공부하며 번역한 문서 입니다.&lt;br&gt;&lt;a href=&quot;https://www.scala-exercises.org/scala_tutorial&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;scala-exercises&lt;/a&gt; 는 스칼라 창시자인 &lt;a href=&quot;https://www.coursera.org/learn/progfun1?action=enroll&quot;
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>이 포스팅은 <a href="https://sehajyang.github.io/tags/scala-exercises/">[scala-exercises 번역 시리즈]</a>로 <code>scala-exercises</code> 사이트의 스칼라 튜토리얼을 공부하며 번역한 문서 입니다.<br><a href="https://www.scala-exercises.org/scala_tutorial" target="_blank" rel="noopener">scala-exercises</a> 는 스칼라 창시자인 <a href="https://www.coursera.org/learn/progfun1?action=enroll" target="_blank" rel="noopener">마틴 오더스키가 만든 강의</a>의 강의자료입니다.<br>따라서 강의를 들으며 본 문서를 같이 보는것을 추천합니다.<br>직역보단 의역을 했기 때문에 의역이 많습니다. 오역 및 오타 등은 코멘트로 알려주세요 😄<br>원문 : <a href="https://www.scala-exercises.org/scala_tutorial/classes_vs_case_classes" target="_blank" rel="noopener">[scala tutorial classes vs case classes]</a></p><hr><h1 id="CLASSES-VS-CASE-CLASSES"><a href="#CLASSES-VS-CASE-CLASSES" class="headerlink" title="CLASSES VS CASE CLASSES"></a>CLASSES VS CASE CLASSES</h1><p>앞 포스팅에서 케이스 클래스를 사용해 어떻게 정보집계를 하는지, 데이터 추상화를 하는지와 상태객체(stateful object)를 정의하는지 알아봤습니다.<br>class와 case class 는 어떤 관계와 어떤 차이점이 있는걸까요?</p><h2 id="생성-및-조작"><a href="#생성-및-조작" class="headerlink" title="생성 및 조작"></a>생성 및 조작</h2><p><code>BankAccount</code>의 정의를 다시 봅시다:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BankAccount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> balance = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">deposit</span></span>(amount: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (amount &gt; <span class="number">0</span>) balance = balance + amount</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">withdraw</span></span>(amount: <span class="type">Int</span>): <span class="type">Int</span> =</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> &lt; amount &amp;&amp; amount &lt;= balance) &#123;</span><br><span class="line">      balance = balance - amount</span><br><span class="line">      balance</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Error</span>(<span class="string">"insufficient funds"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 <code>Note</code>의 케이스 클래스 정의는 다음과 같습니다:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Note</span>(<span class="params">name: <span class="type">String</span>, duration: <span class="type">String</span>, octave: <span class="type">Int</span></span>)</span></span><br></pre></td></tr></table></figure><p><code>BankAccount</code>와 <code>Note</code>의 몇가지 인스턴스를 생성하고 조작 해봅시다:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aliceAccount = <span class="keyword">new</span> <span class="type">BankAccount</span></span><br><span class="line"><span class="keyword">val</span> c3 = <span class="type">Note</span>(<span class="string">"C"</span>, <span class="string">"Quarter"</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">c3.name shouldBe <span class="string">"C"</span></span><br></pre></td></tr></table></figure><p>우린 클래스 인스턴스를 생성하려면 <code>new</code>키워드가 필요한 것을 볼 수 있습니다, 그에 비해 case class는 <code>new</code>키워드가 필요하지 않습니다.<br>또한, case classs 생성자 파라미터는 멤버로 취급되는 반면 일반 클래스의 경우엔 그렇지 않습니다.</p><h3 id="EQUALITY"><a href="#EQUALITY" class="headerlink" title="EQUALITY"></a>EQUALITY</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> aliceAccount = <span class="keyword">new</span> <span class="type">BankAccount</span></span><br><span class="line"><span class="keyword">val</span> bobAccount = <span class="keyword">new</span> <span class="type">BankAccount</span></span><br><span class="line"></span><br><span class="line">aliceAccount == bobAccount shouldBe <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> c3 = <span class="type">Note</span>(<span class="string">"C"</span>, <span class="string">"Quarter"</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> cThree = <span class="type">Note</span>(<span class="string">"C"</span>, <span class="string">"Quarter"</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">c3 == cThree shouldBe <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>위의 예제에서 BankAccount 정의는 다른 값을 도출하는 반면 Note 정의는 동일한 값을 나타냅니다.<br>이전 섹션에서 봤듯이, 상태가있는 클래스는 케이스 클래스에는 존재하지 않는 <code>identity</code> 개념을 보여줍니다.<br>실제로 BankAccount 값은 시간이 지남에 따라 변할 수 있지만 Note의 값은 불변입니다.<br>기본적으로 스칼라에서 두개의 객체를 비교한다는것은 그들의 <code>identity</code> 를 비교한다는 것입니다.<br>하지만 케이스 클래스의 경우엔 집계된 정보의 값을 비교하기 위해 동일성(equality)이 재정의 됩니다.</p><h3 id="Pattern-Matching"><a href="#Pattern-Matching" class="headerlink" title="Pattern Matching"></a>Pattern Matching</h3><p>패턴매칭을 사용해 케이스클래스 인스턴스로부터 정보를 추출하는 방법을 보았습니다.</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c3 <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">Note</span>(name, duration, octave) =&gt; <span class="string">s"The duration of c3 is <span class="subst">$duration</span>"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>기본적으로, 패턴매칭은 일반적인 클래스에서 동작하지 않습니다.</p><h3 id="확장가능성-Extensibility"><a href="#확장가능성-Extensibility" class="headerlink" title="확장가능성(Extensibility)"></a>확장가능성(Extensibility)</h3><p>클래스는 다른 클래스를 확장할 수 있지만, 케이스 클래스는 다른 클래스를 확장할 수 없습니다(동일성(equality)을 올바르게 구현할 수 없기 때문에)</p><h3 id="Case-Class-Encoding"><a href="#Case-Class-Encoding" class="headerlink" title="Case Class Encoding"></a>Case Class Encoding</h3><p>우린 클래스와 케이스클래스간에 주요한 차이점을 보았습니다.<br>케이스 클래스는 클래스의 특수한 경우이며 여러값을 하나의 값으로 모으는 것이 목적입니다.<br>스칼라는 이러한 일반적인 사용 사례를 명시적으로 지원합니다.<br>케이스 클래스를 정의할때 스칼라 컴파일러는 더 많은 메소드와 동반 객체로 향상된 클래스(case class)를 정의합니다.<br>예를들어, 다음과 같은 케이스 클래스 정의는 다음과 같습니다:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Note</span>(<span class="params">name: <span class="type">String</span>, duration: <span class="type">String</span>, octave: <span class="type">Int</span></span>)</span></span><br></pre></td></tr></table></figure><p>다음과 같은 클래스 정의로 확장됩니다:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Note</span>(<span class="params">_name: <span class="type">String</span>, _duration: <span class="type">String</span>, _octave: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Constructor parameters are promoted to members</span></span><br><span class="line">  <span class="keyword">val</span> name = _name</span><br><span class="line">  <span class="keyword">val</span> duration = _duration</span><br><span class="line">  <span class="keyword">val</span> octave = _octave</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Equality redefinition</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">equals</span></span>(other: <span class="type">Any</span>): <span class="type">Boolean</span> = other <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> that: <span class="type">Note</span> =&gt;</span><br><span class="line">      (that canEqual <span class="keyword">this</span>) &amp;&amp;</span><br><span class="line">        name == that.name &amp;&amp;</span><br><span class="line">        duration == that.duration &amp;&amp;</span><br><span class="line">        octave == that.octave</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">canEqual</span></span>(other: <span class="type">Any</span>): <span class="type">Boolean</span> = other.isInstanceOf[<span class="type">Note</span>]</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Java hashCode redefinition according to equality</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">hashCode</span></span>(): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> state = <span class="type">Seq</span>(name, duration, octave)</span><br><span class="line">    state.map(_.hashCode()).foldLeft(<span class="number">0</span>)((a, b) =&gt; <span class="number">31</span> * a + b)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// toString redefinition to return the value of an instance instead of its memory addres</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= <span class="string">s"Note(<span class="subst">$name</span>,<span class="subst">$duration</span>,<span class="subst">$octave</span>)"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a copy of a case class, with potentially modified field values</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">copy</span></span>(name: <span class="type">String</span> = name, duration: <span class="type">String</span> = duration, octave: <span class="type">Int</span> = octave): <span class="type">Note</span> =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Note</span>(name, duration, octave)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Note</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Constructor that allows the omission of the `new` keyword</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name: <span class="type">String</span>, duration: <span class="type">String</span>, octave: <span class="type">Int</span>): <span class="type">Note</span> =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Note</span>(name, duration, octave)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Extractor for pattern matching</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>(note: <span class="type">Note</span>): <span class="type">Option</span>[(<span class="type">String</span>, <span class="type">String</span>, <span class="type">Int</span>)] =</span><br><span class="line">    <span class="keyword">if</span> (note eq <span class="literal">null</span>) <span class="type">None</span></span><br><span class="line">    <span class="keyword">else</span> <span class="type">Some</span>((note.name, note.duration, note.octave))</span><br></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> c3 = <span class="type">Note</span>(<span class="string">"C"</span>, <span class="string">"Quarter"</span>, <span class="number">3</span>)</span><br><span class="line">c3.toString shouldBe <span class="string">"Note(C,Quarter,3)"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> d = <span class="type">Note</span>(<span class="string">"D"</span>, <span class="string">"Quarter"</span>, <span class="number">3</span>)</span><br><span class="line">c3.equals(d) shouldBe <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> c4 = c3.copy(octave = <span class="number">4</span>)</span><br><span class="line">c4.toString shouldBe <span class="string">"Note(C,Quarter,4)"</span></span><br></pre></td></tr></table></figure><p>읽어주셔서 감사합니다. 혹 글에 오역/추가할 내용이 있다면 코멘트 남겨주세요🙆</p>]]></content:encoded>
      
      <comments>https://sehajyang.github.io/2019/10/11/class-vs-case-class/#disqus_thread</comments>
    </item>
    
    <item>
      <title>190903-191010 월간 회고</title>
      <link>https://sehajyang.github.io/2019/10/10/190903-191006/</link>
      <guid>https://sehajyang.github.io/2019/10/10/190903-191006/</guid>
      <pubDate>Thu, 10 Oct 2019 01:29:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;p&gt;미루다보니 월간회고가 되었다. 9월달에 무엇을 했나 생각해보면 떠오르는 것은 다음과 같다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;기존 레거시를 서버리스로 교체&lt;del&gt;로 인한 삽질과 에러의 향연&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;Lambda SQS 1부 포스팅&lt;/li&gt;
&lt;li&gt;우아한 테크 세미나 - 우아한 스프링배치 참가&lt;/li&gt;
&lt;li&gt;스타트업 뽀시래기콘 참가&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;기존-레거시를-서버리스로-교체&quot;&gt;&lt;a href=&quot;#기존-레거시를-서버리스로-교체&quot; class=&quot;headerlink&quot; title=&quot;기존 레거시를 서버리스로 교체&quot;&gt;&lt;/a&gt;기존 레거시를 서버리스로 교체&lt;/h2&gt;&lt;p&gt;이번달의 가장 빅 이슈였다.
          
        
      
      </description>
      
      <content:encoded><![CDATA[<p>미루다보니 월간회고가 되었다. 9월달에 무엇을 했나 생각해보면 떠오르는 것은 다음과 같다.</p><ul><li>기존 레거시를 서버리스로 교체<del>로 인한 삽질과 에러의 향연</del></li><li>Lambda SQS 1부 포스팅</li><li>우아한 테크 세미나 - 우아한 스프링배치 참가</li><li>스타트업 뽀시래기콘 참가</li></ul><h2 id="기존-레거시를-서버리스로-교체"><a href="#기존-레거시를-서버리스로-교체" class="headerlink" title="기존 레거시를 서버리스로 교체"></a>기존 레거시를 서버리스로 교체</h2><p>이번달의 가장 빅 이슈였다. 기존의 메세지 발송 서비스에 추가 기능 개발 요구가 들어오면서 추후에 늘어날 유저수를 고려할 겸 기존 레거시를 뜯어고쳐야겠다고 생각했다.<br>기존 레거시를 개편할 방법으론 1.서버리스로 만들기 2.MQ를 붙이기 등이 있었는데, 서버리스를 선택했다.<br>서버리스를 선택한 이유 중 가장 큰 이유는 비용이었다.<br>과거에 <code>서버리스로 챗봇만들기</code> 정도의 경험만 해봤던 서버리스 왕초보였던 나는 서버리스로 메세지 발송 서비스를 개편하면서 예상대로 많은 삽질과 오류들을 만나게됐다.<br>그러나 해당 오류를 찾아봐도 아직 관련 자료가 많지 않아서 삽질을 많이 했다. 삽질은 크게 구축 삽질과 구축후 운영 삽질로 나뉘었다.<br>구축삽질엔 VPC 셋팅과 VPC를 설정함에 따라 외부 인터넷으로 요청을 보낼 수 없어서 API Gateway를 사용한 것 등이 있었다.<br>구축 후 QA 다 통과하고 프로덕션에 붙인 후 부터 오류가 나기 시작해서 진땀을 뺐다. 가장 큰 문제는 람다 실행시간이었다. 설정해둔 시간제한을 오버하면서 해당 이벤트가 실패하는 일이 많이 발생했다. 급한대로 시간제한을 늘렸는데, 이쯤되면 비용적인 이점은 사라졌다고 보면된다.<br>DLQ를 잘못 셋팅한 문제도 있었다. 그 와중에 에러 로깅도 안되고 정말 혼란이었다.<br>이러한 삽질을 겪으며 한국어로 된 get started 격의 포스팅이 있으면 좋겠다 싶어서 고민끝에 포스팅을 작성을 시작했다.<br> <a href="https://sehajyang.github.io/2019/09/25/sqs-lambda-python/#more">[Lambda SQS 포스팅]</a> 우선 1부를 작성했는데, 회사소스를 캡쳐할 순 없으니 예제를 처음부터 만들어가며 해야되기 때문에 굉장히 시간이 많이 걸린다는 것을 깨달았다. 다음달 안에는 완성하고 싶다.<br>여튼 프로덕션에서 급한불은 껐는데 앞으로도 계속해서 오류가 난다면 서버리스 걷어내고 rabbitMQ를 두는 방식으로 바꿀 생각도 하고있다.</p><h2 id="우아한-테크-세미나"><a href="#우아한-테크-세미나" class="headerlink" title="우아한 테크 세미나"></a>우아한 테크 세미나</h2><p>이동욱님이 발표하시는 <code>우아한 스프링 배치 세미나</code>에 당첨이 되어 9월 26일에 다녀왔다.<br>원래 이번에 서버리스로 바꾼 메세지 발송 서비스를 초기엔 스프링 배치로 돌릴까 하는 생각을 했었다. 실제로 기존엔 배치로 돌아가고 있었다.<br>어쨌든 우리 프로덕션에서 스프링 배치를 안티패턴으로 사용하고 있는건 아닌지, best prectice는 어떨지 궁금해서 신청했었다.<br>내용은 굉장히 좋았고 후기를 따로 포스팅 하려고 했는데, 이미 다른 분들이 좋은 후기 포스팅을 하셨다. 굳이 바퀴를 재발명할 필요는 없을 것 같아서 후기 포스팅은 패스했다.<br><a href="https://www.youtube.com/watch?v=_nkJkWVH-mo" target="_blank" rel="noopener">[우아한 배치 영상]</a><br><a href="https://jojoldu.tistory.com/451" target="_blank" rel="noopener">[이동욱님의 Spring Batch의 멱등성 유지하기]</a><br><a href="https://taetaetae.github.io/2019/09/29/woowabros-spring-batch/" target="_blank" rel="noopener">[태태태님의 우아한 스프링 배치 테크세미나 정리 및 후기]</a></p><h2 id="스타트업-뽀시래기-콘-참가"><a href="#스타트업-뽀시래기-콘-참가" class="headerlink" title="스타트업 뽀시래기 콘 참가"></a>스타트업 뽀시래기 콘 참가</h2><p>스타트업 뽀시래기 콘에 참가했다. 주말임에도 불구하고 많은분들이 오셨던 것 같다. 도움이 되는 내용이 굉장히 많았다.  </p><h2 id="다음주-목표"><a href="#다음주-목표" class="headerlink" title="다음주 목표"></a>다음주 목표</h2><ul><li>CS(computer science) 공부</li><li>Programming in Scala 공부</li></ul><h2 id="총평"><a href="#총평" class="headerlink" title="총평"></a>총평</h2><p>대략 1년에 한번 10월즈음 슬럼프가 오는 것 같다. 한달간 따로 공부한건 서버리스를 위한 학습과 간간히 하던 스칼라 학습 말곤 없었던 것 같다.<br>그래서 주간회고가 미뤄졌다. 쓸 게 없었기 때문이다. 그것에 대해서 생각을 해봤는데, 그냥 기존에 하던식의 학습을 하기엔 이젠 한계에 다다랐다.<br>게다가 최근엔 굉장히 기본적인 몇가지 질문에 답을 할 수 없었던 일이 있었다. 아무리 복습을 안하면 까먹는다지만 이건 심했다.<br>이것도 모르면서 개발자라고 말하기엔 스스로가 부끄럽다는 생각이 들었다.<br>사실 이론적인 것을 몰라도 개발은 할 수 있다. 하지만 그런 개발자가 되고싶진 않았다.<br>결론적으로 이제는 이론적인 공부를 피해갈 수 없게 되었다. 대학교 다닐 때 했던 CS 공부는 시험과 함께 까먹었으므로 다시해야한다.<br>아직 어떤 책으로 공부할건지 정하진 않았지만 다음주 내에 책을 골라 공부를 시작하는게 목표이다.</p>]]></content:encoded>
      
      <comments>https://sehajyang.github.io/2019/10/10/190903-191006/#disqus_thread</comments>
    </item>
    
    <item>
      <title>SQS, Lambda를 이용해 문자전송하기(1부)</title>
      <link>https://sehajyang.github.io/2019/09/25/sqs-lambda-python/</link>
      <guid>https://sehajyang.github.io/2019/09/25/sqs-lambda-python/</guid>
      <pubDate>Wed, 25 Sep 2019 08:31:35 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;h3 id=&quot;들어가며&quot;&gt;&lt;a href=&quot;#들어가며&quot; class=&quot;headerlink&quot; title=&quot;들어가며&quot;&gt;&lt;/a&gt;들어가며&lt;/h3&gt;&lt;p&gt;이 포스팅은 전체적으로 Get Started의 성격을 띄며 3부로 나눠져 있습니다.&lt;br&gt;좌측 사이드바에서 목차 빠른 이동이 가능합니다.&lt;/p&gt;
&lt;h3 id=&quot;1부&quot;&gt;&lt;a href=&quot;#1부&quot; class=&quot;headerlink&quot; title=&quot;1부&quot;&gt;&lt;/a&gt;1부&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;하고자 하는 것&lt;/li&gt;
&lt;li&gt;SQS란?&lt;/li&gt;
&lt;li&gt;아키텍쳐&lt;ul&gt;
&lt;li&gt;Skill Set&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;구축 과정&lt;ul&gt;
&lt;li&gt;SQS 생성 및 설정
          
        
      
      </description>
      
      <content:encoded><![CDATA[<h3 id="들어가며"><a href="#들어가며" class="headerlink" title="들어가며"></a>들어가며</h3><p>이 포스팅은 전체적으로 Get Started의 성격을 띄며 3부로 나눠져 있습니다.<br>좌측 사이드바에서 목차 빠른 이동이 가능합니다.</p><h3 id="1부"><a href="#1부" class="headerlink" title="1부"></a>1부</h3><ul><li>하고자 하는 것</li><li>SQS란?</li><li>아키텍쳐<ul><li>Skill Set</li></ul></li><li>구축 과정<ul><li>SQS 생성 및 설정 <ul><li>SQS 큐 생성</li><li>SQS 큐 설정</li><li>SQS 권한설정</li></ul></li><li>Lambda 생성 및 SQS로 메세지 전송하기<ul><li>Lambda 함수생성</li><li>Lambda 함수에 SQS, RDS 권한 추가</li><li>SQS에 메세지 전송하기</li></ul></li><li>Lambda layer로 DB 조회를 위한 외부 라이브러리 추가</li></ul></li></ul><h3 id="2부"><a href="#2부" class="headerlink" title="2부"></a>2부</h3><ul><li>Lambda에서 EC2, RDS등 내부 서비스 접근 문제 해결하기<ul><li>VPC설정으로 접근하기</li><li>VPC 란?</li><li>Lambda 함수에 VPC 셋팅하기</li></ul></li><li>SQS에 메세지를 보내기 위한 VPC 설정<ul><li>VPC 추가한 상태로 외부 인터넷에 요청을 보내기 위한 방법들</li><li>VPC에 SQS 엔드포인트 추가</li><li>SQS에 메세지 전송하기</li></ul></li><li>Cloud Watch Event로 Cron Job 붙이기<ul><li>주의할 점</li></ul></li><li>SQS 큐에 람다 트리거 함수 붙이기</li></ul><h3 id="3부"><a href="#3부" class="headerlink" title="3부"></a>3부</h3><ul><li>VPC 설정되어 있는 람다함수가 외부 인터넷에 요청 보내기 <ul><li>API Gateway</li><li>생성 및 설정</li></ul></li><li>예외처리를 위한 DLQ 설정</li><li>운영 하면서 겪은 문제들<ul><li>요금이 이렇게 나오다니?</li><li>람다 타임아웃</li><li>잘못된 DLQ 설정</li><li>에러 핸들링</li></ul></li><li>예약문자 서비스를 위한 가장 좋은 설계<ul><li>MQ</li></ul></li><li>총평</li></ul><h2 id="하고자-하는-것"><a href="#하고자-하는-것" class="headerlink" title="하고자 하는 것"></a>하고자 하는 것</h2><p>외부 문자발송 API에 예약문자 발송 요청을 보내는 작업을 해야합니다. 단 조건이 있습니다.</p><ul><li>예약문자가 발송되기 전이면 취소가 가능해야 합니다.</li><li>분할전송되는 문자의 순서를 보장하려고 합니다.<br>분할전송되는 문자 순서의 경우, 순서에 맞게 요청을 보내도 문자 발송 API측에서 요청이 동시에 들어올 경우 순서를 섞어 발송합니다.<br>분할문자의 순서가 섞이는 것을 방지하려면 많은 방법이 있지만 그 중 SQS의 <code>DelaySeconds</code> 옵션을 사용해 해결할 것 입니다.</li></ul><h3 id="Amazon-SQS란"><a href="#Amazon-SQS란" class="headerlink" title="Amazon SQS란?"></a>Amazon SQS란?</h3><p><strong>SQS(Simple Queue Service)</strong>는 분산 메세지 큐 서비스로 메세지에 대한 수신, 송신만이 가능한 큐 입니다.<br><strong>인터넷을 통해 통신</strong>하며 웹 서비스 응용 프로그램을 통해 메세지를 전송할 수 있습니다.<br><strong>풀링(polling)</strong> 방식으로 동작하기 때문에 <a href="https://bcho.tistory.com/683" target="_blank" rel="noopener">수신자는 매번 풀링하는 식으로 로직을 구성해야합니다.</a><br>폴링은 <a href="https://aws.amazon.com/ko/blogs/korea/aws-lambda-adds-amazon-simple-queue-service-to-supported-event-sources/" target="_blank" rel="noopener">유연하게 동작합니다.</a><br>메세지 보관기간 지정, 전송 지연시간 지정, 실패한 작업을 배달못한 편지 대기열(DeadQueue)로 전송할 수 있는 기능등이 있습니다.<br>백만 요청당 가격은 표준 : $ 0.40 / FIFO : $ 0.50 로 저렴한 편입니다.<br>메세지는 최대 10개, 256KB 배치 송수신이 가능하며 <a href="https://docs.aws.amazon.com/ko_kr/AWSSimpleQueueService/latest/SQSDeveloperGuide/reducing-costs.html" target="_blank" rel="noopener">SQS 배치 API 작업으로 비용을 절감</a>할 수 있습니다.<br>대기열 종류로는 <strong>표준과 FIFO</strong>를 제공합니다.</p><table><thead><tr><th></th><th>표준</th><th>FIFO</th></tr></thead><tbody><tr><td>처리량</td><td>무제한으로 초당 트랜잭션(TPS)수 지원</td><td>일괄처리를 통해 초당 3000개 혹은 API작업별로 300개 메세지를 지원</td></tr><tr><td>전달</td><td>최소 한번 전달이지만 가끔 <a href="https://docs.aws.amazon.com/ko_kr/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-visibility-timeout.html" target="_blank" rel="noopener"><strong>두번이상 전달되기도 함</strong></a></td><td>정확히 한번 전달</td></tr><tr><td>순서</td><td>순서보장 안됨</td><td>순서보장 됨</td></tr><tr><td>람다</td><td>Lambda 트리거 가능</td><td><a href="https://docs.aws.amazon.com/ko_kr/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-configure-lambda-function-trigger.html" target="_blank" rel="noopener">Lambda 트리거 불가능</a> 19/11/20 이후로 가능하게 변경되었습니다 <a href="https://aws.amazon.com/ko/blogs/compute/new-for-aws-lambda-sqs-fifo-as-an-event-source/" target="_blank" rel="noopener">[링크]</a></td></tr></tbody></table><p>여기서 중요하게 봐야될 점은 순서보장과 Lambda 트리거 가능 여부입니다.<br><strong>FIFO는 Lambda 트리거를 지원하지 않았습니다.</strong><br>하지만 2019/11/20 이후로 FIFO에서도 람다 트리거를 사용할 수 있도록 변경되었습니다.<a href="https://aws.amazon.com/ko/blogs/compute/new-for-aws-lambda-sqs-fifo-as-an-event-source/" target="_blank" rel="noopener">[관련 링크]</a><br>이 포스팅을 작성할 당시 FIFO에서는 람다트리거를 사용할 수 없었기 때문에 저는 표준 대기열을 선택했지만, 순서가 중요하거나 한번만 전달되어야한다면 FIFO를 선택하시는게 좋습니다.</p><blockquote><p>추가1)<br>SQS 트리거에 Lambda를 붙일 경우, Lambda는 <strong>연속적</strong>으로 SQS대기열을 장기 풀링합니다.<br>Lambda는 <strong>풀링을 자동조절</strong> 합니다.<br>대기열이 비어있을땐 5개의 <strong>병렬 폴링 연결</strong>을 하며, <strong>처리중인 메세지 수가 증가할 경우 메세지 요청을 20회, 동시성을 분당 60회 증가시킵니다.</strong><br>대기열이 계속 분주할 경우 동시성이 제한에 다다를 때 까지 요청과 동시성은 계속 증가됩니다.<br>처리중인 메세지가 하락중일 경우엔 분당 요청을 10회, 동시성을 30회씩 감소시킵니다.<br>만약 동시성등을 더 증가시켜야 한다면 aws측에 문의를 해서 제한을 풀어야합니다. </p></blockquote><blockquote><p>추가2)<br>Lambda와 SQS는 반드시 같은 AWS 리전에 있어야 합니다.<br>하나 이상의 Lambda함수에 하나의 SQS대기열만 연결할 수 있습니다. <a href="https://docs.aws.amazon.com/ko_kr/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-configure-lambda-function-trigger.html" target="_blank" rel="noopener">[관련 링크]</a></p></blockquote><h3 id="아키텍쳐"><a href="#아키텍쳐" class="headerlink" title="아키텍쳐"></a>아키텍쳐</h3><h4 id="기술스택"><a href="#기술스택" class="headerlink" title="기술스택"></a>기술스택</h4><ul><li>Python 3.7</li><li>AWS Lambda</li><li>AWS SQS</li><li>AWS API Gateway</li><li>AWS VPC</li><li>AWS RDS</li><li>AWS CloudWatch</li></ul><p><img src="https://i.imgur.com/g2ykNdN.png" alt="arch"></p><center><span style="color:grey;">최종적으로 위와같은 구조가 됩니다</span></center><p>각 서비스에 대한 설명은 다음과 같습니다.<br><strong>send sqs func</strong> : 매 분마다 지금으로부터 발송 1분전의 시간으로 DB조회를 하고 delay를 계산해 SQS에 메세지 송신을 하는 람다 함수입니다.<br><strong>sqs trigger func</strong> : SQS의 람다 트리거 함수입니다. API Gateway로 요청을 보내고 응답을 받아서 DB(RDS)에 저장합니다.<br><strong>main queue</strong> : send sqs로부터 메세지를 수신한 뒤 sqs trigger가 주기적으로 풀링해 메세지를 가져옵니다.<br><strong>API Gateway</strong> : 내부 서비스가 외부 인터넷으로 요청을 보낼수 있게 도와줍니다. </p><p>플로우는 다음과 같습니다.</p><ol><li>send_sqs_func가 rds에 1분후에 보내야될 데이터를 조회하는 요청을 보냅니다</li><li>조회된 데이터로 SQS 전송 delay시간을 조정해 같은 사람에게 보낼 문자의 순서가 섞이지 않도록 값을 셋팅후 SQS로 메세지를 전송합니다.</li><li>SQS에 쌓여있는 데이터를 sqs_trigger_func가 지속적으로 풀링해 가져옵니다.</li><li>sqs_trigger_func 에서 Api Gateway를 통해 외부 문자 API로 요청을 보냅니다.</li><li>Exception이 발생한 경우 dead_queue로 해당 메세지를 보냅니다.</li></ol><p>그럼 바로 예제에 들어가도록 하겠습니다.</p><h3 id="구축과정"><a href="#구축과정" class="headerlink" title="구축과정"></a>구축과정</h3><h4 id="SQS-생성-및-설정"><a href="#SQS-생성-및-설정" class="headerlink" title="SQS 생성 및 설정"></a>SQS 생성 및 설정</h4><p>우선 SQS를 생성하겠습니다. 위 아키텍쳐에서 설명했던 것과 같이 두개의 SQS 큐를 생성할 것 입니다.</p><p><img src="https://i.imgur.com/OqKJT7P.jpg" alt="sqs-create1"><br>우선 표준대기열로 <strong>main queue</strong>를 생성합니다.  </p><p><img src="https://i.imgur.com/JBOkzmn.jpg" alt="sqs-create2"><br>우측 하단의 대기열 구성에서 세부적인 속성을 제어할 수 있습니다. </p><p>아직 속성을 설정하지 않을 것이므로 속성을 기본값으로 놔둔 뒤 대기열을 생성합니다.<br>main queue와 동일한 방법으로  <strong>dead queue</strong>를 생성합니다.<br>이제 생성된 큐 중 <strong>main queue</strong> 의 속성 중 리드라이브 정책 사용을 활성화 합니다.</p><h4 id="SQS-큐-설정"><a href="#SQS-큐-설정" class="headerlink" title="SQS 큐 설정"></a>SQS 큐 설정</h4><p><img src="https://i.imgur.com/0pAGqEa.jpg" alt="sqs-config1"><br><img src="https://i.imgur.com/yeXkt2k.jpg" alt="sqs-config2"><br>배달못한 편지 대기열은 dead_queue로 설정 뒤 변경사항을 저장합니다.  </p><p>SQS의 기본설정은 short polling입니다. 만약 비용을 줄이고 싶다면 <strong>메시지 수신 대기시간</strong>을 조정해야 합니다.<br>다음과 같은 경우 short polling 입니다:</p><blockquote><p>WaitTimeSeconds이 0으로 설정되어있는 경우<br>ReceiveMessageWaitTimeSeconds이 0으로 설정되어 있는 경우</p></blockquote><p>SQS의 long polling 과 short polling에 대해 더 알고 싶다면 [<a href="https://docs.aws.amazon.com/ko_kr/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-short-and-long-polling.html" target="_blank" rel="noopener">공식문서</a>]를 참고해주세요.</p><h4 id="SQS-권한-설정"><a href="#SQS-권한-설정" class="headerlink" title="SQS 권한 설정"></a>SQS 권한 설정</h4><p>sqs가 외부로부터 메세지를 수신받기 위해선 다음과 같은 권한이 필요합니다:</p><blockquote><p>sqs:ChangeMessageVisibility<br>sqs:DeleteMessage<br>sqs:GetQueueAttributes<br>sqs:ReceiveMessage</p></blockquote><p>권한 설정은 하단의 <strong>권한</strong> 탭에서 추가할 수 있습니다.</p><p><img src="https://i.imgur.com/sY6j57E.jpg" alt="sqs-auth1"></p><center><span style="color:grey;">권한 추가 버튼을 클릭합니다.</span></center><p><img src="https://i.imgur.com/iFsRrK0.jpg" alt="sqs-auth2"></p><center><span style="color:grey;">프린시펄이 있다면 설정합니다.</span></center><p>권한설정 후 하단의 권한추가로 완료합니다.</p><h3 id="Lambda-생성-및-SQS로-메세지-전송하기"><a href="#Lambda-생성-및-SQS로-메세지-전송하기" class="headerlink" title="Lambda 생성 및 SQS로 메세지 전송하기"></a>Lambda 생성 및 SQS로 메세지 전송하기</h3><p><strong>send sqs func, sqs trigger func</strong> 라는 두개의 람다 함수를 만들 것입니다.<br>우선 <strong>send sqs func</strong>를 만들어보겠습니다. </p><p><img src="https://i.imgur.com/CvJSW5m.jpg" alt="lambda-create"><br>새 역할생성을 선택한 뒤 함수를 생성합니다.</p><h4 id="Lambda-함수에-SQS-RDS-권한-추가"><a href="#Lambda-함수에-SQS-RDS-권한-추가" class="headerlink" title="Lambda 함수에 SQS, RDS 권한 추가"></a>Lambda 함수에 SQS, RDS 권한 추가</h4><p>send sqs func는 위 아키텍쳐 섹션에서 설명했듯이 DB 조회결과를 sqs 큐로 보내는 작업을 하는 함수입니다.<br>따라서 정책에 SQS와 RDS권한을 추가합니다.<br>생성된 람다함수에 권한을 추가하기 위해<br>함수코드 아래에 그림과 같이 실행역할 &gt; 기존역할 &gt; <code>send-sqs-func-role-0opyfljq 역할을 확인하십시오.</code>를 클릭합니다.</p><p><img src="https://i.imgur.com/QbJk4op.jpg" alt="lambda-auth1"><br><img src="https://i.imgur.com/At14nEw.jpg" alt="lambda-auth2"><br><img src="https://i.imgur.com/DU4135J.jpg" alt="lambda-auth3"><br>권한이 성공적으로 추가되었다면 send sqs func 페이지에서 새로고침을 합니다.</p><p><img src="https://i.imgur.com/9dcEk1D.jpg" alt="lambda-auth4"><br>성공적으로 추가가 되었습니다.</p><h4 id="SQS에-메세지-전송하기"><a href="#SQS에-메세지-전송하기" class="headerlink" title="SQS에 메세지 전송하기"></a>SQS에 메세지 전송하기</h4><p>SQS의 <code>main queue</code>에 메세지를 보내는 코드를 lambda_function에 작성합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> boto3</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> botocore.exceptions <span class="keyword">import</span> ClientError</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lambda_handler</span><span class="params">(event, context)</span>:</span></span><br><span class="line">    _params = &#123;<span class="string">'message'</span>: <span class="string">"hello"</span>&#125;</span><br><span class="line"></span><br><span class="line">    msg_body = json.dumps(_params)</span><br><span class="line">    msg = send_sqs_message(os.environ[<span class="string">'SQS_QUEUE'</span>], msg_body)</span><br><span class="line">    <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_sqs_message</span><span class="params">(sqs_queue_url, msg_body)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param sqs_queue_url: String URL of existing SQS queue</span></span><br><span class="line"><span class="string">    :param msg_body: String message body</span></span><br><span class="line"><span class="string">    :return: Dictionary containing information about the sent message. If</span></span><br><span class="line"><span class="string">        error, returns None.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Send the SQS message</span></span><br><span class="line">    sqs_client = boto3.client(<span class="string">'sqs'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        msg = sqs_client.send_message(QueueUrl=sqs_queue_url,</span><br><span class="line">                                      MessageBody=msg_body)</span><br><span class="line">    <span class="keyword">except</span> ClientError <span class="keyword">as</span> e:</span><br><span class="line">        logging.error(e)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> msg</span><br></pre></td></tr></table></figure><blockquote><p>boto3 란?<br>python용 aws sdk 입니다.<br>람다에선 실행환경의 일부로 aws sdk의 여러버전이 포함되어 있으므로 굳이 설치하지 않아도 됩니다.</p></blockquote><p><img src="https://i.imgur.com/8m0DWOl.jpg" alt="sqs-send1.1"><br>함수코드 하단의 환경변수에서 <code>SQS_QUEUE</code>를 추가합니다. </p><p><img src="https://i.imgur.com/QjRxA1A.jpg" alt="sqs-send1"><br>환경변수 <code>SQS_QUEUE</code>키에대한 값은 SQS main_queue의 URL 이며 SQS대기열 세부정보에서 확인할 수 있습니다.</p><p><img src="https://i.imgur.com/6P3pK2f.jpg" alt="sqs-send2"><br>람다 테스트는 기본 이벤트를 선택한 후 다음과 같이 생성합니다.<br>오른쪽 상단의 save 후 테스트를 실행합니다.</p><p><img src="https://i.imgur.com/dHrBSVe.jpg" alt="sqs-send3"></p><p><img src="https://i.imgur.com/OmP9njg.jpg" alt="sqs-send4"><br>SQS에서 방금 송신한 메세지가 main queue에 있는것을 확인할 수 있습니다.</p><h4 id="Lambda-layer로-DB-조회를-위한-외부-라이브러리-추가"><a href="#Lambda-layer로-DB-조회를-위한-외부-라이브러리-추가" class="headerlink" title="Lambda layer로 DB 조회를 위한 외부 라이브러리 추가"></a>Lambda layer로 DB 조회를 위한 외부 라이브러리 추가</h4><p>이제 RDS에 접근해 DB커넥션을 생성해보도록 하겠습니다.<br>외부 라이브러리인 pymysql을 람다에서 사용해야합니다.<br>우선 인라인 편집에서 DB 커넥션을 생성하는 부분을 lambda_function.py에 작성합니다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> boto3</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> botocore.exceptions <span class="keyword">import</span> ClientError</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lambda_handler</span><span class="params">(event, context)</span>:</span></span><br><span class="line">    get_connection()</span><br><span class="line">    _params = &#123;<span class="string">'message'</span>: <span class="string">"hello"</span>&#125;</span><br><span class="line"></span><br><span class="line">    msg_body = json.dumps(_params)</span><br><span class="line">    msg = send_sqs_message(os.environ[<span class="string">'SQS_QUEUE'</span>], msg_body)</span><br><span class="line">    <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">send_sqs_message</span><span class="params">(sqs_queue_url, msg_body)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    :param sqs_queue_url: String URL of existing SQS queue</span></span><br><span class="line"><span class="string">    :param msg_body: String message body</span></span><br><span class="line"><span class="string">    :return: Dictionary containing information about the sent message. If</span></span><br><span class="line"><span class="string">        error, returns None.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Send the SQS message</span></span><br><span class="line">    sqs_client = boto3.client(<span class="string">'sqs'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        msg = sqs_client.send_message(QueueUrl=sqs_queue_url,</span><br><span class="line">                                      MessageBody=msg_body)</span><br><span class="line">    <span class="keyword">except</span> ClientError <span class="keyword">as</span> e:</span><br><span class="line">        logging.error(e)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> msg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_connection</span><span class="params">()</span>:</span></span><br><span class="line">    connection = pymysql.connect(host=os.environ[<span class="string">'DB_ADDR'</span>],</span><br><span class="line">                                 user=os.environ[<span class="string">'DB_HOST'</span>],</span><br><span class="line">                                 password=os.environ[<span class="string">'DB_PASSWD'</span>],</span><br><span class="line">                                 db=os.environ[<span class="string">'DB_NAME'</span>],</span><br><span class="line">                                 charset=<span class="string">'utf8mb4'</span>,</span><br><span class="line">                                 autocommit=<span class="literal">True</span>,</span><br><span class="line">                                 cursorclass=pymysql.cursors.DictCursor)</span><br><span class="line">    <span class="keyword">return</span> connection</span><br></pre></td></tr></table></figure><p>이제 람다 레이어에 사용할 외부 라이브러러를 추가할 것입니다.<br>람다 레이어 설정에 대한 내용은 이 포스팅을 참고해주세요 : <a href="https://beomi.github.io/2018/11/30/using-aws-lambda-layers-on-python3/" target="_blank" rel="noopener">[AWS Lambda Layers로 함수 공통용 Python 패키지 재사용하기]</a><br>람다 레이어에 올리기전 <strong>외부 라이브러리를 패키징할 때 주의할 점</strong>이 있습니다.<br><strong>압축을 풀었을 시 패키지들의 상위 폴더 이름은 python 이어야 합니다</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-python</span><br><span class="line">    - 패키지폴더 1</span><br><span class="line">    - 패키지폴더 2</span><br></pre></td></tr></table></figure><p>그렇지 않으면 라이브러리 import가 되지 않는다는 오류가 발생합니다.<br>람다 레이어에 올린 라이브러리 압축파일은 aws측에서 내부적으로 압축 해제 후 다음과 같이 <code>/opt</code> 아래에 둡니다.  </p><blockquote><p>/opt/python/패키지1</p></blockquote><p>따라서 패키지의 상위 폴더 이름은 python 이어야 합니다.  </p><blockquote><p>opt/python/lib/python3.7/dist-package/</p></blockquote><p>도 가능하기 때문에 패키지들의 상위 폴더가 <code>/python/lib/python3.7/dist-package/</code> 여도 됩니다.<br>마찬가지로 node등은 node로 상위 폴더 이름을 설정합니다.</p><p><img src="https://i.imgur.com/RhatvNJ.jpg" alt="sqs-db2"><br>프로젝트 파일을 zip으로 압축한 뒤 code entry type &gt; .zip 파일 업로드로 방금 생성한 프로젝트 파일을 업로드합니다<br>(aws cli를 사용중이라면 좀 더 편하게 배포할 수 있습니다)<br>DB 접속정보등을 환경변수에 셋팅 후 상단의 save를 하고 테스트를 실행합니다.<br>만약 RDS가 모든 접근을 허용한다면 아무 오류없이 성공을 출력할 것 입니다.<br>하지만 RDS 인바운드에 몇가지 접근에 대해서만 허용해뒀다면 다음과 같이 타임아웃이 발생합니다.<br><img src="https://i.imgur.com/AUpXUuM.jpg" alt="sqs-db3"><br>왜 그런걸까요? Lambda 함수가 보안그룹 설정이 되어있는 RDS에 접근할 수 없기 때문입니다.<br>lambda 함수가 왜 RDS에 접근을 할 수 없는지에 대해 알기위해선 먼저 VPC에 대해서 알아야 합니다. </p><p>2부에선 VPC가 무엇이며 RDS 및 SQS 접근 문제를 해결해보도록 하겠습니다.</p><p><strong>2부에 계속..</strong></p><hr><p>읽어주셔서 감사합니다. 혹 궁금한게 있으시거나 오류가 있다면 댓글 남겨주세요🙆</p>]]></content:encoded>
      
      <comments>https://sehajyang.github.io/2019/09/25/sqs-lambda-python/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
